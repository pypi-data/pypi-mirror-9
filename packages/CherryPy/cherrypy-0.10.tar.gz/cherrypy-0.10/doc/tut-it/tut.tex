\documentclass{manual}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}

\title{CherryPy Tutorial}

\input{boilerplate}

\begin{document}

\maketitle

\ifhtml
\chapter*{Copertina}
\fi

\input{copyright}

\begin{abstract}

\noindent
CherryPy è un tool Python-based per sviluppare siti web dinamici. Provvede tutte le caratteristiche di un application server enterprise-class pur restando veloce e facile
da imparare.

CherryPy permette a sviluppatori di costruire applicazioni web nello stesso modo in
cui avrebbero scritto qualsiasi altro programma object-oriented in Python.
Il risultato è poco codice sviluppato in tempi brevi.

Unisce molti concetti innovativi, che lo
rendono unico nel suo approccio per lo sviluppo di siti web.

Può essere utilizzato su molte piattaforme (in pratica in tutte quelle dove può essere
installato ed eseguito Python) ed è disponibile sotto licenza GPL.

CherryPy è ora un prodotto con quasi 2 anni di sviluppo ed è provato in quanto 
a stabilità e velocità. E' attualmente usato nella produzioni di molti siti, dai
più semplici a quelli più esigenti.

Cosa non meno importante: è divertente lavorare con CherryPy :-)

\end{abstract}

\tableofcontents

\chapter{Download, installazione ed esecuzione demo}

\section{Prerequisiti}

CherryPy usa 100\% puro codice Python, in tal modo può essere eseguito ovunque è presente
Python (Windows, Unix, Max, ...).
Tutto ciò di cui avrete bisogno è una distribuzione di Python 2.1, o maggiore, presente
sulla vostra macchina.

\section{Download ed installazione}

Scaricate l'ultima versione di CherryPy da questa pagina \url{http://www.cherrypy.org/download} 
e unzippate/untarrate il file.

Questa operazione creerà un directory \strong{CherryPy-version/} con diversi file e sottodirectory.

\section{Eseguire i demo}

Entrate nella directory \file{demo/} e digitate il seguente comando:

\begin{verbatim}
python ../cherrypy.py Root.cpy
\end{verbatim} \footnote{\samp{python} deve essere presente nel vostro PATH and e deve essere almeno la versione 2.1 o maggiore} \footnote{Se \var{make} è installato sulla vostra macchina potete semplicemente digitare \samp{make}}

Questo creerà un file chiamato \file{RootServer.py}

Per eseguirlo basterà:

\begin{verbatim}
[remi@serveur demo]$ python RootServer.py
Reading parameters from RootServer.cfg ...
Calling initServer() ...
Reading gaz station database for the Prestation demo ...
Done reading database
Starting Httpd service ...
Server parameters:
portOrUnixFile: 8000
numberOfProcs: 1
staticContentList: [('images', 'images')]
Serving on 8000
\end{verbatim}


Aprite quindi un web browser e digitate: \url{http://localhost:8000/}, e voilà

Potete giocare con un website demo chiamato \strong{Prestation} o con i piccoli
test che mostrano alcune delle caratteristiche di CherryPy.

\section{Fermare il server}

In molti casi per stoppare il sever basterà premere "Ctrl-C".

Questo non funzionerà se state usando Python 2.1 o 2.2 su Windows e il modulo
\var{timeoutsocket.py} non è installato. In questo caso, potete fermare il server
premendo "Ctrl-Break".

Se siete su un sistema Unix-based e il sever è in esecuzione in background,
potete fermarlo digitando "kill <PID>".

Ora che avete scaricato CherryPy ed eseguito i demo, è il momento di capire
come uno sviluppatore può utilizzare CherryPy per costruire un sito web...

\chapter{Concetti usati in CherryPy}

\section{Creazione di un sito web}
CherryPy si pone tra un compilatore e un application server.
\begin{itemize}
\item
Come un compilatore, legge file in input e genera un eseguibile. L'eseguibile contiene tutto il necessario
per la gestione del sito web, incluso un proprio HTTP server.
\item
Come un application server, mette a disposizione siti web dinamici che possono essere uniti ad altre
risorse, come un database.
\end{itemize}

\section{Gestione delle richieste}
In un server generato da CherryPy, ogni richiesta di un client (per esempio un browser che richiede una pagina), viene trasformata in una chiamata al metodo di una classe. I parametri inviati dal client diventano
gli argomenti di una funzione.

Con CherryPy, gli sviluppatori di siti web devono solo implementare queste classi e questi metodi.
Non si devono preoccupare se i parametri sono inviati con un GET o un POST, se arrivano come una
piccola stringa o un file che deve essere scaricato.
Sono tutti convertiti in una stringa regolare Python e passati come argomento a un metodo. Il tutto in modo
trasparente allo sviluppatore.

\section{Programmare un sito web}
I file di input per CherryPy sono scritti usando un'estensione del linguaggio Python. Questa estensione
definisce classi speciali chiamate \strong{CherryClass} oltre a differenti metodi per queste
CherryClass:

\begin{itemize}
\item
\strong{function}: le funzioni presenti in questo metodo sono usate per processare dati e sono scritte in Python classico. Queste
funzioni generalmente ricevono dati in ingresso e ritornano dati (non HTML) 
come uscita.
\item
\strong{mask}: le funzioni presenti in questo metodo sono usate per interpretare dati. Sono scritte in CHTL o CGTL (che sono i 
linguaggi di templating di CherryPy). Queste funzioni ricevono dati in ingresso e rendono
HTML (o XML; Javascript, ...) in uscita.
\item
\strong{view}: le funzioni sono scritte in Python classico e possono essere usate in due modi
differenti:
\begin{itemize}
\item
possono essere usate come funzioni mask, per interpretare dati. In questo caso, la sola differenza
con funzioni mask è il linguaggio col quale sono scritte. Per comprendere bene, diciamo che una
pagina per lo più statica e con qualche dato dinamico sarà scritta con una funzione del metodo mask (in CHTL o CGTL).
Una pagina con molto contenuto dinamico e poco statico sarà scritta come view (in Python).
\item
possono essere usate come unione tra una funzione e una maschera. In questo caso il codice sorgente
di una funzione view sarà tipicamente:
\strong{applica questa maschera al risultato di questa funzione}
\end{itemize}
\end{itemize}

Questo concetto di metodi (function, mask e view) usato in CherryClass è una delle principali
caratteristiche di CherryPy. Una classe CherryClass può contenere tutte le informazioni per processare
dati e visualizzarne il risultato, rendendola un modulo a se stante che potrà essere
facilmente riutilizzato o ereditato.

Abbiamo così visto alcuni dei concetti usati in CherryPy. Altri saranno descritti in seguito, ma è il
momento di creare il nostro primo sito web...

\chapter{Creazione del primo sito web: Hello, world !}

Allo stesso livello della directory \file{demo/}, creiamo una directory chiamata \file{hello/}.

Entriamo nella directory \file{hello/} e creiamo un file chiamato \file{Hello.cpy} 
che dovrà contenere le seguenti linee:

\begin{verbatim}
CherryClass Root:
mask:
    def index(self):
        <html><body>
            Hello, world !
        </body></html>
\end{verbatim} \footnote{Potete usare sia 4 spazi bianchi che un TAB per indentare il vostro codice.
    E' possibile usare più o meno di 4 spazi per l'indentazione (p.e. 3) 
    specificando l'opzione -W (p.e. -W 3) per istruire CherryPy all'uso di 3 spazi invece di 4.
    Notate che, a differenza del Python, un TAB non corrisponderà mai a 2 livelli
    di indentazione ma sempre ad un solo livello.}

Per compilare il file digitate:
\begin{verbatim}
python ../cherrypy.py Hello.cpy
\end{verbatim}

Questo comando creerà un file chiamato \file{HelloServer.py}, il quale conterraà tutto il necessario per visualizzare il sito web (incluso un server HTTP).
Per farlo partire, basta digitare:
\begin{verbatim}
python HelloServer.py
\end{verbatim}

Per vedere la pagina, aprite un browser e andate all'indirizzo: \url{http://localhost:8000/}

Cosa abbiamo imparato:
\begin{itemize}
\item
I sorgenti per CherryPy sono scritti usando una estensione del Python (alune parti usano il linguaggio di
template di CherryPy).
\item
Il nome dei file sorgenti per CherryPy hanno l'estensione \file{.cpy} e l'iniziale maiuscola.
\item
Come ogni altro sorgente Python, i file sorgente per CherryPy sono sensibili all'indentazione.
Date un'occhiata alla nota in calce per conoscere come CherryPy usa l'indentazione.
\item
La parola chiave \code{CherryClass} è usata come la parola chiave \code{class} in Python.
Il nome di una classe CherryClass deve iniziare con una lettera maiuscola.
\item
All'interno di una classe CherryClass potete definire differenti sezioni, come \code{mask}, \code{view} o \code{function}.
Vedremo in seguito come usarle ed  il loro significato.
\item
All'interno di una sezione, potete definire dei metodi proprio come fareste in Python. (p.e: \code{def index(self):})
\item
Il corpo di un metodo mask non è scritto in Python. Al contrario è scritto in CHTL o CGTL che sono i 
linguaggi di template di CherryPy. Ne parleremo più dettagliatamente in seguito.
\item
Il file generato da CherryPy dal file di input \file{Foo.cpy} è chiamato \file{FooServer.py}
\item
Il file generato da CherryPy è 100\% puro Python
\item
Quando un browser richiede la pagina principale di un sito web, viene chiamata \code{root.index}
il cui valore di ritorno è inviato al browser.
\end{itemize}

Aggiungiamo ora alcune funzionalità dinamiche...

\chapter{Creazione del primo sito dinamico: Hello, you !}

Editate il file \file{Hello.cpy} ache avete creato nel precedente capitolo, e fate le seguenti modifiche:

\begin{verbatim}
CherryClass Root:
mask:
    def index(self, name="you"):
        <html><body>
            Hello, <b py-eval="name"></b> !
            <form py-attr="request.base" action="" method="get">
                Enter your name: <input name=name type=text><br>
                <input type=submit value=OK>
            </form>
        </body></html>
\end{verbatim}

Ricompilate il file e fate ripartire il server. Fate un refresh della pagina nel vostro browser.
Dovreste vedere
\begin{verbatim}
Hello, you
\end{verbatim}

seguito da un campo dove potete inserire del testo. Inserite il vostro nome 
e premete il bottone OK. Ora la riga dovrebbe cambiare in

\begin{verbatim}
Hello, "il vostro nome"
\end{verbatim}

Come è  possibile ?

Questa volta il metodo \var{index} ha un parametro chiamato \var{name}.
Proprio come per ogni metodo Python, questo parametro può avere un valore di default (in questo caso \var{you}). 
La prima volta che il browser visualizza la pagina, non viene passato nessun parametro \var{name}
, così \var{name} avrà il proprio valore di default nella funzione.

Quando riempite il campo con del testo e premete OK, il browse invierà una richiesta alla stessa
pagina, ma questa volta \var{name} sarà passato come un parametro contenente il nome da voi immesso.

Dato che abbiamo usato \var{method="get"} nella form, il parametro name verrà passato usando  l'URL
(potete facilmente controllarlo dato che l'URL del vostro browser avrà il seguente aspetto:
\url{http://localhost:8000/?name=yourName}).

Editate ora \file{Hello.cpy} e cambiate \var{method="get"} in \var{method="post"}.
Ricompilate il file, fate ripartire il server, e rifate il test: funzionerà esattamente come prima, eccetto
per il fatto che \var{name=yourName} non apparirà nell'URL.
Il motivo risiede nel fatto che abbiamo usato un metodo \var{POST} al posto di \var{GET} nella form.

Cosa abbiamo imparato:
\begin{itemize}
\item
I parametri inviati dal browser usando l'URL (GET) o usando POST sono passati al metodo come un normale
parametro Python.
Non dobbiamo preoccuparci se e' un GET o un POST, o se il parametro è una stringa o un un file.
Tutto sarà sempre trattato nello stesso modo.
\item
In un metodo mask, potete usare tag speciali come \code{py-eval} o \code{py-attr}.
Questi tag fanno parte del linguaggio di template di CherryPy.
\end{itemize}

E' il momento di fare qualcosa di interessante con questo linguaggio di template...

\chapter{I linguaggi di template: CHTL e CGTL}

CherryPy possiede DUE linguaggi di template. Sono molto simili, ma sono usati in situazioni differenti.
Sono stati pensati per essere facili da usare ma nello stesso tempo, molto potenti.
\begin{itemize}
\item
\strong{CherryPy HTML Templating Language (CHTL)}: è usato per produrre output in HTML.
E' stato disegnato in modo che editor HTML prendano le informazioni dinamiche dalla pagina.
In questo modo, webdesigner possono editare le pagine usando il proprio editor HTML preferito senza
perdere le informazioni che gli sviluppatori vi hanno messo. Il trucco sta nel nascondere il codice
negli attributi dei tag HTML.
\item
\strong{CherryPy Generic Templating Language (CGTL)}: è usato per produrre output non-HTML  (per esempio
Javascript, CSS, XML, ...). E' molto simile al CHTL, eccetto che non possiamo usare tag HTML per nascondere
il codice e la sintassi è leggermente più semplice.
\strong{Se non usate nessun editor HTML per creare le vostre pagine, probabilmente potreste usare solo il
CGTL che è più semplice rispetto al CHTL}.
\end{itemize}

\section{Tag}
Entrambi i linguaggi usano solo 6 tag: \code{py-eval}, \code{py-attr}, \code{py-exec}, \code{py-code}, \code{py-if} (con \code{py-else})
e \code{py-for}.

Tutti i tag sono usati nello stesso modo: \code{CherryPyTag="Codice Python"}. Per esempio:
\begin{verbatim}
py-eval="2*2"
py-exec="a=1"
py-if="2==0"
py-for="i in range(10)"
...
\end{verbatim}

Se volete usare le virgolette all'interno del codice python, avrete bisogno di usare il carattere di escape
(backslash), in questo modo:
\begin{verbatim}
py-eval="'I love \"cherry pies\"'"
\end{verbatim}

Vediamo cosa da ognuno di questi tag:

\subsection{py-eval}
Questo tag è usato per valutare un espressione Python, come in questo caso:
\begin{verbatim}
Hello, the sum is <py-eval="1+2+3">
\end{verbatim}

Questa linea verrà visualizzata come:
\begin{verbatim}
Hello, the sum is 6
\end{verbatim}

Quello che succede è che CherryPy prima valuta l'espressione (usando \var{eval}) e quindi usa
\var{str} per convertire il risultato in una stringa.

Tutti i tag CGTL possono essere racchiusi tra \var{/>} o {/ >}, come in questo caso:
\begin{verbatim}
<py-eval="'abcd' * 2" />
<py-eval="'Hello, %s' % name"/>
\end{verbatim}

Nel formato CHTL, il tag \var{py-eval} può essere usato all'interno di qualsiasi coppia di tag (sia di apertura che di chiusura), come in questo caso:

\begin{verbatim}
<span class=myClass py-eval="2*3"></span>
<a href="myHref" py-eval="'Click here'"></a>
<u py-eval="'I\'m with an underline'"></u>
...
\end{verbatim}

Se non volete che nessun tag HTML preceda o segua l'espressione, il trucco è di usare 
il tag HTML \code{<div>}:
\begin{verbatim}
This is a long string with a <div py-eval="'variable'"></div> in it
\end{verbatim}


\subsection{py-attr}
Questo tag e' simile a \code{py-eval}, eccetto che è usato come attributo a tag HTML. Ecco il suo uso:
\begin{verbatim}
<td py-attr="'red'" bgColor="">
\end{verbatim}
E che darà come risultato:
\begin{verbatim}
<td bgColor="red">
\end{verbatim}
Notate che questo è equivalente a:
\begin{verbatim}
<td bgColor="<py-eval="'red'">">
\end{verbatim}
Ma la prima sintassi è preferibile.

\subsection{py-exec e py-code}
Questi tag sono usati per eseguire codice Python.
\code{py-exec} è usato per eseguire una linea di codice Python mentre
\code{py-code} è usato per eseguire blocchi di codice Python.
Per esempio, il codice che segue:
\begin{verbatim}
<py-exec="a=2">
<py-code="
    if a==2:
        b=1
    else:
        b==2
">
b equals <py-eval="b">
\end{verbatim}
Sarà visualizzato come:
\begin{verbatim}
b equals 1
\end{verbatim}

Usando la sintassi CHTL, entrambi i tag dovranno essere racchiusi tra i tag <div> e </div> come segue:
\begin{verbatim}
<div py-exec="a=2"></div>
<div py-code="
    if a==2:
        b=1
    else:
        b=2
"></div>
\end{verbatim}

Se volete visualizzare dei dati all'interno del codice Python, dovrete appenderli alla variabile
\var{_page}:
\begin{verbatim}
<html><body>
    Integers from 0 to 9:
    <py-code="
        for i in range(10):
            _page.append("%s "%i)
    ">
</body></html>
\end{verbatim}

Che sarà visualizzato come:
\begin{verbatim}
<html><body>
    Integers from 0 to 9:
    0 1 2 3 4 5 6 7 8 9
</body></html>
\end{verbatim}


\subsection{py-if e py-else}
Questi tag sono usati come \code{if} ed \code{else} in Python. La sintassi è la seguente:
\begin{verbatim}
<py-if="1==1">
    OK
</py-if><py-else>
    Not OK
</py-else>
\end{verbatim}

Che sarà visualizzato come
\begin{verbatim}
OK
\end{verbatim}

Notate che se c'è una clausola \code{else}, il tag \code{<div py-else>} deve seguire il tag \code{</div>} 
che chiude il tag \code{<div py-if>}, con nessun carattere significativo tra di loro (sono permessi solo
separatori).

Il CHTL equivalente è:
\begin{verbatim}
<div py-if="1==1">
    OK
</div>
<div py-else>
    Not OK
</div>
\end{verbatim}


\subsection{py-for}
Anche questo tag è uguale al \code{for} in Python. La sintassi è la seguente:
\begin{verbatim}
<py-for="i in range(10)">
    <py-eval="i">
</py-for>
\end{verbatim}
Che sarà visualizzato come
\begin{verbatim}
0 1 2 3 4 5 6 7 8 9
\end{verbatim}

Notate che potete ciclare su liste di tuple:
\begin{verbatim}
<py-for="i,j in [(0,0), (0,1), (1,0), (1,1)]">
    <py-eval="i+j">
</py-for>
\end{verbatim}
La cui visualizzazione sarà
\begin{verbatim}
0 1 1 2
\end{verbatim}

Il CGTL equivalente è:
\begin{verbatim}
<div py-for="i,j in [(0,0), (0,1), (1,0), (1,1)]">
    <div py-eval="i+j"></div>
</div>
\end{verbatim}

In un ciclo \var{py-for}, CherryPy crea due variabili speciali: \var{_index} and \var{_end}.
La prima è un intero contenente il numero corrente di iterazioni (da 0 a n-1). La seconda contiene il
numero totale di iterazioni meno 1.

Per esempio, se vogliamo visualizzare una lista con la prima occorrenza in grassetto e l'ultima sottolineata
possiamo usare il seguente codice:
\begin{verbatim}
<py-exec="myList=[1,5,3,2,5,4,5]">
<py-for="item in myList">
    <py-if="_index==0"><b py-eval="item"></b>
    </py-if><py-else>
        <py-if="_index==_end"><u py-eval="item"></u>
        </py-if><py-else><py-eval="item"></py-else>
        </div>
    </py-else>
</py-for>
\end{verbatim}
Questo sarà il risultato:
\begin{verbatim}
<b>1</b> 5 3 2 5 4 <u>5</u>
\end{verbatim}

Nella prossima sezione vedremo come usare tutti questi tag insieme...

\section{Mettiamo tutto insieme}

Ora andremo a creare una pagina web che visualizza una tabella con tutti i colori HTML. 
Editate il file Hello.cpy e modificatelo nel seguente modo:

\begin{verbatim}
CherryClass Root:
mask:
    def index(self):
        <html><body>
            <a py-attr="request.base+'/webColors'" href="">
                Click here to see a nice table with all web colors
            </a>
        </body></html>
    def webColors(self):
        <html><body>
            <py-exec="codeList=['00', '33', '66', '99', 'CC', 'FF']">
            <table border=1>
            <py-for="r in codeList">
                <py-for="g in codeList">
                    <tr>
                        <py-for="b in codeList">
                            <py-exec="color='#%s%s%s'%(r,g,b)">
                            <td py-attr="color" bgColor="" py-eval="'&nbsp;&nbsp;
                                                '+color+'&nbsp;'"></td>
                        </py-for>
                    </tr>
                </py-for>
            </py-for>
        </body></html>
\end{verbatim}

Ricompilate il file, fate ripartire il server e ricaricate la pagina nel vostro browser. Cliccate sul link
e dovreste vedere una simpatica tabella con tutti i colori del web.

Come funziona?

Il metodo \code{webColors} è un esempio di un uso diretto e semplice dei tag CHTL.
La riga più interessante è:
\begin{verbatim}
<a py-attr="request.base+'/webColors'" href="">
\end{verbatim}

\var{request} è una variabile globale usata da CherryPy per ogni richiesta di un client.
E' un'instanza di una classe con diverse variabili. Una di queste è chiamata \code{base} e contiene
l'URL di base del sito web (nel nostro caso: \url{http://localhost:8000}).
Così, la linea
\begin{verbatim}
<a py-attr="request.base+'/webColors'" href="">
\end{verbatim}
sarà resa come:
\begin{verbatim}
<a href="http://localhost:8000/webColors">
\end{verbatim}
Questo ci dice anche che quando il browser richiede l'URL  \url{http://localhost:8000/webColors}, 
verrà chiamato il metodo \var{webColors} della classe  \var{Root}.

Nel prossimo capitolo, impareremo come e dove usare view e function ...

\chapter{Views, function ed altro}

Fino ad ora abbiamo usato solo metodi di tipo mask: Impareremo ora come usare view e function.

\section{Differenti architetture per il codice sorgente di un sito web}
Prenderemo in esame due esempi per mostrare i due differenti modi di disegnare l'architettura del vostro codice.

\subsection{Primo esempio: architettura semplice}
Assumiamo vogliate costruire un sito web veramente semplice dove persone possono ricercare tra una serie
di libri e vedere i dettagli di uno in particolare.
Il sito web è costituito da un paio di pagine:
\begin{itemize}
\item
La pagina principale mostra una lista di libri. Ogni libro è un link.
\item
Una pagina mostra le informazioni relative ad un particolare libro. Questa pagina è visualizzata quando
un utente clicca sul nome del libro
\end{itemize}
Per implementare questo sito web, abbiamo bisogno di usare 2 funzioni  e 2 maschere.
\begin{itemize}
\item
Una funzione chiamata \strong{getBookListData} ritornerà la lista dei nomi dei libri
\item
Una funzione chiamata \strong{getBookData} ritornerà le informazioni dettagliate di un particolare libro
\item
Una maschera chiamata \strong{index} che visualizzerà la lista dei libri
\item
Una maschera chiamata \strong{displayBook} che mostrerà in dettaglio le informazioni di un particolare libro
\end{itemize}
Il codice per il sito web è il seguente:
\begin{verbatim}
CherryClass Root:
variable:
    # Sample book list data. In real life, this would probably come from a database
    # (title, author, price)
    bookListData=[
        ('Harry Potter and the Goblet of Fire', 'J. K. Rowling', '9$'),
        ('The flying cherry', 'Remi Delon', '5$'),
        ('I love cherry pie', 'Eric Williams', '6$'),
        ('CherryPy rules', 'David stults', '7$')
    ]

function:
    def getBookListData(self):
        return self.bookListData
    def getBookData(self, id):
        return self.bookListData[id]
mask:
    def index(self):
        <html><body>
            Hi, choose a book from the list below:<br>
            <py-for="title, dummy, dummy in self.getBookListData()">
                <a py-attr="'displayBook?id=%s'%_index" href="" py-eval="title"></a><br>
            </py-for>
        </body></html>
    def displayBook(self, id):
        <html><body>
            <py-exec="title, author, price=self.getBookData(int(id))">
            Details about the book:<br>
            Title: <py-eval="title"><br>
            Author: <py-eval="author"><br>
            Price: <py-eval="price"><br>
        </body></html>
\end{verbatim}
Come avete potuto vedere, il codice per questo "mini" sito è veramente semplice: ogni maschera corrisponde
ad un tipo di pagina. Dato che avevamo 2 tipi di pagine abbiamo usato 2 maschere.

Andiamo a vedere un esempio leggermente più complicato...
\subsection{Secondo esempio: un'architettura più elegante per siti più complessi}

In questo esempio aggiungeremo alcune caratteristiche al nostro sito web:
\begin{itemize}
\item
Questa volta vogliamo che il nostro sito web sia bilingue: Inglese e Francese
\item
Oltre a scorrere i libri per titolo, vogliamo che siano anche selezionabili per autore
\end{itemize}

Questo significa che avremo bisogno di 6 tipi di pagine:
\begin{itemize}
\item
1. Una per visualizzare una lista di titoli in Inglese
\item
2. Una per visualizzare una lista di titoli in Francese
\item
3. Una per visualizzare una lista di libri per autore in Inglese
\item
4. Una per visualizzare una lista di libri per autore in Francese
\item
5. Una per visualizzare i dettagli dei libri in Inglese
\item
6. Una per visualizzare i dettagli dei libri in Francese
\end{itemize}

Se volessimo mantenere la stessa architettura del primo esempio, dovremmo scrivere 6 maschere (più 
le funzioni). Proviamo a fare qualcosa di meglio ...

Non c'è molto da fare per le ultime 2 pagine (la 5 e la 6). Ma per le prime quattro, possiamo in effetti
usare 2 funzioni e 2 maschere. Combinando ogni funzione con ogni maschera, abbiamo le nostre 4 combinazioni
(2 per 2). Useremo ciò che segue:

\begin{itemize}
\item
Una funzione chiamata \strong{getBookListByTitleData} che ritornerà la lista dei libri per titolo
\item
Una funzione chiamata \strong{getBookListByAuthorData} che ritornerà una lista di libri per autore
\item
Una maschera chiamata \strong{bookListInEnglishMask} che visualizzerà una lista di libri in Inglese (senza
preoccuparsi se i libri sono ordinati per titolo o autore).
\item
Una maschera chiamata \strong{bookListInFrenchMask} che visualizzerà una lista di libri in Francese.
\end{itemize}

Per permettere l'unione tra maschera e funzione, useremo una view. Questo significa che avremo 4 view, una
per ogni combinazione. Ogni view avrà un codice veramente semplice: \strong{applica questa maschera al
risultato di questa funzione}

Il codice per il nostro sito web è il seguente:
\begin{verbatim}
CherryClass Root:
variable:
    # Sample book list data. In real life, this would probably come from a database
    # (title, author, price)
    bookListData=[
        ('Harry Potter and the Goblet of Fire', 'J. K. Rowling', '9$'),
        ('The flying cherry', 'Remi Delon', '5$'),
        ('I love cherry pie', 'Eric Williams', '6$'),
        ('CherryPy rules', 'David Stults', '7$')
    ]

function:
    def getBookListByTitleData(self):
        titleList=[]
        for title, dummy, dummy in self.bookListData: titleList.append(title)
        return titleList
    def getBookListByAuthorData(self):
        authorList=[]
        for dummy, author, dummy in self.bookListData: authorList.append(author)
        return authorList
    def getBookData(self, id):
        return self.bookListData[id]
mask:
    def bookListInEnglishMask(self, myBookListData):
            Hi, choose a book from the list below:<br>
            <py-for="data in myBookListData">
                <a py-attr="'displayBookInEnglish?id=%s'%_index" href="" 
                    py-eval="data"></a><br>
            </py-for>
            <br>
    def bookListInFrenchMask(self, myBookListData):
            Bonjour, choisissez un livre de la liste:<br>
            <py-for="data in myBookListData">
                <a py-attr="'displayBookInFrench?id=%s'%_index" href=""
                        py-eval="data"></a><br>
            </py-for>
            <br>
    def displayBookInEnglish(self, id):
        <html><body>
            <py-exec="title, author, price=self.getBookData(int(id))">
            Details about the book:<br>
            Title: <py-eval="title"><br>
            Author: <py-eval="author"><br>
            Price: <py-eval="price"><br>
            <br>
            <a py-attr="'displayBookInFrench?id=%s'%id" href="">Version francaise</a>
        </body></html>
    def displayBookInFrench(self, id):
        <html><body>
            <py-exec="title, author, price=self.getBookData(int(id))">
            Details du livre:<br>
            Titre: <py-eval="title"><br>
            Auteur: <py-eval="author"><br>
            Prix: <py-eval="price"><br>
            <br>
            <a py-attr="'displayBookInEnglish?id=%s'%id" href="">English version</a>
        </body></html>
\end{verbatim}
\begin{verbatim}
view:
    def englishByTitle(self):
        page="<html><body>"
        byTitleData=self.getBookListByTitleData()
        page+=self.bookListInEnglishMask(byTitleData)
        page+='<a href="englishByAuthor">View books by author</a><br>'
        page+='<a href="frenchByTitle">Version francaise</a>'
        page+="</body></html>"
        return page
    def frenchByTitle(self):
        page="<html><body>"
        byTitleData=self.getBookListByTitleData()
        page+=self.bookListInFrenchMask(byTitleData)
        page+='<a href="frenchByAuthor">Voir les livres par auteur</a><br>'
        page+='<a href="englishByTitle">English version</a>'
        page+="</body></html>"
        return page
    def englishByAuthor(self):
        page="<html><body>"
        byTitleData=self.getBookListByAuthorData()
        page+=self.bookListInEnglishMask(byTitleData)
        page+='<a href="englishByTitle">View books by title</a><br>'
        page+='<a href="frenchByAuthor">Version francaise</a>'
        page+="</body></html>"
        return page
    def frenchByAuthor(self):
        page="<html><body>"
        byTitleData=self.getBookListByAuthorData()
        page+=self.bookListInFrenchMask(byTitleData)
        page+='<a href="frenchByTitle">Voir les livres par titre</a><br>'
        page+='<a href="englishByAuthor">English version</a>'
        page+="</body></html>"
        return page
    def index(self):
        # By default, display books by title in English
        return self.englishByTitle()
\end{verbatim}

Alternativamente, avremmo potuto risparmiare alcune lnee di codice passando la lingua (Francese o Inglese)
e il tipo di lista (titolo o autore) come parametri. In questo modo, non avremmo avuto bisogno di usare view,
e le maschere avrebbero potuto essere chiamata direttamente...

\section{Altri esempi usando function, mask e view insieme}
In questa sezione, costruiremo un piccolo sito web che richiede all'utente un numero intero tra 20 e 50
e un numero di colonne C tra 2 e 20. Quindi visualizzerà i numeri interi da 1 a N in una tabella di C colonne.

Editate \file{Hello.cpy} ed inserite le seguenti righe di codice:
\begin{verbatim}
CherryClass Root:
function:
    def prepareTableData(self, N, C):
        # Prepare data that will be rendered in the table
        # Example, for N=10 and C=3, it will return:
        # [[1,2,3],
        #  [4,5,6],
        #  [7,8,9],
        #  [10]]
        N=int(N)
        C=int(C)
        tableData=[]
        i=1
        while 1:
            rowData=[]
            for c in range(C):
                rowData.append(i)
                i+=1
                if i>N: break
            tableData.append(rowData)
            if i>N: break
        return tableData
            
view:
    def viewResult(self, N, C):
        tableData=self.prepareTableData(N,C)
        return self.renderTableData(tableData)
mask:
    def renderTableData(self, tableData):
        # Renders tableData in a table
        <html><body>
        <table border=1>
            <div py-for="rowData in tableData">
                <tr>
                    <div py-for="columnValue in rowData">
                        <td py-eval="columnValue"></td>
                    </div>
                </tr>
            </div>
        </table>
        </body></html>

    def index(self):
        <html><body>
            <form py-attr="request.base+'/viewResult'" action="">
                Integer between 20 and 50: <input type=text name=N><br>
                Number of columns between 2 and 10: <input type=text name=C><br>
                <input type=submit>
            </form>
        </body></html>
\end{verbatim}

Come funziona?

La maschera \var{index} è facile da capire ed è usata solo per inserire N e C.

La funzione \var{prepareTableData} è usata per processare N e C e per calcolare una lista di liste
che sarà pronta per la visualizzazione. La maschera \var{renderTableData} prende in ingresso
il ritorno di \var{prepareTableData} e lo visualizza. La view \var{viewResult} è un 
collegamento tra i due. Basilarmente diciamo di calcolare il risulato di una funzione e
applicarvi una maschera.

Ora cosa possiamo fare se volessimo visualizzare gli interi per colonna invece che per riga?

Dobbiamo creare una nuova maschera e aggiornare la view in modo da applicare la nuova maschera
ai dati.

Modifichiamo \file{Hello.cpy} come segue:
\begin{verbatim}
CherryClass Root:
function:
    def prepareTableData(self, N, C):
        N=int(N)
        C=int(C)
        tableData=[]
        i=1
        while 1:
            rowData=[]
            for c in range(C):
                rowData.append(i)
                i+=1
                if i>N: break
            tableData.append(rowData)
            if i>N: break
        return tableData
            
view:
    def viewResult(self, N, C, displayBy):
        tableData=self.prepareTableData(N,C)
        if displayBy=="line": mask=self.renderTableDataByLine
        else: mask=self.renderTableDataByColumn
        return mask(tableData)
mask:
    def renderTableDataByLine(self, tableData):
        <html><body>
        <table border=1>
            <div py-for="rowData in tableData">
                <tr>
                    <div py-for="columnValue in rowData">
                        <td py-eval="columnValue"></td>
                    </div>
                </tr>
            </div>
        </table>
        </body></html>
    def renderTableDataByColumn(self, tableData):
        <html><body>
        <table border=1>
            <tr>
                <div py-for="rowData in tableData">
                    <td valign=top>
                        <div py-for="columnValue in rowData">
                            <div py-eval="columnValue"></div><br>
                        </div>
                    </td>
                </div>
            </tr>
        </table>
        </body></html>

\end{verbatim}
\begin{verbatim}
    def index(self):
        <html><body>
            <form py-attr="request.base+'/viewResult'" action="">
                Integer between 20 and 50: <input type=text name=N><br>
                Number of columns (or lines) between 2 and 10: 
                    <input type=text name=C><br>
                Display result by: <select name=displayBy>
                    <option>line</option>
                    <option>column</option>
                </select><br>
                <input type=submit>
            </form>
        </body></html>
\end{verbatim}

Abbiamo rinominato la maschera \var{renderTableData} in \var{renderTableDataByLine},
abbiamo quindi chiamato 
\var{renderTableDataByColumn}. \var{viewResult} ha adesso il parametro \var{displayBy}
che è immesso dall'utente. Basandosi su questo, \var{viewResult} seleziona la maschera da applicare 
al risultato della funzione \var{prepareTableData} (che non è cambiata).

Facciamo ora alcuni test: nel nostro browser digitiamo l'URL: \url{http://localhost:8000/prepareTableData?N=30\&C=5}

Dovreste ricevere il seguente errore:
\begin{verbatim}
CherryError: CherryClass "root" doesn't have any view or
            mask function called "prepareTableData"
\end{verbatim}
Questo significa che una funzione non può essere "chiamata" direttamente da un browser.
Solo funzioni view e mask, che ritornano dati visualizzabili, possono essere "chiamate" direttamente.

Cosa abbiamo imparato:
\begin{itemize}
\item
CherryPy permette la separazione tra contenuto e presentazione usando 'sezioni' chiamate function, mask e view
\item
Le funzioni in function processano dati e ritornano dati. Una funzione che implementa un algoritmo può essere
riutilizzata per ogni tipo di dato.
\item
Le funzioni in mask ricevono dati e li renderizzano. Una maschera può essere riutilizzata per ogni tipo di dato.
\item
Le funzioni in view sono collegamenti tra funzioni e maschere.
\end{itemize}

Nota: all'interno di una dichiarazione di una CherryClass, le sezioni differenti (function, mask o view)
possono apparire in qualsiasi ordine, il numero di volte che vogliamo.

Nel prossimo capitolo vedremo come CherryPy determina che metodo chiamare in base all'URL...

\chapter{Classi, istanze, metodi e URL}
Abbiamo visto come l'URL \url{http://localhost:8000} genera una chiamata al metodo \var{index} della classe \var{Root}
. L'URL \url{http://localhost:8000/viewResult} genera una chiamata al metodo \var{viewResult} della classe \var{Root}.
\begin{itemize}
\item
Come funzione questa 'magia'?
\item
Sappiamo che non possiamo chiamare il metodo di una classe. Dovremmo chiamare il metodo come una \strong{istanza}
di una classe. Come si spiega quindi?
\item
Cosa succede quando digito l'URL \url{http://localhost:8000/dir1/dir2/dir3/page} ?
\end{itemize}

Rispondiamo a queste domande:

Prima di tutto, quando dichiarate nel file sorgente una CherryClass:
\begin{verbatim}
CherryClass ClassName:
\end{verbatim}

CherryPy ( o per essere più precisi: l'eseguibile generato da CherryPy) automaticamente creerà
un'istanza di questa classe, chiamata \var{className}. Questo è il nome della classe con la prima
lettera del nome minuscola. (Questa è la ragione per cui i nomi delle classi CherryPy dovrebbero
sempre iniziare con una lettera maiuscola)
Questa istanza è una variabile globale che è accessibile da qualsiasi parte del programma.

Basandosi sull'URL, come fa CherryPy a conoscere quale metodo di quale istanza di classe chiamare?

Usa un semplice meccanismo:
Per l'URL \var{host/dir1/dir2/dir3/page}, chiamerà il metodo \var{dir1_dir2_dir3.page()}. 
Così si aspetterà che il vostro programma abbia un classe CherryClass chiamata \var{Dir1_dir2_dir3},
che dovrebbe avere un metodo chiamato \var{page}.

Ci sono 2 casi speciali:
\begin{itemize}
\item
se non c'è prima una directory (in altre parole, l'URL ha la forma: \var{host/page}), verrà  chiamato il
metodo \var{root.page()}. Il che significa che entrambi gli URL \var{host/page} e \var{host/root/page}
sono perfettamente equivalenti.
\item
se non c'e' prima una directory o nessuna pagina (in altre parole, l'URL è il solo hostname), verrà allora chiamato il metodo \var{root.index()}.
\end{itemize}
\strong{Importante}: In CherryPy-0.9, è stata aggiunta una nuova caratteristica: se viene richiesta la pagina \url{http://localhost:8000/dir1/dir2/dir3} 
, CherryPy prima convertirà la chiamata in \var{dir1_dir2.dir3()}, aspettandosi quindi un metodo \var{dir3}
nella classe CherryClass \var{Dir1_dir2}.
Ma se tale metodo non esiste, verrà cercato un metodo  \var{index} nella classe CherryClass \var{Dir1_dir2_dir3}. (che potrebbe anche corrispondere a \url{http://localhost:8000/dir1/dir2/dir3/index}).

Nel prossimo capitolo vedremo come usare l'ereditarietà quando abbiamo moduli simili all'interno di un sito web...

\chapter{Usare la programmazione ad oggetti su un sito web}

Una della caratteristiche più  potenti di CherryPy è che potete realmente usare un approccio \strong{object oriented} per "programmare" il vostro sito web.

Quando guardiamo un sito web complesso, realizziamo che alcune parti hanno cose in comune:
\begin{itemize}
\item
Usano le stesse funzionalità ma applicandole a differenti tipi di dati
\item
Visualizzano la stessa informazione, ma i dati sono visualizzati in modo differente (per esempio quando avete
versioni multiple di un sito o diverse versioni in lingue differenti)
\end{itemize}

In entrambi i casi, OOP provvede una soluzione elegante al problema e minimizza il codice richiesto per
implementare la soluzione.

Per mostrarci come è possibile tutto questo, creeremo un sito web che ha due versioni: una in Inglese ed una in Francese.
Non cambia solo il testo, ma anche i colori ed il modo di visualizzare i moduli.

Digitiamo il seguente codice:
\begin{verbatim}
#######################
CherryClass Airline abstract:
#######################
function:
    def localize(self, stri):
        return self.dictionnary.get(stri, stri)
mask:
    def header(self):
        <html><body>
            <center>
                <H1 py-eval="self.localize('Welcome to CherryPy airline')"></H1>
                <div py-if="self==airlineFrench">
                    <a py-attr="request.base+'/airlineEnglish/index'" href="">
                        Click here for English version
                    </a>
                </div><div py-else>
                    <a py-attr="request.base+'/airlineFrench/index'" href="">
                        Cliquez ici pour la version française
                    </a>
                </div>
                <br><br><br><br>
    def footer(self):
            </center>
        </body></html>
    def squareWithText(self, title, text):
        <table border=0 cellspacing=0 cellpadding=1 width=200><tr>
            <td py-attr="self.borderColor" bgColor="">
                <table border=0 cellspacing=0 cellpadding=5><tr>
                    <td py-attr="self.insideColor" bgColor=""
                        align=center width=198 py-eval="'<b>%s</b><br><br>%s'
                                %(title,text)">
                    </td>
                </tr></table>
            </td>
        </tr></table>
view:
    def bookAFlight(self):
        page=self.header()
        page+=self.squareWithText(self.localize('Booking a flight'),
            self.localize('To book a flight, think about where you want to go, and you should dream about it tonight'))
        page+=self.footer()
        return page


#######################
CherryClass AirlineFrench(Airline):
#######################
variable:
    insideColor='#FFFF99'
    borderColor='#FF6666'
    dictionnary={
        'Welcome to CherryPy airline': 'Bienvenue chez CherryPy airline',
        'Booking a flight': 'Réserver un vol',
        'To book a flight, think about where you want to go, and you should 
        dream about it tonight':
            'Pour réserver un vol, pensez très fort à la destination, et vous 
            devriez en rêver cette nuit'
    }    
view:
    def index(self):
        page=self.header()
        page+=self.squareWithText('Réserver un vol', 'Pour réserver un vol, 
        cliquez sur <a href="%s/bookAFlight">réserver</a>'%self.getPath())+'<br>'
        page+=self.squareWithText('Présentation', 'CherryPy airline est la compagnie
        qui vous emmène au 7ème ciel')
        page+=self.footer()
        return page

#######################
CherryClass AirlineEnglish(Airline):
#######################
variable:
    insideColor='#00CCFF'
    borderColor='#3333FF'
    dictionnary={}    
view:
    def index(self):
        page=self.header()
        page+=self.squareWithText('Presentation', 'CherryPy airline is the company 
        that will take you to cloud 9')+'<br>'
        page+=self.squareWithText('Book a flight', '<a href="%s/bookAFlight">Click here</a> 
        to book a flight'%self.getPath())
        page+=self.footer()
        return page

#######################
CherryClass Root(AirlineEnglish):
#######################
\end{verbatim}

Questo programma usa alcune caratteristiche di CherryPy. Proviamo a capire come funzionano:

L'idea è di usare una classe CherryClass generica (\var{Airline}) che contiene funzioni, mask e view che sono comuni ad entrambe le versioni (Inglese e Francese) o il sito web.
Quindi usiamo 2 classi CherryClasses (\var{AirlineFrench}
e \var{AirlineEnglish}) per implemetare azioni speifiche per ogni versione.

Abbiamo usato due modi differenti per implementare ogni versione:
\begin{itemize}
\item
In uno la sola differenza sono le label (che sono tradotte in Francese per la versione Francese).
In questo caso abbbiamo usato un dizionario per implementare la traduzione.
\item
nell'altro cambia anche la presentazione delle informazioni. In questo caso abbiamo scritto 2 versioni per ogni
metodo.
\end{itemize}

Questo esempio mostra anche alcune nuove caratteristiche di CherryPy:
\begin{itemize}
\item
\strong{Astrazione delle CherryClasses}: avrete notato che in questo esempio che la CherryClass \var{Airline} 
è dichiarata "abstract". Questo significa solo che il server non creerà nessuna istanza di una CherryClass
chiamata \var{airline}. 
Il risultato sarà che non potrete usare l'URL \url{http://localhost:8000/airline/index}.
L'idea è che \var{Airline} non può essere chiamata direttamente.
Deve essre derivata in una sotto classe, e solo questa sotto classe può essere accessibile dal browser.
\item
\strong{Sezione variable}: avrete anche notato che questo esempio usa un nuovo tipo di sezione in una CherryClass: \var{variable}. 
Questa sezione è usata per setttare le variabili di default per questa CherryClass.
\item
\strong{self.getPath()}: di default CherryPy crea un metodo chiamato \var{getPath} per ogni CherryClass.
Questo metodo ritorna l'URL della CherryClass. Per esempio, per la CherryClass \var{AirlineFrench}, \var{getPath} dovrebbe ritornare
\url{http://localhost:8000/airlineFrench}
\end{itemize}

Nel prossimo capitolo, impareremo come dividere il nostro codice in diversi file sorgente...

\chapter{Usare diversi moduli}
Se avete in programma lo sviluppo di un grosso sito, comprenderete la necessità di suddividere il codice
in diversi moduli.
Ci sono due modi per farlo:
\begin{itemize}
\item
Nel primo i moduli sono completamente indipendenti. In questo caso dovrete solo creare i vostri file 
(per esempio: \file{Hello1.cpy}, \file{Hello2.cpy} and \file{Hello3.cpy}) e compilarli insieme usando:
\begin{verbatim}
python ../cherrypy.py Hello1.cpy Hello2.cpy Hello3.cpy
\end{verbatim}
Notate che l'eseguibile generato da CherryPy sarà chiamato \file{Hello1Server.py}
\item
Nell'altro caso un modulo è necessario agli altri (per esempio uno è una libreria usata dagli altri).
In questo caso tutto ciò di cui avrete bisogno è la parola chiave \var{use module} 
sulla prima riga del file, che è l'equivalente di una dichiarazione  \var{import} in Python.
Per esempio:
\begin{verbatim}
***** File BoldTime.cpy: *****
import time

CherryClass BoldTime:
view:
    def getBoldTime(self):
        # Display the time in bold
        return "<b>%s</b>"%time.time()

***** File Hello.cpy: *****
use BoldTime

CherryClass Root:
view:
    def index(self):
        return "<html><body>Hello, time is %s</body></hello>"%boldTime.getBoldTime()
\end{verbatim}
Per compilare uqesto esempio basta:
\begin{verbatim}
python ../cherrypy.py Hello.cpy
\end{verbatim}

Cinque cose da notare:
\begin{itemize}
\item
La dichiarazione \var{use} DEVE essere la prima riga del file (non mettete alcun commento prima).
\item
CherryPy creerà automaticamente una lista di dipendenze e leggerà i file i ordine generando l'eseguibile
di conseguenza. Se create un ciclo di dipendenze, CherryPy andrà in errore.
\item
Il nome di una CherryClass è \var{BoldTime} (con il carattere B in lettere maiuscole).
Così deve essere il nome del file e il nome da usare nella dichiarazione \var{use}.
Ma quando chiamate \var{boldTime.getBoldTime}, deve essere usata la b minuscola,
altrimenti si riferisce all'istanza della classe che è stata automaticamente creata.
\item
Potete anche usare la dichiarazione Python \var{import}. (Sia \code{import ...} che \code{from ... import ...})
\item
Se avete un certo numero di moduli da includere in \var{use}, potete dividere la dichiarazione "use"
su diverse righe (ma devono sempre essere nelle prime righe del file).
Per esempio, possiamo usare:
\begin{verbatim}
****** File Root.cpy: *****
use HttpAuthenticate, CookieAuthenticate
use Mail, MaskTools

CherryClass Root:
mask:
	def index(self):
		OK
\end{verbatim}
\end{itemize}
\end{itemize}

E se i moduli non sono nella stessa directory?

Allora dobbiamo usare l'opzione \var{-I} per compilare i file. Questo vi permette di specificare
le directory dove CherryPy deve ricercare i file di input. Per esempio se abbiamo i seguenti file:

\begin{verbatim}
/dir1/Module1.cpy
/dir2/Module2.cpy
Hello.cpy (uses Module1 and Module2)
\end{verbatim}
Dovremo compilare \file{Hello.cpy} usando:
\begin{verbatim}
python ../cherrypy.py -I /dir1 -I /dir2 Hello.cpy
\end{verbatim}
Di default, CherryPy cercherà in \file{.}, \file{../lib} e \file{../src}

E' possibile anche settare una variabile ambiente chiamata \var{CHERRYPY_HOME} che contiene i nomi
delle directory dove CherryPy è installato.
In questo caso, CherryPy cercherà i moduli in \file{CHERRYPY_HOME/lib} e  \file{CHERRYPY_HOME/src}.

Nei prossimi capitoli, impareremo come usare alcuni dei moduli delle librerie standard di CherryPy.

\chapter{HTTP e autenticazione cookie-based}
Due dei modi più comuni per restringere l'accesso ad alcune parti di un sito sono:
\begin{itemize}
\item
Autenticazione via HTTP: dove il browser apre una finestra popup e aspetta l'inserimento
di un login ed una password. Le informazioni sulla sessione sono registrate all'interno
del browser e vengono perse alla chiusura di tutte le finestre del browser.
\item
Autenticazione cookie-based: in questo caso usate una form per inserire una login ed una password. Le informazioni sulla sessione sono registrate in un cookie.
\end{itemize}

Queste tecniche possono essere difficoltose da implementare con alcuni application server,
Con CherryPy richiedono solo \strong{TRE LINEE DI CODICE} !

Tutto quello che dovete fare è usare i moduli standard \var{HttpAuthenticate} e \var{CookieAuthenticate}. 
Il seguente esempio usa entrambi i moduli.
\begin{verbatim}
use HttpAuthenticate, CookieAuthenticate

CherryClass Root:
mask:
    def index(self):
        <html><body>
            <a py-attr="request.base+'/httpProtected/index'" href="">
            Click here to enter a restricted area using HTTP authentication</a><br>
            <a py-attr="request.base+'/cookieProtected/index'" href="">
            Click here to enter a restricted area using cookie authentication</a><br>
            In both cases, the login and password are "login" and "password"
        </body></html>

CherryClass HttpProtected(HttpAuthenticate):
function:
    def getPasswordListForLogin(self, login):
        # Here we define what the login and password are
        if login=='login': return ['password']
        return []
mask:
    def index(self):
        <html><body>You're in</body></html>

CherryClass CookieProtected(CookieAuthenticate):
function:
    def getPasswordListForLogin(self, login):
        # Here we define what the login and password are
        if login=='login': return ['password']
        return []
mask:
    def index(self):
        <html><body>
            You're in<br>
            Click <a href="doLogout">here</a> to log out.
        </body></html>
\end{verbatim}

Come avete potuto vedere tutto ciò di cui abbiamo bisogno è di creare una CherryClass che erediti \var{HttpAuthenticate} o \var{CookieAuthenticate}
e implementare una funzione chiamata \var{getPasswordListForLogin} che ritorna una lista
di password corrispondeti per un dato login.
(questo vi permette di mantenere una master key che lavori per tutti gli utenti, per esempio ...)

Come avete potuto vedere, usare questi moduli è realmente facile.

Nel prossimo capitolo, vedremo come usare un altro modulo standard di CherryPy: Form

\chapter{Trattare form HTML}


Creare form HTML può essere difficoltoso con alcuni application server. Specialmente per
il trattamento degli errori: quando l'utente immette una informazione non corretta, la form
è visualizzata di nuovo, tutti i campi mantengono il loro valore tranne il campo errato che
visualizza un errore.

Se usate il modulo Form di CherryPy, probabilmente risparmierete molto tempo (una volta capito
come funziona).

Trovate un esempio  tra i demo di CherryPy, e un pò di documentazione nel CherryPy Library Reference.

Nel prossimo capitolo impareremo come configurare alcune opzioni di CherryPy ...

\chapter{Configurare CherryPy}
Prima di adesso avete sempre eseguito il server di CherryPy sulla porta 8000.
Come possiamo cambiarla? E' veramente semplice: attraverso un file di configurazione.

\section{Cambiare la porta}
Nella directory \file{hello/}, dove ci sono i file \file{Hello.cpy} e \file{HelloServer.py} 
creiamo un file chiamato  \file{HelloServer.cfg} con le seguenti linee:
\begin{verbatim}
[server]
socketPort=80
\end{verbatim}
Facciamo ripartire il server... che ora e' sulla porta 80.

Alcune altre opzioni sono disponibili nella sezione \var{[server]} del file di configurazione.
Controllate il capitolo "Usare il vostro sito web in ambiente produttivo" per maggiori
informazioni sulle differenti opzioni.

\section{Offrire contenuto statico}
Se volete usare CherryPy per offrire contenuto statico, tutto ciò che dovete fare è aggiungere
un paio di linee al file di configurazione:
\begin{verbatim}
[staticContent]
static=/home/remi/static
data/images=/home/remi/images
\end{verbatim}
Questo significa che quando un browser richiederà l'URL \url{http://localhost/static/styleSheet.css}, il server risponderà col contenuto del file \file{/home/remi/static/styleSheet.css}.

Quando il browser richiederà l'URL \url{http://localhost/data/images/girl.jpg}, il server offrirà il contenuto del file \file{/home/remi/images/girl.jpg}.

Notate che se avete bisogno del server statico come radice del vostro sito
(per esempio \var{favicon.ico}), potete speficare il nome completo del file invece che la
directory, in questo modo:
\begin{verbatim}
[staticContent]
favicon.ico=/home/remi/images/favicon.ico
\end{verbatim}


\section{Cambiare il nome del file di configurazione}
Se volete usare un nome differente per il file di configurazione, usate l'opzione \var{-C}
quando fate partire il server.
Per esempiom se il vostro file di configurazione si chiama \file{/dir1/dir2/myConfigFile.cfg}, fate partire il server, digitando:
\begin{verbatim}
python HelloServer.py -C /dir1/dir2/myConfigFile.cfg
\end{verbatim}

\chapter{Usare le proprie opzioni di configurazione}
Potete utilizzare opzioni di configurazione personali nel file di configurazione.
Basta aggiungere la vostra sezione e le vostre opzioni.
Quindi, nel codice, queste informazioni saranno disponibili attraverso la variabile globale
\var{configFile}. Questa variabile è un oggetto \var{ConfigParser}.
Il seguente è un esempio di come farlo:
\begin{verbatim}
**** File HelloServer.cfg ****
[server]
socketPort=80

[staticContent]
static=/home/remi/static

# Here I add my own configuration options
[user]
name=Remi
[database]
login=remiLogin
password=remiPassword


*** File Hello.cpy ****
CherryClass Root:
view:
    def index(self):
        <html><body>
            Hello, <py-eval="configFile.get('user','name')"><br>
            to connect to the database, you should use:<br>
            <py-eval="'Login:%s, Password:%s'%(configFile.get('database','login'),
                configFile.get('database','password'))">
        </body></html>
\end{verbatim}
Questo sarà renderizzato come:
\begin{verbatim}
<html><body>
    Hello, Remi<br>
    to connect to the database, you should use:<br>
    Login:remiLogin, Password:remiPassword
</body></html>
\end{verbatim}

Nel prossimo capitolo impareremo qualcosa su variabili e funzioni speciali di CherryPy ...

\chapter{Variabili e funzioni speciali}

CherryPy genera e usa alcune variabili e funzioni speciali. Sono molto facili da usare, ma
altrettanto potenti. In questo capitolo vedremo cosa sono queste variabili e funzioni, mentre nel prossimo impareremo ad usarle.

\section{Variabili speciali}
\subsection{request}
Questa è la variabile usata più comunemente. Contiene tutte le informazioni sulle richiesta
pervenute da un client. E' un'istanza di classe che contiene alcune variabili membro che
sono generate da CherryPy per ogni richiesta. Le variabili membro usate più comunemente sono:
\begin{itemize}
\item
\strong{request.headerMap}: è un dizionario Python contenente tutte le chiavi e i valori inviati
dal client nell'intestazione della richiesta.
Notate che tutte le chiavi sono sempre convertite in minuscolo. Per esempio, per trovare il tipo
di browser usato dal client, usate \var{request.headerMap['user-agent']}
(notate che queste informazioni possono non essere inviate dal client)
\item
\strong{request.simpleCookie}: è un oggetto \var{simpleCookie} contenente il cookies inviato dal client.
Notate che questa informazione è disponibile anche in  \var{request.headerMap['cookie']}. 
Controllate l'HowTo per imparare ad usare i cookie con CherryPy.
\item
\strong{request.base}: stringa contenente l'URL base del sito. E' equivalente a \var{'http://'+request.headerMap['host']}
\item
\strong{request.path e request.paramMap}: la prima contiene il percorso della pagina che è stata inizialmente richiesta. Caratteri '/' iniziali o finali sono rimossi (se necessario).
La seconda è un dizionario contenente una chiave ed un valore per ogni parametro che il client
invia (via GET o POST). Per esempio, se l'URL è:
\begin{verbatim}
http://localhost:8000/dir/page?key1=value1&key2=value2
\end{verbatim}
avremo:
\begin{verbatim}
request.base == 'http://localhost:8000'
and
request.path == 'dir/page'
and
request.paramMap == {'key1': 'value1', 'key2': 'value2'}
\end{verbatim}
\item
\strong{request.originalPath e request.originalParamMap}: queste variabili sono una copia di
 \var{request.path} e \var{request.paramMap}. Ma come vedremo nella prossima sezione, è possibile
 modificare \var{request.path} e \var{request.paramMap}. 
In questo caso, \var{request.originalPath} e \var{request.originalParamMap} mantengono
i valori originali.
\item
\strong{request.browserUrl}: stringa contenente l'URL come appare nella finestra del browser.
\item
\strong{request.method}: Stringa contenente o \var{GET} o \var{POST}, per indicare che tipo di richiesta è stata fatta.
\item
\strong{request.wfile} (solo per uso avanzato): date un'occhiata all'HowTo su "Come uploadare un file direttamente du disco" per maggiori informazioni all'uso.
\end{itemize}

\subsection{response}
Questa è la seconda variabile usata più comunemente (dopo \var{request}).
Contiene tutte le informazioni sui responsi che saranno inviati al client.
E' un'instanza di classe che contiene alcune variabili membro che sono generate
da CherryPy o dal vostro programma.
\begin{itemize}
\item
\strong{response.headerMap}: è un dizionario Python che contiene tutte le chiavi e i valori 
che verranno inviati nell'intestazione delle risposte.
Di default, CherryPy genera le seguente coppie chiave/valore:
\begin{verbatim}
"status": 200
"content-type": "text/html"
"server": "CherryPy 0.1"
"date": current date
"set-cookie": []
"content-length": 0
\end{verbatim}
Nel prossimo capitolo impareremo come usare e modificare questi valori.
\item
\strong{response.body}: stringa contenente il corpo della risposta. Questa variabile può essere usata solo in 3 funzioni speciali (vedi sotto)
\item
\strong{response.simpleCookie}: oggetto \var{simpleCookie} usato per inviare cookies al browser. Notate che i cookie possono anche essere inviati usando \var{response.headerMap['cookie']}.
Date un'occhiata all'HowTo per imparare l'uso dei cookie con CherryPy.
\strong{response.sendResponse e response.wfile} (solo per uso avanzato): usato per lo streaming. Date un'occhiata alla sezione dell'HowTo chiamata "How to use streaming with CherryPy" per maggiori informazioni.
\end{itemize}

\section{Funzioni speciali}
Nel vostro codice potete definire funzioni speciali che modificheranno il comportamento del server. Per definire queste funzioni, usate la sintassi Python e definitele fuori dalle CherryClass. Quando usate moduli differenti, potete definire la stessa funzione in moduli differenti. In questo caso, CherryPy concatenerà i corpi di tutte le funzioni nello stesso ordine di lettura dei file.

\subsection{initRequest, initNonStaticRequest, initResponse e initNonStaticResponse}
Ecco l'algoritmo che il server usa quando riceve una richiesta (se non specificato, l'operazione
si riferisce ad ogni tipo di contenuto):

\begin{enumerate}

\item  arriva la richiesta
\item Genera tutte le variabili membro di \var{request}
\item Chiama \var{initRequest} (che può modificare \var{request.path} e \var{request.paramMap})
\item Determina se questa richiesta corrisponde a contenuto statico o dinamico (basato su \var{request.path}
        e la sezione \var{staticContent} del file di configurazione)
\item \strong{(Solo per contenuto dinamico)} Chiama \var{initNonStaticRequest} (che può modificare \var{request.path} e \var{request.paramMap})
\item \strong{(solo per contenuto statico)} Legge il file statico e genera i valori di \var{response.headerMap} e \var{response.body} in modo appropriato
\item \strong{(solo per contenuto dinamico)} Chiama il metodo dell'istanza CherryClass, con alcuni argomenti (basati su \var{request.path} e
        \var{request.paramMap}) e genera i valori di \var{response.headerMap} e \var{response.body} in accordo con i risultati
\item \strong{(solo per contenuto statico)} Chiama \var{initResponse} (che può modificare \var{response.headerMap} e \var{response.body})
\item  \strong{(solo per contenuto dinamico)} Chiama \var{initResponse} (che può modificare \var{response.headerMap} e \var{response.body})
\item  \strong{(solo per contenuto statico)} Invia un responso al browser (basato su \var{response.headerMap} e \var{response.body})
\item  \strong{(solo per contenuto dinamico)} Invia un responso al browser (basato su \var{response.headerMap} e \var{response.body})
\end{enumerate}

Come potete vedere, \var{initRequest} e \var{initNonStaticRequest} possono essere usate per 
un aggiustamento fine dell'URL o dei parametri, o per fare qualsiasi lavoro che deve
essere eseguito su ogni richiesta.

\var{initResponse} e \var{initNonStaticResponse} possono essere usate per cambiare l'intestazione della risposta o del corpo, prima che venga invita al client.


\subsection{onError}
Questa funzione è chiamata da CherryPy quando avviene un errore durante la costruzione della pagina.
Guardate la prossima sezione per un esempio.

\subsection{initThread, initProcess}
Se usate un server thread-pool o process-pool, sarà chiamata la funzione corrispondente (rispettivamente
 \var{initThread} o \var{initProcess}) per ogni nuovo thread/processo creato.

 Queste funzioni possono essere usate per esempio se volete avere per ogni thread/processo
 una propria connessione ad un database (l'HowTo chiamato "Sample deployment
configuration for a real-world website" spiega come farlo).

\var{initThread} prende un argomento chiamato \var{threadIndex} contenente l'indice
del thread che deve essere creato. Per esempio, se volete creare 10 threads, \var{threadIndex} avrà i valori da 0 a 9.

\subsection{initProgram, initServer, initAfterBind}
Il codice in  \var{initProgram} viene copiato all'inizio del file generato, in modo da essere la prima cosa ad essere eseguita.
Potete usare le funzioni speciali se avete bisogno di eseguire del codice prima che
vengano istanziate le CherryClass.
Quindi, il server crea tutte le instanze delle CherryClass e quindi chiama la funzione
speciale \var{initServer}. Questo è basilarmente il posto dove mettere tutti i passi
di inizializzazione necessari.

\var{initAfterBind} viene chiamata dopo che il socket si è messo in "ascolto". Per esempio,
su sistemi Unix-based, dovrete far partitre CherryPy come root se volete che si metta
in ascolto sulla porta 80. La funzione speciale \var{initAfterBind} può essere usata
per cambiare l'utente proprietario del processo in ascolto in uno non privilegiato.
(l'HowTo chiamato "Sample deployment
configuration for a real-world website" spiega come farlo).

\subsection{initRequestBeforeParse (solo per uso avanzato)}
Questa funzione speciale è chiamata dal server quando riceve una richiesta di tipo POST,
prima di analizzare i dati POST. Questo vi permette per esempio di dire al server di non 
analizzare i dati POST (settando la variabile \var{request.parsePostData} a \var{0}) e quindi
potete analizzare i dati POST voi stessi (leggendoli da  \var{request.rfile}). Controllate l'HowTo chiamato "How to stream uploaded files directly to disk" per maggiori informazioni.

\section{Esempi}
\subsection{Giochiamo con gli URL}
Abbiamo detto di voler mettere su un sito per i nostri clienti. Vogliamo che i nostri clienti
abbiano il proprio URL:
\url{http://host/customerName}, ma che la pagina sia sempre la stessa per ogni cliente, così
da non dover creare un metodo per ogni cliente.

Tutto ciò che dovete fare è usare \var{initNonStaticRequest} per convertire l'URL \url{http://host/customerName} in
\url{http://host?customer=customerName}. Tutto questo sarà trasparente all'utente.

Scriviamo il seguente codice:
\begin{verbatim}
def initNonStaticRequest():
    if request.path:
        request.paramMap['customer']=request.path
        request.path=""
CherryClass Root:
mask:
    def index(self, customer=""):
        <html><body>
            Hello, <py-eval="customer">
        </body></html>
\end{verbatim}
E questo è tutto !

Compilate il file, fate partire il server e provate gli URL, come \url{http://localhost:8000/customer1}
o \url{http://localhost:8000/world}

\subsection{Ridirezione}
Per inviare un \var{redirect} al browser,  tutto quello che dovete fare è inviare un codice di stato \var{302} (invece
di 200), e generare un valore \var{location} nell'intestazione della risposta. Questo può essere fatto facilmente usando la variabile speciale \var{response.headerMap}:
\begin{verbatim}
CherryClass Root:
mask:
    def index(self):
        <html><body>
            <a href="loop">Click here to come back to this page</a>
        </body></html>
view:
    def loop(self):
        response.headerMap['status']=302
        response.headerMap['location']=request.base
        return "" # A view should always return a string
\end{verbatim}

\subsection{Aggiungere informazioni sul tempo di costruzione in ogni pagina}
In questo esempio, aggiungeremo una linea alla fine di ogni pagina che è generata dal server.
Questa linea conterrà il tempo impiegato per costruire la pagina. Naturalmente, vogliamo questa linea
solo per le pagine HTML dinamiche.

Tutto quello che dobbiamo fare è usare \var{initNonStaticRequest} per memorizzare la partenza, e \var{initNonStaticResponse}
per aggiungere la linea contenente il tempo impiegato per la costruzione.

Ecco il codice:
\begin{verbatim}
import time
def initNonStaticRequest():
    request.startTime=time.time()
def initNonStaticResponse():
    if response.headerMap['content-type']=='text/html':
        response.body+='<br>Time: %.04fs'%(time.time()-request.startTime)
CherryClass Root:
mask:
    def index(self):
        <html><body>
            Hello, world
        </body></html>
\end{verbatim}

Et voila

\subsection{Adattare i messaggi di errore}
Questo può essere fatto usando la funzione speciale \var{onError}.
Usate \var{response.headerMap} e \var{response.body} per fare quello che desiderate.

L'esempio che segue mostra come configurare il tutto per inviare una mail 
ogni volta che viene incontrato un errore:
\begin{verbatim}
use Mail

def onError():
    # Get the error in a string
    import traceback, StringIO
    bodyFile=StringIO.StringIO()
    traceback.print_exc(file=bodyFile)
    errorBody=bodyFile.getvalue()
    bodyFile.close()
    # Send an email with the error
    myMail.sendMail("erreur@site.com", "webmaster@site.com", "", "text/plain", "An error occured on your site", errorBody)
    # Set the body of the response
    response.body="<html><body><br><br><center>"
    response.body+="Sorry, an error occured<br>"
    response.body+="An email has been sent to the webmaster"
    response.body+="</center></body></html>"


CherryClass MyMail(Mail):
function:
    def __init__(self):
        self.smtpServer='smtp.site.com'

CherryClass Root:
mask:
    def index(self):
        <html><body>
            <a py-attr="request.base+'/generateError'" href="">
                    Click here to generate an error</a>
        </body></html>
    def generateError(self):
        <html><body>
            You'll never see this: <py-eval="1/0">
        </body></html>
\end{verbatim}

Questo esempio mostra anche l'uso del modulo standard \var{Mail} compreso in CherryPy.

\chapter{Approntare il vostro sito per la produzione}

Siete giunti ad avere un grosso sito su cui avete speso settimane di lavoro per approntarlo.
E siete finalmente pronti per farlo usare al mondo !

Ma state ancora decidendo come \strong{utilizzarlo}, il che significa: come configurarlo per le macchine di produzione.

\section{Scelta della configurazione}

Durante la fase di sviluppo del vostro sito, siete i soli (forse con qualche altro sviluppatore) ad accedere al sito, così non è necessario sia veloce e robusto. Ma ad un sito per la produzione accederanno molte persone (se siete fortunati). Il che comporta la scelta di una configurazione
del CherryPy appropriata in modo da provvedere un servizio veloce e costante ai vostri utenti.

Un criterio per aiutarvi a scegliere una configurazione, include:
\begin{itemize}
\item
\strong{Cosa vi permette di fare il vostro hosting provider ?} Se usate una macchina condivisa,
potreste non poter fare cosa volete.
Per esempio, potreste solo poter usare CGI, e il vostro hosting provider potrebbe solo
provvedere un hosting virtuale basato su Apache.
\item
\strong{Quanto traffico prevedete di avere ?} Prevedete di avere solo qualche centinaio di utenti al giorno o alcune decine di migliaia ?
\item
\strong{Di quante macchine/processori disponete ? } Se prevedete di avere molto traffico, potrebbe essere meglio usare alcune macchine/processori  (che potrebbero avere un discreto costo).
\item
\strong{Avrete un webmaster per controllare il vostro sito ?} Se non avete nessuno che controlli il vostro sito, potreste volere che il sito riparta automaticamente in caso di crash.
\end{itemize}

\strong{Notate che c'è un HowTo chiamato "Sample deployment configuration for a
real-world website" che contiene un esempio completo di configurazione raccomandato per la maggior parte dei siti.}

\subsection{Dovrei usare CherryPy HTTP server direttamente o con un altro webserver come Apache ?}
La prima decisione da prendere è se usare CherryPy HTTP server direttamente o dietro in altro
webserver come Apache.
Ecco una lista di vantaggi per ogni metodo:
\subsubsection{Uso diretto}
\begin{itemize}
\item
E' più veloce e usa meno risorse (nessun processo Apache e nessuna necessità di dialogo
tra Apache e CherryPy)
\item
E' facile da implementare
\end{itemize}
\subsubsection{Uso dietro Apache}
\begin{itemize}
\item
Potrebbe esser più veloce per contenuti statici (come immagini)
\item
Hosting provider potrebbe forzare l'uso di Apache
\end{itemize}

Una volta deciso se usare CherryPy direttamente o dietro un altro webserver, dovrete decidere fra alcune configurazioni...

\subsection{Opzioni per utilizzare CherryPy direttamente}
Le sezioni che seguono vi mostreranno le diverse opzioni e i loro vantaggi/svantaggi:
\subsubsection{Single thread/process}
\strong{Spiegazione}: il CherryPy HTTP server verrà eseguito in solo thread/process. Durante l'esame di una richiesta, non ci possono essere altre connessioni.

Vantaggi:
\begin{itemize}
\item
Velocità su ogni richiesta (nessuna necessità di creare un processo per ogni richiesta)
\end{itemize}
Svantaggi:
\begin{itemize}
\item
Non possono essere esaminate richieste concorrenti
\end{itemize}
\strong{Conclusione}: Questo è il metodo di default e funziona bene per la fase di sviluppo,
ma dovrebbe essere vietata per la produzione se avrete diversi utenti che accedono al sito nello stesso momento.

\subsubsection{Forking server}
\strong{Spiegazione}: il CherryPy HTTP server creerà un nuovo processo
per esaminare ogni richiesta. Dopo che è stata inviata la risposta, il processo viene distrutto.

Vantaggi:
\begin{itemize}
\item
Possibilità di esaminare richieste multiple allo stesso tempo.
\item
Su una macchina multiprocessore, un forking server trarrà  vantaggio dai processori multipli.
\end{itemize}
Svantaggi:
\begin{itemize}
\item
La creazione di un processo per ogni richiesta potrebbe prendere diverse risorse (specialmente se le richieste arrivano molto velocemente)
\item
Forking non funziona su Windows
\item
Non si possono usare le sessioni in modo semplice così come non  si possono facilmente condividere session data tra processi.
\end{itemize}
\strong{Conclusione}: Questo metodo può essere usato su sistemi non-Windows se il traffico non è molto elevato.

\subsubsection{Threading server}
\strong{Spiegazione}:  il CherryPy HTTP server creerà un nuovo thread per esaminare ogni richiesta. Dopo la risposta, il thread è distrutto.

Vantaggi:
\begin{itemize}
\item
Possibilità di esaminare più richieste alla volta
\item
Funziona su tutte le piattaforme (incluso Windows)
\end{itemize}
Svantaggi:
\begin{itemize}
\item
Potrebbe essere dispendioso in fatto di risorse creare un nuovo thread per ogni richiesta (benché meno dispendioso rispetto ai processi) specialmente se le richieste arrivano molto velocemente
\item
Su macchine multiprocessore, un threading server \strong{non} trarrà vantaggio dai processori multipli ( a causa del global interpreter lock del Python)
\end{itemize}
\strong{Conclusione}: Questo metodo può essere usato per siti con un traffico non molto alto.


\subsubsection{Process pool}
\strong{Spiegazione}: in questo caso il CherryPy HTTP server creerà un numero fissato di processi all'avvio i quali persisteranno tutto il tempo di vita del server. Se un processo è occupato ad esaminare una richiesta e ne arriva un'altra, un altro processo si prenderà in carico l'esame di questa nuova richiesta.

Vantaggi:
\begin{itemize}
\item
Possono essere esaminte più richieste alla volta
\item
Veloce, dato che non c'è bisogno di creare un thread o un processo per ogni richiesta
\item
Trae vantaggio da macchine multiprocessore
\end{itemize}
Svantaggi:
\begin{itemize}
\item
Non funziona sotto Windows
\item
Non si possono usare le sessioni in modo semplice così come non  si possono facilmente condividere session data tra processi.
\end{itemize}
\strong{Conclusione}: Questo metodo funziona bene su macchine non-Windows a finché non arrivano
centinaia di utenti concorrenti.

\subsubsection{Thread pool}
\strong{Spiegazione}:  questo è il caso un cui il CherryPy HTTP server creerà un numero fissato di thread all'avvio e questi rimarrano attivi per tutto il tempo di vita del server. Se un thread
è occupato ad esaminare una richiesta e arriva un'altra richiesta, questa viene presa in carico da un altro thread.

Vantaggi:
\begin{itemize}
\item
Possono essere esaminate più richieste alla volta
\item
Veloce, perché non sarà creato un thread o un processo per ogni richiesta
\end{itemize}
Svantaggi:
\begin{itemize}
\item
Non trae vantaggio da macchine multiprocessore
\item
Il numero dei thread non aumenta se abbiamo più utenti concorrenti
\end{itemize}
\strong{Conclusione}: Questo metodo funziona molto bene ed è quello raccomandato in molti casi (finché non ci sono centinaia di utenti concorrenti).

\subsubsection{Altre alternative}
Se avete \strong{realmente} molto traffico e i metodi sin qui presentanti non sono sufficienti
o non potete usarli (se per esempio usate Windows), potete allora usare un generico load-balancing. C'è un HowTo nella documentazione che ne parla.

\subsection{Opzioni per utilizzare CherryPy dietro in altro webserver}
Tutte le configurazioni descritte nella precedente sezione sono disponibili anche utilizzando
CherryPy dietro un altro webserver. Webserver di terze parti sono generalmente
multi-thread o multi-processo. C'è un HowTo nella documentazione che spiega la configurazione
in questo caso.

\section{Opzioni del file di configurazione}
Segue una lista di opzioni che sono usate per specificare come sarà utilizzato il CherryPy server. Tutte queste opzioni sono poste nella sezione \var{[server]} del file di configurazione. (confronta il capitolo "Configurare CherryPy").
\begin{itemize}
\item
\strong{socketPort}: indica su che porta il server dovrebbe essere in ascolto: Per esempio:
\begin{verbatim}
[server]
socketPort=80
\end{verbatim}
\item
\strong{socketHost}: indica l'indirizzo del server (di default è localhost). Esempio:
\begin{verbatim}
[server]
socketHost=192.168.0.23
\end{verbatim}
\item
\strong{socketFile}: usata solo in Unix, se vogliamo usare un socket AF_UNIX invece di un
socket AF_INET. Esempio:
\begin{verbatim}
[server]
socketFile=/tmp/mySocket.soc
\end{verbatim}
\item
\strong{forking}: ponete questa a  1 se volete un forking server. Esempio:
\begin{verbatim}
[server]
socketPort=80
forking=1
\end{verbatim}
\item
\strong{threading}: ponete questa a 1 se volete un threading server. Esempio:
\begin{verbatim}
[server]
socketPort=80
threading=1
\end{verbatim}
\item
\strong{processPool}: ponete questa a n (n>1) se volete creare n processi all'avvio del server. Esempio:
\begin{verbatim}
[server]
socketPort=80
processPool=10
\end{verbatim}
\item
\strong{threadPool}: ponete questa a n (n>1) se volete creare n thread all'avvio del server. Esempio:
\begin{verbatim}
[server]
socketPort=80
threadPool=10
\end{verbatim}
\item
\strong{reverseDNS}: ponete questa a 1 se volete abilitare un reverse DNS (in questo modo il nome completo del dominio dei client sarà scritto nei log). Di default è 0. Esempio:
\begin{verbatim}
[server]
socketPort=80
reverseDNS=1
\end{verbatim}
\item
\strong{socketQueueSize}: dimensione della coda del socket (questo valore sarà passato alla funzione listen()). Il default è 5: Esempio:
\begin{verbatim}
[server]
socketPort=80
socketQueueSize=5
\end{verbatim}
\item
\strong{sslKeyFile e sslCertificateFile}:  usate se avete un server SSL. C'è un HowTo nella documentazione per questo.
\item
\strong{xmlRpc}: usata se avete un server XML-RPC. C'è un HowTo nella documentazione per questo.
\end{itemize}

Alcune di queste opzioni non possono ovviamente essere usate insieme altrimenti causerebbero un conflitto:
\begin{itemize}
\item
\strong{socketFile} e \strong{socketPort} ovviamente entrano in conflitto una con l'altra
\item
\strong{threading}, \strong{forking}, \strong{processPool} e \strong{threadPool} entrano in conflitto tra loro
\end{itemize}

\chapter{E poi ?}
Questo tutorial dovrebbe essere sufficiente per capire come funziona CherryPy e per sviluppare
alcuni siti reali.

Potete dare un'occhiata al resto della documentazione (HowTo, library module reference ...) per
conoscere caratteristiche avanzate.

Se avete bisogno di aiuto, inviate un messaggio alla mailing list e saremo felici di aiutarvi.

Speriamo siate contenti di usare CherryPy come lo siamo noi.


\chapter{History e Licenza}
\input{license}

\end{document}
