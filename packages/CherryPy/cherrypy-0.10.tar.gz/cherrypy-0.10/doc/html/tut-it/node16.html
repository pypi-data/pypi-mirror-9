<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>14. Variabili e funzioni speciali</title>
<META NAME="description" CONTENT="14. Variabili e funzioni speciali">
<META NAME="keywords" CONTENT="tut">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="STYLESHEET" href="tut.css" type='text/css'>
<link rel="first" href="tut.html">
<link rel="contents" href="contents.html" title="Contents">

<LINK REL="next" HREF="node17.html">
<LINK REL="previous" HREF="node15.html">
<LINK REL="up" HREF="tut.html">
<LINK REL="next" HREF="node17.html">
<meta name='aesop' content='information'>
</head>
<body>
<DIV CLASS="navigation">
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td><A HREF="node15.html"><img src="../icons/previous.gif"
  border="0" height="32"
  alt="Previous Page" width="32"></A></td>
<td><A HREF="tut.html"><img src="../icons/up.gif"
  border="0" height="32"
  alt="Up One Level" width="32"></A></td>
<td><A HREF="node17.html"><img src="../icons/next.gif"
  border="0" height="32"
  alt="Next Page" width="32"></A></td>
<td align="center" width="100%">CherryPy Tutorial</td>
<td><A HREF="node2.html"><img src="../icons/contents.gif"
  border="0" height="32"
  alt="Contents" width="32"></A></td>
<td><img src="../icons/blank.gif"
  border="0" height="32"
  alt="" width="32"></td>
<td><img src="../icons/blank.gif"
  border="0" height="32"
  alt="" width="32"></td>
</tr></table>
<b class="navlabel">Previous:</b> <a class="sectref" HREF="node15.html">13. Usare le proprie</A>
<b class="navlabel">Up:</b> <a class="sectref" HREF="tut.html">CherryPy Tutorial</A>
<b class="navlabel">Next:</b> <a class="sectref" HREF="node17.html">15. Approntare il vostro</A>
<br><hr>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></a>

<UL CLASS="ChildLinks">
<LI><A href="node16.html#SECTION0016100000000000000000">14.1 Variabili speciali</a>
<UL>
<LI><A href="node16.html#SECTION0016110000000000000000">14.1.1 request</a>
<LI><A href="node16.html#SECTION0016120000000000000000">14.1.2 response</a>
</ul>
<LI><A href="node16.html#SECTION0016200000000000000000">14.2 Funzioni speciali</a>
<UL>
<LI><A href="node16.html#SECTION0016210000000000000000">14.2.1 initRequest, initNonStaticRequest, initResponse e initNonStaticResponse</a>
<LI><A href="node16.html#SECTION0016220000000000000000">14.2.2 onError</a>
<LI><A href="node16.html#SECTION0016230000000000000000">14.2.3 initThread, initProcess</a>
<LI><A href="node16.html#SECTION0016240000000000000000">14.2.4 initProgram, initServer, initAfterBind</a>
<LI><A href="node16.html#SECTION0016250000000000000000">14.2.5 initRequestBeforeParse (solo per uso avanzato)</a>
</ul>
<LI><A href="node16.html#SECTION0016300000000000000000">14.3 Esempi</a>
<UL>
<LI><A href="node16.html#SECTION0016310000000000000000">14.3.1 Giochiamo con gli URL</a>
<LI><A href="node16.html#SECTION0016320000000000000000">14.3.2 Ridirezione</a>
<LI><A href="node16.html#SECTION0016330000000000000000">14.3.3 Aggiungere informazioni sul tempo di costruzione in ogni pagina</a>
<LI><A href="node16.html#SECTION0016340000000000000000">14.3.4 Adattare i messaggi di errore</a>
</ul></ul>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION0016000000000000000000">
14. Variabili e funzioni speciali</A>
</H1>

<P>
CherryPy genera e usa alcune variabili e funzioni speciali. Sono molto facili da usare, ma
altrettanto potenti. In questo capitolo vedremo cosa sono queste variabili e funzioni, mentre nel prossimo impareremo ad usarle.

<P>

<H1><A NAME="SECTION0016100000000000000000">
14.1 Variabili speciali</A>
</H1>

<H2><A NAME="SECTION0016110000000000000000">
14.1.1 request</A>
</H2>
Questa &#232; la variabile usata pi&#249; comunemente. Contiene tutte le informazioni sulle richiesta
pervenute da un client. E' un'istanza di classe che contiene alcune variabili membro che
sono generate da CherryPy per ogni richiesta. Le variabili membro usate pi&#249; comunemente sono:

<UL>
<LI><b>request.headerMap</b>: &#232; un dizionario Python contenente tutte le chiavi e i valori inviati
dal client nell'intestazione della richiesta.
Notate che tutte le chiavi sono sempre convertite in minuscolo. Per esempio, per trovare il tipo
di browser usato dal client, usate <var>request.headerMap['user-agent']</var>
(notate che queste informazioni possono non essere inviate dal client)
</LI>
<LI><b>request.simpleCookie</b>: &#232; un oggetto <var>simpleCookie</var> contenente il cookies inviato dal client.
Notate che questa informazione &#232; disponibile anche in  <var>request.headerMap['cookie']</var>. 
Controllate l'HowTo per imparare ad usare i cookie con CherryPy.
</LI>
<LI><b>request.base</b>: stringa contenente l'URL base del sito. E' equivalente a <var>'http://'+request.headerMap['host']</var>
</LI>
<LI><b>request.path e request.paramMap</b>: la prima contiene il percorso della pagina che &#232; stata inizialmente richiesta. Caratteri '/' iniziali o finali sono rimossi (se necessario).
La seconda &#232; un dizionario contenente una chiave ed un valore per ogni parametro che il client
invia (via GET o POST). Per esempio, se l'URL &#232;:
<div class="verbatim"><pre>
http://localhost:8000/dir/page?key1=value1&amp;key2=value2
</pre></div>
avremo:
<div class="verbatim"><pre>
request.base == 'http://localhost:8000'
and
request.path == 'dir/page'
and
request.paramMap == {'key1': 'value1', 'key2': 'value2'}
</pre></div>
</LI>
<LI><b>request.originalPath e request.originalParamMap</b>: queste variabili sono una copia di
 <var>request.path</var> e <var>request.paramMap</var>. Ma come vedremo nella prossima sezione, &#232; possibile
 modificare <var>request.path</var> e <var>request.paramMap</var>. 
In questo caso, <var>request.originalPath</var> e <var>request.originalParamMap</var> mantengono
i valori originali.
</LI>
<LI><b>request.browserUrl</b>: stringa contenente l'URL come appare nella finestra del browser.
</LI>
<LI><b>request.method</b>: Stringa contenente o <var>GET</var> o <var>POST</var>, per indicare che tipo di richiesta &#232; stata fatta.
</LI>
<LI><b>request.wfile</b> (solo per uso avanzato): date un'occhiata all'HowTo su "Come uploadare un file direttamente du disco" per maggiori informazioni all'uso.
</LI>
</UL>

<P>

<H2><A NAME="SECTION0016120000000000000000">
14.1.2 response</A>
</H2>
Questa &#232; la seconda variabile usata pi&#249; comunemente (dopo <var>request</var>).
Contiene tutte le informazioni sui responsi che saranno inviati al client.
E' un'instanza di classe che contiene alcune variabili membro che sono generate
da CherryPy o dal vostro programma.

<UL>
<LI><b>response.headerMap</b>: &#232; un dizionario Python che contiene tutte le chiavi e i valori 
che verranno inviati nell'intestazione delle risposte.
Di default, CherryPy genera le seguente coppie chiave/valore:
<div class="verbatim"><pre>
"status": 200
"content-type": "text/html"
"server": "CherryPy 0.1"
"date": current date
"set-cookie": []
"content-length": 0
</pre></div>
Nel prossimo capitolo impareremo come usare e modificare questi valori.
</LI>
<LI><b>response.body</b>: stringa contenente il corpo della risposta. Questa variabile pu&#242; essere usata solo in 3 funzioni speciali (vedi sotto)
</LI>
<LI><b>response.simpleCookie</b>: oggetto <var>simpleCookie</var> usato per inviare cookies al browser. Notate che i cookie possono anche essere inviati usando <var>response.headerMap['cookie']</var>.
Date un'occhiata all'HowTo per imparare l'uso dei cookie con CherryPy.
<b>response.sendResponse e response.wfile</b> (solo per uso avanzato): usato per lo streaming. Date un'occhiata alla sezione dell'HowTo chiamata "How to use streaming with CherryPy" per maggiori informazioni.
</LI>
</UL>

<P>

<H1><A NAME="SECTION0016200000000000000000">
14.2 Funzioni speciali</A>
</H1>
Nel vostro codice potete definire funzioni speciali che modificheranno il comportamento del server. Per definire queste funzioni, usate la sintassi Python e definitele fuori dalle CherryClass. Quando usate moduli differenti, potete definire la stessa funzione in moduli differenti. In questo caso, CherryPy concatener&#224; i corpi di tutte le funzioni nello stesso ordine di lettura dei file.

<P>

<H2><A NAME="SECTION0016210000000000000000">
14.2.1 initRequest, initNonStaticRequest, initResponse e initNonStaticResponse</A>
</H2>
Ecco l'algoritmo che il server usa quando riceve una richiesta (se non specificato, l'operazione
si riferisce ad ogni tipo di contenuto):

<P>

<OL>
<LI>arriva la richiesta
</LI>
<LI>Genera tutte le variabili membro di <var>request</var>
</LI>
<LI>Chiama <var>initRequest</var> (che pu&#242; modificare <var>request.path</var> e <var>request.paramMap</var>)
</LI>
<LI>Determina se questa richiesta corrisponde a contenuto statico o dinamico (basato su <var>request.path</var>
        e la sezione <var>staticContent</var> del file di configurazione)
</LI>
<LI><b>(Solo per contenuto dinamico)</b> Chiama <var>initNonStaticRequest</var> (che pu&#242; modificare <var>request.path</var> e <var>request.paramMap</var>)
</LI>
<LI><b>(solo per contenuto statico)</b> Legge il file statico e genera i valori di <var>response.headerMap</var> e <var>response.body</var> in modo appropriato
</LI>
<LI><b>(solo per contenuto dinamico)</b> Chiama il metodo dell'istanza CherryClass, con alcuni argomenti (basati su <var>request.path</var> e
        <var>request.paramMap</var>) e genera i valori di <var>response.headerMap</var> e <var>response.body</var> in accordo con i risultati
</LI>
<LI><b>(solo per contenuto statico)</b> Chiama <var>initResponse</var> (che pu&#242; modificare <var>response.headerMap</var> e <var>response.body</var>)
</LI>
<LI><b>(solo per contenuto dinamico)</b> Chiama <var>initResponse</var> (che pu&#242; modificare <var>response.headerMap</var> e <var>response.body</var>)
</LI>
<LI><b>(solo per contenuto statico)</b> Invia un responso al browser (basato su <var>response.headerMap</var> e <var>response.body</var>)
</LI>
<LI><b>(solo per contenuto dinamico)</b> Invia un responso al browser (basato su <var>response.headerMap</var> e <var>response.body</var>)
</LI>
</OL>

<P>
Come potete vedere, <var>initRequest</var> e <var>initNonStaticRequest</var> possono essere usate per 
un aggiustamento fine dell'URL o dei parametri, o per fare qualsiasi lavoro che deve
essere eseguito su ogni richiesta.

<P>
<var>initResponse</var> e <var>initNonStaticResponse</var> possono essere usate per cambiare l'intestazione della risposta o del corpo, prima che venga invita al client.

<P>

<H2><A NAME="SECTION0016220000000000000000">
14.2.2 onError</A>
</H2>
Questa funzione &#232; chiamata da CherryPy quando avviene un errore durante la costruzione della pagina.
Guardate la prossima sezione per un esempio.

<P>

<H2><A NAME="SECTION0016230000000000000000">
14.2.3 initThread, initProcess</A>
</H2>
Se usate un server thread-pool o process-pool, sar&#224; chiamata la funzione corrispondente (rispettivamente
 <var>initThread</var> o <var>initProcess</var>) per ogni nuovo thread/processo creato.

<P>
Queste funzioni possono essere usate per esempio se volete avere per ogni thread/processo
 una propria connessione ad un database (l'HowTo chiamato "Sample deployment
configuration for a real-world website" spiega come farlo).

<P>
<var>initThread</var> prende un argomento chiamato <var>threadIndex</var> contenente l'indice
del thread che deve essere creato. Per esempio, se volete creare 10 threads, <var>threadIndex</var> avr&#224; i valori da 0 a 9.

<P>

<H2><A NAME="SECTION0016240000000000000000">
14.2.4 initProgram, initServer, initAfterBind</A>
</H2>
Il codice in  <var>initProgram</var> viene copiato all'inizio del file generato, in modo da essere la prima cosa ad essere eseguita.
Potete usare le funzioni speciali se avete bisogno di eseguire del codice prima che
vengano istanziate le CherryClass.
Quindi, il server crea tutte le instanze delle CherryClass e quindi chiama la funzione
speciale <var>initServer</var>. Questo &#232; basilarmente il posto dove mettere tutti i passi
di inizializzazione necessari.

<P>
<var>initAfterBind</var> viene chiamata dopo che il socket si &#232; messo in "ascolto". Per esempio,
su sistemi Unix-based, dovrete far partitre CherryPy come root se volete che si metta
in ascolto sulla porta 80. La funzione speciale <var>initAfterBind</var> pu&#242; essere usata
per cambiare l'utente proprietario del processo in ascolto in uno non privilegiato.
(l'HowTo chiamato "Sample deployment
configuration for a real-world website" spiega come farlo).

<P>

<H2><A NAME="SECTION0016250000000000000000">
14.2.5 initRequestBeforeParse (solo per uso avanzato)</A>
</H2>
Questa funzione speciale &#232; chiamata dal server quando riceve una richiesta di tipo POST,
prima di analizzare i dati POST. Questo vi permette per esempio di dire al server di non 
analizzare i dati POST (settando la variabile <var>request.parsePostData</var> a <var>0</var>) e quindi
potete analizzare i dati POST voi stessi (leggendoli da  <var>request.rfile</var>). Controllate l'HowTo chiamato "How to stream uploaded files directly to disk" per maggiori informazioni.

<P>

<H1><A NAME="SECTION0016300000000000000000">
14.3 Esempi</A>
</H1>

<H2><A NAME="SECTION0016310000000000000000">
14.3.1 Giochiamo con gli URL</A>
</H2>
Abbiamo detto di voler mettere su un sito per i nostri clienti. Vogliamo che i nostri clienti
abbiano il proprio URL:
<a class="url" href="http://host/customerName">http://host/customerName</a>, ma che la pagina sia sempre la stessa per ogni cliente, cos&#236;
da non dover creare un metodo per ogni cliente.

<P>
Tutto ci&#242; che dovete fare &#232; usare <var>initNonStaticRequest</var> per convertire l'URL <a class="url" href="http://host/customerName">http://host/customerName</a> in
<a class="url" href="http://host?customer=customerName">http://host?customer=customerName</a>. Tutto questo sar&#224; trasparente all'utente.

<P>
Scriviamo il seguente codice:
<div class="verbatim"><pre>
def initNonStaticRequest():
    if request.path:
        request.paramMap['customer']=request.path
        request.path=""
CherryClass Root:
mask:
    def index(self, customer=""):
        &lt;html&gt;&lt;body&gt;
            Hello, &lt;py-eval="customer"&gt;
        &lt;/body&gt;&lt;/html&gt;
</pre></div>
E questo &#232; tutto !

<P>
Compilate il file, fate partire il server e provate gli URL, come <a class="url" href="http://localhost:8000/customer1">http://localhost:8000/customer1</a>o <a class="url" href="http://localhost:8000/world">http://localhost:8000/world</a>
<P>

<H2><A NAME="SECTION0016320000000000000000">
14.3.2 Ridirezione</A>
</H2>
Per inviare un <var>redirect</var> al browser,  tutto quello che dovete fare &#232; inviare un codice di stato <var>302</var> (invece
di 200), e generare un valore <var>location</var> nell'intestazione della risposta. Questo pu&#242; essere fatto facilmente usando la variabile speciale <var>response.headerMap</var>:
<div class="verbatim"><pre>
CherryClass Root:
mask:
    def index(self):
        &lt;html&gt;&lt;body&gt;
            &lt;a href="loop"&gt;Click here to come back to this page&lt;/a&gt;
        &lt;/body&gt;&lt;/html&gt;
view:
    def loop(self):
        response.headerMap['status']=302
        response.headerMap['location']=request.base
        return "" # A view should always return a string
</pre></div>

<P>

<H2><A NAME="SECTION0016330000000000000000">
14.3.3 Aggiungere informazioni sul tempo di costruzione in ogni pagina</A>
</H2>
In questo esempio, aggiungeremo una linea alla fine di ogni pagina che &#232; generata dal server.
Questa linea conterr&#224; il tempo impiegato per costruire la pagina. Naturalmente, vogliamo questa linea
solo per le pagine HTML dinamiche.

<P>
Tutto quello che dobbiamo fare &#232; usare <var>initNonStaticRequest</var> per memorizzare la partenza, e <var>initNonStaticResponse</var>
per aggiungere la linea contenente il tempo impiegato per la costruzione.

<P>
Ecco il codice:
<div class="verbatim"><pre>
import time
def initNonStaticRequest():
    request.startTime=time.time()
def initNonStaticResponse():
    if response.headerMap['content-type']=='text/html':
        response.body+='&lt;br&gt;Time: %.04fs'%(time.time()-request.startTime)
CherryClass Root:
mask:
    def index(self):
        &lt;html&gt;&lt;body&gt;
            Hello, world
        &lt;/body&gt;&lt;/html&gt;
</pre></div>

<P>
Et voila

<P>

<H2><A NAME="SECTION0016340000000000000000">
14.3.4 Adattare i messaggi di errore</A>
</H2>
Questo pu&#242; essere fatto usando la funzione speciale <var>onError</var>.
Usate <var>response.headerMap</var> e <var>response.body</var> per fare quello che desiderate.

<P>
L'esempio che segue mostra come configurare il tutto per inviare una mail 
ogni volta che viene incontrato un errore:
<div class="verbatim"><pre>
use Mail

def onError():
    # Get the error in a string
    import traceback, StringIO
    bodyFile=StringIO.StringIO()
    traceback.print_exc(file=bodyFile)
    errorBody=bodyFile.getvalue()
    bodyFile.close()
    # Send an email with the error
    myMail.sendMail("erreur@site.com", "webmaster@site.com", "", "text/plain", "An error occured on your site", errorBody)
    # Set the body of the response
    response.body="&lt;html&gt;&lt;body&gt;&lt;br&gt;&lt;br&gt;&lt;center&gt;"
    response.body+="Sorry, an error occured&lt;br&gt;"
    response.body+="An email has been sent to the webmaster"
    response.body+="&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;"


CherryClass MyMail(Mail):
function:
    def __init__(self):
        self.smtpServer='smtp.site.com'

CherryClass Root:
mask:
    def index(self):
        &lt;html&gt;&lt;body&gt;
            &lt;a py-attr="request.base+'/generateError'" href=""&gt;
                    Click here to generate an error&lt;/a&gt;
        &lt;/body&gt;&lt;/html&gt;
    def generateError(self):
        &lt;html&gt;&lt;body&gt;
            You'll never see this: &lt;py-eval="1/0"&gt;
        &lt;/body&gt;&lt;/html&gt;
</pre></div>

<P>
Questo esempio mostra anche l'uso del modulo standard <var>Mail</var> compreso in CherryPy.

<P>

<DIV CLASS="navigation">
<p><hr>
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td><A HREF="node15.html"><img src="../icons/previous.gif"
  border="0" height="32"
  alt="Previous Page" width="32"></A></td>
<td><A HREF="tut.html"><img src="../icons/up.gif"
  border="0" height="32"
  alt="Up One Level" width="32"></A></td>
<td><A HREF="node17.html"><img src="../icons/next.gif"
  border="0" height="32"
  alt="Next Page" width="32"></A></td>
<td align="center" width="100%">CherryPy Tutorial</td>
<td><A HREF="node2.html"><img src="../icons/contents.gif"
  border="0" height="32"
  alt="Contents" width="32"></A></td>
<td><img src="../icons/blank.gif"
  border="0" height="32"
  alt="" width="32"></td>
<td><img src="../icons/blank.gif"
  border="0" height="32"
  alt="" width="32"></td>
</tr></table>
<b class="navlabel">Previous:</b> <a class="sectref" HREF="node15.html">13. Usare le proprie</A>
<b class="navlabel">Up:</b> <a class="sectref" HREF="tut.html">CherryPy Tutorial</A>
<b class="navlabel">Next:</b> <a class="sectref" HREF="node17.html">15. Approntare il vostro</A>
<hr>
<span class="release-info">Release 0.10-beta, documentation updated on 14. gennaio 2004.</span>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
See <i><a href="about.html">About this document...</a></i> for information on suggesting changes.
</ADDRESS>
</BODY>
</HTML>
