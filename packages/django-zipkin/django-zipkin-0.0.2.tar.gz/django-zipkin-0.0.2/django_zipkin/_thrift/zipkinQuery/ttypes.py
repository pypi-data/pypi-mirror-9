#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import zipkinCore.ttypes
import zipkinDependencies.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Order:
  TIMESTAMP_DESC = 0
  TIMESTAMP_ASC = 1
  DURATION_ASC = 2
  DURATION_DESC = 3
  NONE = 4

  _VALUES_TO_NAMES = {
    0: "TIMESTAMP_DESC",
    1: "TIMESTAMP_ASC",
    2: "DURATION_ASC",
    3: "DURATION_DESC",
    4: "NONE",
  }

  _NAMES_TO_VALUES = {
    "TIMESTAMP_DESC": 0,
    "TIMESTAMP_ASC": 1,
    "DURATION_ASC": 2,
    "DURATION_DESC": 3,
    "NONE": 4,
  }

class Adjust:
  """
  The raw data in our storage might have various problems. How should we adjust it before
  returning it to the user?

  Time skew adjuster tries to make sure that even though servers might have slightly
  different clocks the annotations in the returned data are adjusted so that they are
  in the correct order.
  """
  NOTHING = 0
  TIME_SKEW = 1

  _VALUES_TO_NAMES = {
    0: "NOTHING",
    1: "TIME_SKEW",
  }

  _NAMES_TO_VALUES = {
    "NOTHING": 0,
    "TIME_SKEW": 1,
  }


class Trace:
  """
  Attributes:
   - spans
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'spans', (TType.STRUCT,(zipkinCore.ttypes.Span, zipkinCore.ttypes.Span.thrift_spec)), None, ), # 1
  )

  def __init__(self, spans=None,):
    self.spans = spans

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.spans = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = zipkinCore.ttypes.Span()
            _elem5.read(iprot)
            self.spans.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Trace')
    if self.spans is not None:
      oprot.writeFieldBegin('spans', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.spans))
      for iter6 in self.spans:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryException(TException):
  """
  Attributes:
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'msg', None, None, ), # 1
  )

  def __init__(self, msg=None,):
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryException')
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TraceSummary:
  """
  This sums up a single Trace to make it easy for a client to get an overview of what happened.

  Attributes:
   - trace_id
   - start_timestamp
   - end_timestamp
   - duration_micro
   - service_counts
   - endpoints
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'trace_id', None, None, ), # 1
    (2, TType.I64, 'start_timestamp', None, None, ), # 2
    (3, TType.I64, 'end_timestamp', None, None, ), # 3
    (4, TType.I32, 'duration_micro', None, None, ), # 4
    (5, TType.MAP, 'service_counts', (TType.STRING,None,TType.I32,None), None, ), # 5
    (6, TType.LIST, 'endpoints', (TType.STRUCT,(zipkinCore.ttypes.Endpoint, zipkinCore.ttypes.Endpoint.thrift_spec)), None, ), # 6
  )

  def __init__(self, trace_id=None, start_timestamp=None, end_timestamp=None, duration_micro=None, service_counts=None, endpoints=None,):
    self.trace_id = trace_id
    self.start_timestamp = start_timestamp
    self.end_timestamp = end_timestamp
    self.duration_micro = duration_micro
    self.service_counts = service_counts
    self.endpoints = endpoints

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.trace_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start_timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.end_timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.duration_micro = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.service_counts = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin()
          for _i11 in xrange(_size7):
            _key12 = iprot.readString();
            _val13 = iprot.readI32();
            self.service_counts[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.endpoints = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = zipkinCore.ttypes.Endpoint()
            _elem19.read(iprot)
            self.endpoints.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TraceSummary')
    if self.trace_id is not None:
      oprot.writeFieldBegin('trace_id', TType.I64, 1)
      oprot.writeI64(self.trace_id)
      oprot.writeFieldEnd()
    if self.start_timestamp is not None:
      oprot.writeFieldBegin('start_timestamp', TType.I64, 2)
      oprot.writeI64(self.start_timestamp)
      oprot.writeFieldEnd()
    if self.end_timestamp is not None:
      oprot.writeFieldBegin('end_timestamp', TType.I64, 3)
      oprot.writeI64(self.end_timestamp)
      oprot.writeFieldEnd()
    if self.duration_micro is not None:
      oprot.writeFieldBegin('duration_micro', TType.I32, 4)
      oprot.writeI32(self.duration_micro)
      oprot.writeFieldEnd()
    if self.service_counts is not None:
      oprot.writeFieldBegin('service_counts', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.service_counts))
      for kiter20,viter21 in self.service_counts.items():
        oprot.writeString(kiter20)
        oprot.writeI32(viter21)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.endpoints is not None:
      oprot.writeFieldBegin('endpoints', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.endpoints))
      for iter22 in self.endpoints:
        iter22.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TimelineAnnotation:
  """
  A modified version of the Annotation struct that brings in more information

  Attributes:
   - timestamp
   - value
   - host
   - span_id
   - parent_id
   - service_name
   - span_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'timestamp', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
    (3, TType.STRUCT, 'host', (zipkinCore.ttypes.Endpoint, zipkinCore.ttypes.Endpoint.thrift_spec), None, ), # 3
    (4, TType.I64, 'span_id', None, None, ), # 4
    (5, TType.I64, 'parent_id', None, None, ), # 5
    (6, TType.STRING, 'service_name', None, None, ), # 6
    (7, TType.STRING, 'span_name', None, None, ), # 7
  )

  def __init__(self, timestamp=None, value=None, host=None, span_id=None, parent_id=None, service_name=None, span_name=None,):
    self.timestamp = timestamp
    self.value = value
    self.host = host
    self.span_id = span_id
    self.parent_id = parent_id
    self.service_name = service_name
    self.span_name = span_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.host = zipkinCore.ttypes.Endpoint()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.span_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.parent_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.service_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.span_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TimelineAnnotation')
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 1)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.host is not None:
      oprot.writeFieldBegin('host', TType.STRUCT, 3)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.span_id is not None:
      oprot.writeFieldBegin('span_id', TType.I64, 4)
      oprot.writeI64(self.span_id)
      oprot.writeFieldEnd()
    if self.parent_id is not None:
      oprot.writeFieldBegin('parent_id', TType.I64, 5)
      oprot.writeI64(self.parent_id)
      oprot.writeFieldEnd()
    if self.service_name is not None:
      oprot.writeFieldBegin('service_name', TType.STRING, 6)
      oprot.writeString(self.service_name)
      oprot.writeFieldEnd()
    if self.span_name is not None:
      oprot.writeFieldBegin('span_name', TType.STRING, 7)
      oprot.writeString(self.span_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TraceTimeline:
  """
  This sums up a single Trace to make it easy for a client to get an overview of what happened.

  Attributes:
   - trace_id
   - root_most_span_id
   - annotations
   - binary_annotations
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'trace_id', None, None, ), # 1
    (2, TType.I64, 'root_most_span_id', None, None, ), # 2
    None, # 3
    None, # 4
    None, # 5
    (6, TType.LIST, 'annotations', (TType.STRUCT,(TimelineAnnotation, TimelineAnnotation.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'binary_annotations', (TType.STRUCT,(zipkinCore.ttypes.BinaryAnnotation, zipkinCore.ttypes.BinaryAnnotation.thrift_spec)), None, ), # 7
  )

  def __init__(self, trace_id=None, root_most_span_id=None, annotations=None, binary_annotations=None,):
    self.trace_id = trace_id
    self.root_most_span_id = root_most_span_id
    self.annotations = annotations
    self.binary_annotations = binary_annotations

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.trace_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.root_most_span_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.annotations = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = TimelineAnnotation()
            _elem28.read(iprot)
            self.annotations.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.binary_annotations = []
          (_etype32, _size29) = iprot.readListBegin()
          for _i33 in xrange(_size29):
            _elem34 = zipkinCore.ttypes.BinaryAnnotation()
            _elem34.read(iprot)
            self.binary_annotations.append(_elem34)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TraceTimeline')
    if self.trace_id is not None:
      oprot.writeFieldBegin('trace_id', TType.I64, 1)
      oprot.writeI64(self.trace_id)
      oprot.writeFieldEnd()
    if self.root_most_span_id is not None:
      oprot.writeFieldBegin('root_most_span_id', TType.I64, 2)
      oprot.writeI64(self.root_most_span_id)
      oprot.writeFieldEnd()
    if self.annotations is not None:
      oprot.writeFieldBegin('annotations', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.annotations))
      for iter35 in self.annotations:
        iter35.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.binary_annotations is not None:
      oprot.writeFieldBegin('binary_annotations', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.binary_annotations))
      for iter36 in self.binary_annotations:
        iter36.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TraceCombo:
  """
  Returns a combination of trace, summary and timeline.

  Attributes:
   - trace
   - summary
   - timeline
   - span_depths
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'trace', (Trace, Trace.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'summary', (TraceSummary, TraceSummary.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'timeline', (TraceTimeline, TraceTimeline.thrift_spec), None, ), # 3
    (4, TType.MAP, 'span_depths', (TType.I64,None,TType.I32,None), None, ), # 4
  )

  def __init__(self, trace=None, summary=None, timeline=None, span_depths=None,):
    self.trace = trace
    self.summary = summary
    self.timeline = timeline
    self.span_depths = span_depths

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.trace = Trace()
          self.trace.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.summary = TraceSummary()
          self.summary.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.timeline = TraceTimeline()
          self.timeline.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.span_depths = {}
          (_ktype38, _vtype39, _size37 ) = iprot.readMapBegin()
          for _i41 in xrange(_size37):
            _key42 = iprot.readI64();
            _val43 = iprot.readI32();
            self.span_depths[_key42] = _val43
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TraceCombo')
    if self.trace is not None:
      oprot.writeFieldBegin('trace', TType.STRUCT, 1)
      self.trace.write(oprot)
      oprot.writeFieldEnd()
    if self.summary is not None:
      oprot.writeFieldBegin('summary', TType.STRUCT, 2)
      self.summary.write(oprot)
      oprot.writeFieldEnd()
    if self.timeline is not None:
      oprot.writeFieldBegin('timeline', TType.STRUCT, 3)
      self.timeline.write(oprot)
      oprot.writeFieldEnd()
    if self.span_depths is not None:
      oprot.writeFieldBegin('span_depths', TType.MAP, 4)
      oprot.writeMapBegin(TType.I64, TType.I32, len(self.span_depths))
      for kiter44,viter45 in self.span_depths.items():
        oprot.writeI64(kiter44)
        oprot.writeI32(viter45)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryRequest:
  """
  Attributes:
   - service_name
   - span_name
   - annotations
   - binary_annotations
   - end_ts
   - limit
   - order
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'service_name', None, None, ), # 1
    (2, TType.STRING, 'span_name', None, None, ), # 2
    (3, TType.LIST, 'annotations', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'binary_annotations', (TType.STRUCT,(zipkinCore.ttypes.BinaryAnnotation, zipkinCore.ttypes.BinaryAnnotation.thrift_spec)), None, ), # 4
    (5, TType.I64, 'end_ts', None, None, ), # 5
    (6, TType.I32, 'limit', None, None, ), # 6
    (7, TType.I32, 'order', None, None, ), # 7
  )

  def __init__(self, service_name=None, span_name=None, annotations=None, binary_annotations=None, end_ts=None, limit=None, order=None,):
    self.service_name = service_name
    self.span_name = span_name
    self.annotations = annotations
    self.binary_annotations = binary_annotations
    self.end_ts = end_ts
    self.limit = limit
    self.order = order

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.service_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.span_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.annotations = []
          (_etype49, _size46) = iprot.readListBegin()
          for _i50 in xrange(_size46):
            _elem51 = iprot.readString();
            self.annotations.append(_elem51)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.binary_annotations = []
          (_etype55, _size52) = iprot.readListBegin()
          for _i56 in xrange(_size52):
            _elem57 = zipkinCore.ttypes.BinaryAnnotation()
            _elem57.read(iprot)
            self.binary_annotations.append(_elem57)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.end_ts = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.order = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryRequest')
    if self.service_name is not None:
      oprot.writeFieldBegin('service_name', TType.STRING, 1)
      oprot.writeString(self.service_name)
      oprot.writeFieldEnd()
    if self.span_name is not None:
      oprot.writeFieldBegin('span_name', TType.STRING, 2)
      oprot.writeString(self.span_name)
      oprot.writeFieldEnd()
    if self.annotations is not None:
      oprot.writeFieldBegin('annotations', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.annotations))
      for iter58 in self.annotations:
        oprot.writeString(iter58)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.binary_annotations is not None:
      oprot.writeFieldBegin('binary_annotations', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.binary_annotations))
      for iter59 in self.binary_annotations:
        iter59.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.end_ts is not None:
      oprot.writeFieldBegin('end_ts', TType.I64, 5)
      oprot.writeI64(self.end_ts)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 6)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.order is not None:
      oprot.writeFieldBegin('order', TType.I32, 7)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryResponse:
  """
  Attributes:
   - trace_ids
   - start_ts
   - end_ts
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'trace_ids', (TType.I64,None), None, ), # 1
    (2, TType.I64, 'start_ts', None, None, ), # 2
    (3, TType.I64, 'end_ts', None, None, ), # 3
  )

  def __init__(self, trace_ids=None, start_ts=None, end_ts=None,):
    self.trace_ids = trace_ids
    self.start_ts = start_ts
    self.end_ts = end_ts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.trace_ids = []
          (_etype63, _size60) = iprot.readListBegin()
          for _i64 in xrange(_size60):
            _elem65 = iprot.readI64();
            self.trace_ids.append(_elem65)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start_ts = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.end_ts = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryResponse')
    if self.trace_ids is not None:
      oprot.writeFieldBegin('trace_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.trace_ids))
      for iter66 in self.trace_ids:
        oprot.writeI64(iter66)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.start_ts is not None:
      oprot.writeFieldBegin('start_ts', TType.I64, 2)
      oprot.writeI64(self.start_ts)
      oprot.writeFieldEnd()
    if self.end_ts is not None:
      oprot.writeFieldBegin('end_ts', TType.I64, 3)
      oprot.writeI64(self.end_ts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
