

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Keres Documentation &mdash; keres 0.8.4 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.8.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="keres 0.8.4 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="#">keres 0.8.4 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="keres-documentation">
<h1>Keres Documentation<a class="headerlink" href="#keres-documentation" title="Permalink to this headline">¶</a></h1>
<p><em>Keres</em> is the testing suite for a Bayes filter useful for
amyloid fibrillogenesis fluorimetry data.</p>
<p>The keres homepage is at &lt;<a class="reference external" href="https://pypi.python.org/pypi/keres/">https://pypi.python.org/pypi/keres/</a>&gt; and
the most complete documentation is available at
&lt;<a class="reference external" href="http://pythonhosted.org/keres/">http://pythonhosted.org/keres/</a>&gt;.</p>
</div>
<div class="section" id="fibrillogenesis">
<h1>Fibrillogenesis<a class="headerlink" href="#fibrillogenesis" title="Permalink to this headline">¶</a></h1>
<p>Fibrillogenesis is the process of fiber formation by
amyloid forming proteins, such as the Alzeimer&#8217;s protein
A-beta. At the beginning of a fibrillogensis experiment, the total
protein exists in a fiber-free form. After some time, the
protein starts to form fibers in a rapidly accelerating
reaction that eventually converts all of the protein to fibers.</p>
<p>The moment at which the first fiber appears is the point of
transition from the &#8220;lag phase&#8221; of no fibers to the &#8220;signal
phase&#8221; where fibers are present. The &#8220;signal phase&#8221; gets its
name from the fact that the fibers produce signal
measureable by a detector. The time from the start of the
experiment to the point of transition to the signal phase
is called the &#8220;lag time&#8221;.</p>
<div class="align-center figure">
<img alt="Picture of fluorometric fibirllogenesis data." src="_images/fibrillogenesis.png" />
<p class="caption">Schematized representation of fluorometric fibrillogenesis data.</p>
</div>
<p>Data is generally noisy, although this latter figure represents
data as a smooth curve. The detector measures
the light emitted from dyes that fluoresce when bound to
amyloid fibers and irradiated at specific wavelengths. Thus, the
continuous curve represents a series of many individual
datapoints taken closely together.</p>
<p>Several problems with data, such as noisiness, incompleteness,
or baseline drift make it difficult to measure the lag time with
certainty. One way to address these challenges is to embrace
this uncertainty and convert the series of intensities to a
series of probabilities using a Bayes filter.</p>
</div>
<div class="section" id="the-bayes-filter">
<h1>The Bayes Filter<a class="headerlink" href="#the-bayes-filter" title="Permalink to this headline">¶</a></h1>
<p>The Bayes filter is an application of recursive
Bayesian estimation, a full description of which will be
published soon. But briefly, the principle of recursive
Bayesian estimation is to update a
posterior probability <span class="math">\(p_i(H|E)\)</span>, where <span class="math">\(i\)</span>
indexes the data point in a series. The probability
<span class="math">\(p_i(H|E)\)</span> describes how likely it is that the
experiment is still in the lag phase of fibrillogenesis.</p>
<p>If the point <span class="math">\(i+1\)</span> has higher signal than point <span class="math">\(i\)</span>, then
<span class="math">\(p_i(H|E)\)</span> gets lower (i.e. less likelihood that
the experiment is still in the lag phase). Conversely, if
the point <span class="math">\(i+1\)</span> has lower signal than point <span class="math">\(i\)</span>,
then <span class="math">\(p_i(H|E)\)</span> gets higher.</p>
<p>For each round, the estimator is updated according to Bayes&#8217;s
equation:</p>
<div class="math" id="equation-Bayes">
<span class="eqno">(1)</span>\[p_i(H|E) = \dfrac{p_i(E|H) \cdot p_i(H)}{p_i(E)}\]</div>
<p>The value <span class="math">\(p_i(H)\)</span> is the equal to <span class="math">\(p_{i-1}(H|E)\)</span>. The value
<span class="math">\(p_i(E|H)\)</span> is the probability to see a point with intensity <span class="math">\(I_i\)</span>
given that the experiment is in the lag phase. <span class="math">\(p_i(E|H)\)</span> assumes
a normal distribution of intensities around the mean intensity of the
presumed lag phase (basically a reasonable window of data points
prior to point <span class="math">\(i\)</span>).</p>
<p>The value <span class="math">\(p_i(E)\)</span> is the probability of seeing the intensity <span class="math">\(I_i\)</span>
in a reasonable window of points around point <span class="math">\(i\)</span>.</p>
<p>Once the probability <span class="math">\(p_i(H|E)\)</span> falls below a hard cutoff (<span class="math">\(10^{-10}\)</span>),
the experiment is confidently in the signal phase.</p>
<p>To find the exact transition from the lag
to signal phases, it is useful to &#8220;backtrack&#8221;
to a higher probability (<span class="math">\(10^{-4}\)</span>) and then apply an
empircal correction optimized from simulation data
with Gaussian noise:</p>
<div class="math" id="equation-Pareto">
<span class="eqno">(2)</span>\[C = \dfrac{\alpha \cdot m^{\alpha}}
          {\left ( \dfrac {\nu_h}{\sigma_h} \right )^{1 + \alpha}} + k\]</div>
<p>Here, <span class="math">\(\nu_h\)</span> is the average intensity around the hard cutoff point <span class="math">\(h\)</span>,
<span class="math">\(\sigma_h\)</span> is the square root of the variance of the lag phase for
data point <span class="math">\(h\)</span>. The rest of the values are empirical: <span class="math">\(k = 7\)</span>,
<span class="math">\(m = 362\)</span>, <span class="math">\(\alpha = 0.9\)</span>. Although this correction works well
for both simulated and experimental data, we don&#8217;t have a rigorous theoretical
rationale for its efficacy. In other words, this correction is entirely empirical.</p>
</div>
<div class="section" id="using-the-bayes-filter-directly">
<h1>Using the Bayes Filter Directly<a class="headerlink" href="#using-the-bayes-filter-directly" title="Permalink to this headline">¶</a></h1>
<p>Data can be passed to the default Bayes filter by calling the <tt class="docutils literal"><span class="pre">bayesian_pickup()</span></tt>
function (&#8220;pickup&#8221; refers to when the signal &#8220;picks up&#8221;):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">keres</span> <span class="kn">import</span> <span class="n">bayesian_pickup</span>

<span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">history</span><span class="p">,</span> <span class="n">signoise</span> <span class="o">=</span> <span class="n">bayesian_pickup</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">data</span></tt> is a <span class="math">\(2 \times N\)</span> array, where the first element is a vector
of times (<span class="math">\(t_0, t_1, t_2 ... N\)</span>) and the second element is a vector
of intensities (<span class="math">\(I_0, I_1, I_2 ... N\)</span>).</p>
<div class="section" id="return-values">
<h2>Return Values<a class="headerlink" href="#return-values" title="Permalink to this headline">¶</a></h2>
<p>The return value of <tt class="docutils literal"><span class="pre">bayesian_pickup()</span></tt> is a tuple of three elements,
the first of which is a 2-tuple of the <tt class="docutils literal"><span class="pre">time</span></tt> at the end of the lag phase
(&#8220;pickup&#8221;) and the intensity (<tt class="docutils literal"><span class="pre">value</span></tt>) at the pickup.</p>
<p>The second element, <tt class="docutils literal"><span class="pre">history</span></tt>, is a list of 2-tuples, each having a first
element of the data point number <span class="math">\(i\)</span> and a second element of the
<span class="math">\(\log_{10} p_i(H|E)\)</span>:</p>
<div class="math" id="equation-history">
<span class="eqno">(3)</span>\[\left [ \left (i-K, \log_{10} \{ p_{i-K}(H|E) \} \right ),
        \left (i-K+1, \log_{10} \{ p_{i-K+1}(H|E) \} \right ) ...
        \left (i, \log_{10} \{ p_i(H|E) \} \right ) \right ]\]</div>
<p>Here, <span class="math">\(K\)</span> is the number of data points in the lag phase.</p>
<p>The third element, <tt class="docutils literal"><span class="pre">signoise</span></tt>, is the ratio of the interpolated
value (<span class="math">\(I_H\)</span>) at the time <span class="math">\(t_H\)</span> where <span class="math">\(p(H|E) = 10^{-10}\)</span> to
the standard deviation (<span class="math">\(\sigma_{j&lt;i}\)</span>) of the values <span class="math">\(j&lt;i\)</span> in the
lag phase (all intensity values <span class="math">\(I_j\)</span> prior to point <span class="math">\(i\)</span>):</p>
<div class="math" id="equation-signoise">
<span class="eqno">(4)</span>\[\begin{split}\text{signoise} = \dfrac{I_H}{\sigma_{j&lt;i}}\end{split}\]</div>
</div>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>As an example, let&#8217;s first simulate some data, using noise
from a normal distribution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">arange</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">vectorize</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">random</span> <span class="k">as</span> <span class="n">rnd</span>

<span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">lag</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">scale</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">normal</span>  <span class="c"># others could be rnd.exponential, rnd.poisson</span>

<span class="n">curve</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="o">-</span><span class="n">scale</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">lag</span> <span class="o">*</span> <span class="nb">max</span><span class="p">((</span><span class="n">i</span> <span class="o">-</span> <span class="n">lag</span><span class="p">)</span> <span class="o">/</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">curve</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">Y</span><span class="p">)])</span>
</pre></div>
</div>
<p>To take a look at the data, we&#8217;ll plot it with <a class="reference external" href="https://pypi.python.org/pypi/pygmyplot">pygmyplot</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pygmyplot</span> <span class="kn">import</span> <span class="n">xy_plot</span>

<span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="n">margins</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;bottom&quot;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s">&quot;left&quot;</span><span class="p">:</span> <span class="mf">0.15</span><span class="p">,</span> <span class="s">&quot;right&quot;</span><span class="p">:</span> <span class="mf">0.9</span><span class="p">}</span>

<span class="n">norm_plot</span> <span class="o">=</span> <span class="n">xy_plot</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
<span class="n">norm_plot</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&quot;time&quot;</span><span class="p">)</span>
<span class="n">norm_plot</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&quot;fluorescence intensity&quot;</span><span class="p">)</span>
<span class="n">norm_plot</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="o">**</span><span class="n">margins</span><span class="p">)</span>
<span class="n">norm_plot</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>
</pre></div>
</div>
<div class="align-center figure">
<img alt="Plot of Simulated Data with Gaussian Noise" src="_images/norm-plot.png" />
<p class="caption">Simulated fibrillogenic data with normally distributed noise.</p>
</div>
<p>That data is plenty noisy. Let&#8217;s see how the Bayes filter,
<tt class="docutils literal"><span class="pre">bayesian_pickup()</span></tt>, handles it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">keres</span> <span class="kn">import</span> <span class="n">bayesian_pickup</span>
<span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">history</span><span class="p">,</span> <span class="n">signoise</span> <span class="o">=</span> <span class="n">bayesian_pickup</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;time: </span><span class="si">%s</span><span class="s">,  value: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>For this random data, the latter command reports
&#8220;<tt class="docutils literal"><span class="pre">time:</span> <span class="pre">215.0,</span>&nbsp; <span class="pre">value:</span> <span class="pre">3.11276048316</span></tt>&#8221;,
meaning that filter decided that the lag time is 215.0 s. Let&#8217;s take a look
at a zoom of the area:</p>
<div class="align-center figure">
<img alt="Zoom of Simulated Data with Vertical Line at t=215" src="_images/norm-plot-zin-anno.png" />
<p class="caption">Zoom of simulated data with a vertical line at the measured lag time (t=215).</p>
</div>
<p>Clearly, <tt class="docutils literal"><span class="pre">bayesian_pickup()</span></tt> got very close to what a human might decide for
this particular random data. Note that the actual lag time of the simulation
is 200 s, defined by the line <tt class="docutils literal"><span class="pre">lag</span> <span class="pre">=</span> <span class="pre">200</span></tt>.</p>
<p>This decision includes the correction described in Equation <a href="#equation-Pareto">(2)</a>, but
it is possible to see how the filter decided that the data had
entered the signal phase by plotting the <tt class="docutils literal"><span class="pre">history</span></tt> element
returned by <tt class="docutils literal"><span class="pre">bayesian_pickup()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">history_plot</span> <span class="o">=</span> <span class="n">xy_plot</span><span class="p">(</span><span class="o">*</span><span class="n">array</span><span class="p">(</span><span class="n">history</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
                                          <span class="n">sibling</span><span class="o">=</span><span class="n">norm_plot</span><span class="p">)</span>
<span class="n">history_plot</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&quot;time&quot;</span><span class="p">)</span>
<span class="n">history_plot</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&quot;$\log_{10}\{p_i(H|E)\}$ | Intensity&quot;</span><span class="p">)</span>
<span class="n">history_plot</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">history_plot</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>
</pre></div>
</div>
<div class="align-center figure">
<img alt="Plot of Bayes Filter History with Simulated Data" src="_images/history-plot.png" />
<p class="caption">Bayes filter history (green) with simulated data (blue).</p>
</div>
<p>Here, the data (&#8220;Intensity&#8221;) and history (<span class="math">\(\log_{10}\{p_i(H|E)\}\)</span>)
curves are stacked. Y-lables for both are on the left hand side of the plot.</p>
<p>Following is a zoom of the history and data.</p>
<div class="align-center figure">
<img alt="Zoom of Bayes Filter History with Simulated Data" src="_images/history-plot-zin-anno.png" />
<p class="caption">Zoom of Bayes filter history (green) with simulated data (blue).</p>
</div>
<p>The dashed lines in this figure show the &#8220;backtrack&#8221; point where
<span class="math">\(p(H|E) = 10^{-4}\)</span>. Although it seems like the Bayes filter has
picked a point too far into the signal phase, in actuality, the
Bayes filter found the first point that peeks just above the noise.
The following figure, which includes no points past 238 s, makes this fact clear:</p>
<div class="align-center figure">
<img alt="Plot of Bayes Filter History with Simulated Data (t &lt; 238 s)." src="_images/history-plot-trunc.png" />
<p class="caption">Bayes filter history (green) with simulated data (blue) for all
times less than 238 s.</p>
</div>
</div>
</div>
<div class="section" id="using-the-test-suite">
<h1>Using the Test Suite<a class="headerlink" href="#using-the-test-suite" title="Permalink to this headline">¶</a></h1>
<p><em>Keres</em> includes a testing suite accessible through the program <tt class="docutils literal"><span class="pre">bayestest</span></tt>,
which is controlled by a configuration (&#8220;config&#8221;) file:</p>
<div class="highlight-python"><pre>bayestest configfile</pre>
</div>
<p>The config file has a number of settings, an example of which is in the
<tt class="docutils literal"><span class="pre">examples</span></tt> folder of the source distribution. The example config file,
<tt class="docutils literal"><span class="pre">settings.cfg</span></tt>, documents the settings as comments. Given a complete
source distribution, it is possible to run bayestest without installing
by issuing the following command from within the <tt class="docutils literal"><span class="pre">examples</span></tt> folder:</p>
<div class="highlight-python"><pre>./test-bayes settings.cfg</pre>
</div>
<p>Running <tt class="docutils literal"><span class="pre">bayestest</span></tt> as above will invoke the simulator to produce
a specified number (<tt class="docutils literal"><span class="pre">plot_n</span></tt>) of plots that show individual simulations
(not all simulations are necessarily plotted). The top panel of which
will show the simulated noisy data in blue and the &#8220;noiseless&#8221; data
superposed in green. The bottom pannel shows the history of the
probability <span class="math">\(p(H|E)\)</span>:</p>
<div class="align-center figure">
<img alt="Picture of a plot from the bayestest program" src="_images/bayestest-plot.png" />
<p class="caption">Plot of simulated data (top) and history of <span class="math">\(p(H|E)\)</span>.</p>
</div>
<p>During the simulation, a report window is updated with information about
the simulations and the performance of the various methods to measure
lag time:</p>
<div class="highlight-python"><pre>=======================================================
 Noise: 0.1
=======================================================
   real tenth  half bayes  diff
=======================================================
    234     0   259   231    -3
    291     0   313   285    -6
    252     0   274   247    -4
    420     0   438   412    -8
    367     0   390   360    -7
=======================================================
    312     0   335   307    -5

=======================================================
   Scaling N: 5,  Stocastic n: 2
   Length: 500,  Noise: 0.1
=======================================================
         10%|         50%|    Bayesian
=======================================================
  0.00164648|  0.88912049|  0.90321512 | KS p(Exponential)
107929.561885|   53.923670|   46.500000 | Variance
=======================================================</pre>
</div>
<p>In this report, &#8220;Noise:&#8221; indicates the noise level as a fraction
of the maximum signal for the noiseless data. The following
table indicates the lag time for noiseless data (&#8220;real&#8221;),
and the lag time found for each of the tenth-time, half-time,
and Bayesian methods. The difference between the lag time as
measured by the Bayesian method and the &#8216;real&#8221; time is given
as &#8220;diff&#8221;. Means for each value are given in the bottom row of the table.</p>
<p>The second table reports number of different simultions ran
for the noise level (in the above table, the number of simulations is
<span class="math">\(10 = \mbox{Scaling N} \times \mbox{Stochastic n}\)</span>. The
length of the data series (minus a randomly produced extension of the
lag time) is given, along with the noise level as decribed above.</p>
<p>This table reports the p-value given by the K-S test for an
exponential distribution on the lag time distributions,
as measured by the three methods.
For example, the p-value for the distribution of lag times
measured by the Bayesian method is 0.903. The bottom
row of this table reports the mean squared difference (MSD)
of these distributions relative to the &#8220;real&#8221; lag time (<span class="math">\(t_r\)</span>)
of the simulation:</p>
<div class="math" id="equation-MSD">
<span class="eqno">(5)</span>\[\mbox{MSD} = \dfrac{\displaystyle \sum_{i}^{N} (t_r - t_i)^2}{N}\]</div>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Keres Documentation</a></li>
<li><a class="reference internal" href="#fibrillogenesis">Fibrillogenesis</a></li>
<li><a class="reference internal" href="#the-bayes-filter">The Bayes Filter</a></li>
<li><a class="reference internal" href="#using-the-bayes-filter-directly">Using the Bayes Filter Directly</a><ul>
<li><a class="reference internal" href="#return-values">Return Values</a></li>
<li><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-the-test-suite">Using the Test Suite</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="#">keres 0.8.4 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright Copyright (c) 2014, James C. Stroud; All rights reserved..
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre.
    </div>
  </body>
</html>