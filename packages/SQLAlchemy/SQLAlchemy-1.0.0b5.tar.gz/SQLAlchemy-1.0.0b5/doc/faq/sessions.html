<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    Sessions / Queries
 &mdash;
    SQLAlchemy 1.0 Documentation

        </title>

        
            <!-- begin iterate through SQLA + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
            <!-- end iterate through SQLA + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.0 Documentation" href="../index.html" />
        <link rel="up" title="Frequently Asked Questions" href="index.html" />
        <link rel="next" title="Changes and Migration" href="../changelog/index.html" />
        <link rel="prev" title="Performance" href="performance.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.0.0b5</span> | Release Date: April 3, 2015
    </div>

    <h1>SQLAlchemy 1.0 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.0 Documentation</a></h3>

            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <input type="text" name="q" size="12" /> <input type="submit" value="Search" />
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        
        <h3>
            <a href="index.html" title="Frequently Asked Questions">Frequently Asked Questions</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="connections.html">Connections / Engines</a></span></li>
<li><span class="link-container first"><a class="reference external" href="metadata_schema.html">MetaData / Schema</a></span></li>
<li><span class="link-container first"><a class="reference external" href="sqlexpressions.html">SQL Expressions</a></span></li>
<li><span class="link-container first"><a class="reference external" href="ormconfiguration.html">ORM Configuration</a></span></li>
<li><span class="link-container first"><a class="reference external" href="performance.html">Performance</a></span></li>
<li class="selected"><span class="link-container first"><strong>Sessions / Queries</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#this-session-s-transaction-has-been-rolled-back-due-to-a-previous-exception-during-flush-or-similar">&#8220;This Session&#8217;s transaction has been rolled back due to a previous exception during flush.&#8221; (or similar)</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#but-why-does-flush-insist-on-issuing-a-rollback">But why does flush() insist on issuing a ROLLBACK?</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#but-why-isn-t-the-one-automatic-call-to-rollback-enough-why-must-i-rollback-again">But why isn&#8217;t the one automatic call to ROLLBACK enough?  Why must I ROLLBACK again?</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#how-do-i-make-a-query-that-always-adds-a-certain-filter-to-every-query">How do I make a Query that always adds a certain filter to every query?</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#i-ve-created-a-mapping-against-an-outer-join-and-while-the-query-returns-rows-no-objects-are-returned-why-not">I&#8217;ve created a mapping against an Outer Join, and while the query returns rows, no objects are returned.  Why not?</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#i-m-using-joinedload-or-lazy-false-to-create-a-join-outer-join-and-sqlalchemy-is-not-constructing-the-correct-query-when-i-try-to-add-a-where-order-by-limit-etc-which-relies-upon-the-outer-join">I&#8217;m using <tt class="docutils literal"><span class="pre">joinedload()</span></tt> or <tt class="docutils literal"><span class="pre">lazy=False</span></tt> to create a JOIN/OUTER JOIN and SQLAlchemy is not constructing the correct query when I try to add a WHERE, ORDER BY, LIMIT, etc. (which relies upon the (OUTER) JOIN)</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#query-has-no-len-why-not">Query has no <tt class="docutils literal"><span class="pre">__len__()</span></tt>, why not?</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#how-do-i-use-textual-sql-with-orm-queries">How Do I use Textual SQL with ORM Queries?</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#i-m-calling-session-delete-myobject-and-it-isn-t-removed-from-the-parent-collection">I&#8217;m calling <tt class="docutils literal"><span class="pre">Session.delete(myobject)</span></tt> and it isn&#8217;t removed from the parent collection!</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#why-isn-t-my-init-called-when-i-load-objects">why isn&#8217;t my <tt class="docutils literal"><span class="pre">__init__()</span></tt> called when I load objects?</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#how-do-i-use-on-delete-cascade-with-sa-s-orm">how do I use ON DELETE CASCADE with SA&#8217;s ORM?</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#i-set-the-foo-id-attribute-on-my-instance-to-7-but-the-foo-attribute-is-still-none-shouldn-t-it-have-loaded-foo-with-id-7">I set the &#8220;foo_id&#8221; attribute on my instance to &#8220;7&#8221;, but the &#8220;foo&#8221; attribute is still <tt class="docutils literal"><span class="pre">None</span></tt> - shouldn&#8217;t it have loaded Foo with id #7?</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#is-there-a-way-to-automagically-have-only-unique-keywords-or-other-kinds-of-objects-without-doing-a-query-for-the-keyword-and-getting-a-reference-to-the-row-containing-that-keyword">Is there a way to automagically have only unique keywords (or other kinds of objects) without doing a query for the keyword and getting a reference to the row containing that keyword?</a></span></li>
</ul>
</li>
</ul>



        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="sessions-queries">
<h1>Sessions / Queries<a class="headerlink" href="#sessions-queries" title="Permalink to this headline">¶</a></h1>
<div class="contents faq local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#this-session-s-transaction-has-been-rolled-back-due-to-a-previous-exception-during-flush-or-similar" id="id1">&#8220;This Session&#8217;s transaction has been rolled back due to a previous exception during flush.&#8221; (or similar)</a><ul>
<li><a class="reference internal" href="#but-why-does-flush-insist-on-issuing-a-rollback" id="id2">But why does flush() insist on issuing a ROLLBACK?</a></li>
<li><a class="reference internal" href="#but-why-isn-t-the-one-automatic-call-to-rollback-enough-why-must-i-rollback-again" id="id3">But why isn&#8217;t the one automatic call to ROLLBACK enough?  Why must I ROLLBACK again?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-do-i-make-a-query-that-always-adds-a-certain-filter-to-every-query" id="id4">How do I make a Query that always adds a certain filter to every query?</a></li>
<li><a class="reference internal" href="#i-ve-created-a-mapping-against-an-outer-join-and-while-the-query-returns-rows-no-objects-are-returned-why-not" id="id5">I&#8217;ve created a mapping against an Outer Join, and while the query returns rows, no objects are returned.  Why not?</a></li>
<li><a class="reference internal" href="#i-m-using-joinedload-or-lazy-false-to-create-a-join-outer-join-and-sqlalchemy-is-not-constructing-the-correct-query-when-i-try-to-add-a-where-order-by-limit-etc-which-relies-upon-the-outer-join" id="id6">I&#8217;m using <tt class="docutils literal"><span class="pre">joinedload()</span></tt> or <tt class="docutils literal"><span class="pre">lazy=False</span></tt> to create a JOIN/OUTER JOIN and SQLAlchemy is not constructing the correct query when I try to add a WHERE, ORDER BY, LIMIT, etc. (which relies upon the (OUTER) JOIN)</a></li>
<li><a class="reference internal" href="#query-has-no-len-why-not" id="id7">Query has no <tt class="docutils literal"><span class="pre">__len__()</span></tt>, why not?</a></li>
<li><a class="reference internal" href="#how-do-i-use-textual-sql-with-orm-queries" id="id8">How Do I use Textual SQL with ORM Queries?</a></li>
<li><a class="reference internal" href="#i-m-calling-session-delete-myobject-and-it-isn-t-removed-from-the-parent-collection" id="id9">I&#8217;m calling <tt class="docutils literal"><span class="pre">Session.delete(myobject)</span></tt> and it isn&#8217;t removed from the parent collection!</a></li>
<li><a class="reference internal" href="#why-isn-t-my-init-called-when-i-load-objects" id="id10">why isn&#8217;t my <tt class="docutils literal"><span class="pre">__init__()</span></tt> called when I load objects?</a></li>
<li><a class="reference internal" href="#how-do-i-use-on-delete-cascade-with-sa-s-orm" id="id11">how do I use ON DELETE CASCADE with SA&#8217;s ORM?</a></li>
<li><a class="reference internal" href="#i-set-the-foo-id-attribute-on-my-instance-to-7-but-the-foo-attribute-is-still-none-shouldn-t-it-have-loaded-foo-with-id-7" id="id12">I set the &#8220;foo_id&#8221; attribute on my instance to &#8220;7&#8221;, but the &#8220;foo&#8221; attribute is still <tt class="docutils literal"><span class="pre">None</span></tt> - shouldn&#8217;t it have loaded Foo with id #7?</a></li>
<li><a class="reference internal" href="#is-there-a-way-to-automagically-have-only-unique-keywords-or-other-kinds-of-objects-without-doing-a-query-for-the-keyword-and-getting-a-reference-to-the-row-containing-that-keyword" id="id13">Is there a way to automagically have only unique keywords (or other kinds of objects) without doing a query for the keyword and getting a reference to the row containing that keyword?</a></li>
</ul>
</div>
<div class="section" id="this-session-s-transaction-has-been-rolled-back-due-to-a-previous-exception-during-flush-or-similar">
<h2>&#8220;This Session&#8217;s transaction has been rolled back due to a previous exception during flush.&#8221; (or similar)<a class="headerlink" href="#this-session-s-transaction-has-been-rolled-back-due-to-a-previous-exception-during-flush-or-similar" title="Permalink to this headline">¶</a></h2>
<p>This is an error that occurs when a <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session.flush" title="sqlalchemy.orm.session.Session.flush"><tt class="xref py py-meth docutils literal"><span class="pre">Session.flush()</span></tt></a> raises an exception, rolls back
the transaction, but further commands upon the <cite>Session</cite> are called without an
explicit call to <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session.rollback" title="sqlalchemy.orm.session.Session.rollback"><tt class="xref py py-meth docutils literal"><span class="pre">Session.rollback()</span></tt></a> or <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session.close" title="sqlalchemy.orm.session.Session.close"><tt class="xref py py-meth docutils literal"><span class="pre">Session.close()</span></tt></a>.</p>
<p>It usually corresponds to an application that catches an exception
upon <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session.flush" title="sqlalchemy.orm.session.Session.flush"><tt class="xref py py-meth docutils literal"><span class="pre">Session.flush()</span></tt></a> or <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session.commit" title="sqlalchemy.orm.session.Session.commit"><tt class="xref py py-meth docutils literal"><span class="pre">Session.commit()</span></tt></a> and
does not properly handle the exception.    For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">sessionmaker</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">declarative_base</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">(</span><span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;sqlite://&#39;</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s">&#39;foo&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">()</span>

<span class="n">session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">()()</span>

<span class="c"># constraint violation</span>
<span class="n">session</span><span class="o">.</span><span class="n">add_all</span><span class="p">([</span><span class="n">Foo</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">Foo</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)])</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="k">except</span><span class="p">:</span>
    <span class="c"># ignore error</span>
    <span class="k">pass</span>

<span class="c"># continue using session without rolling back</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p>The usage of the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><tt class="xref py py-class docutils literal"><span class="pre">Session</span></tt></a> should fit within a structure similar to this:</p>
<div class="highlight-python"><div class="highlight"><pre>try:
    &lt;use session&gt;
    session.commit()
except:
   session.rollback()
   raise
finally:
   session.close()  # optional, depends on use case</pre></div>
</div>
<p>Many things can cause a failure within the try/except besides flushes. You
should always have some kind of &#8220;framing&#8221; of your session operations so that
connection and transaction resources have a definitive boundary, otherwise
your application doesn&#8217;t really have its usage of resources under control.
This is not to say that you need to put try/except blocks all throughout your
application - on the contrary, this would be a terrible idea.  You should
architect your application such that there is one (or few) point(s) of
&#8220;framing&#8221; around session operations.</p>
<p>For a detailed discussion on how to organize usage of the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><tt class="xref py py-class docutils literal"><span class="pre">Session</span></tt></a>,
please see <a class="reference internal" href="../orm/session_basics.html#session-faq-whentocreate"><em>When do I construct a Session, when do I commit it, and when do I close it?</em></a>.</p>
<div class="section" id="but-why-does-flush-insist-on-issuing-a-rollback">
<h3>But why does flush() insist on issuing a ROLLBACK?<a class="headerlink" href="#but-why-does-flush-insist-on-issuing-a-rollback" title="Permalink to this headline">¶</a></h3>
<p>It would be great if <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session.flush" title="sqlalchemy.orm.session.Session.flush"><tt class="xref py py-meth docutils literal"><span class="pre">Session.flush()</span></tt></a> could partially complete and then not roll
back, however this is beyond its current capabilities since its internal
bookkeeping would have to be modified such that it can be halted at any time
and be exactly consistent with what&#8217;s been flushed to the database. While this
is theoretically possible, the usefulness of the enhancement is greatly
decreased by the fact that many database operations require a ROLLBACK in any
case. Postgres in particular has operations which, once failed, the
transaction is not allowed to continue:</p>
<div class="highlight-python"><div class="highlight"><pre>test=&gt; create table foo(id integer primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index &quot;foo_pkey&quot; for table &quot;foo&quot;
CREATE TABLE
test=&gt; begin;
BEGIN
test=&gt; insert into foo values(1);
INSERT 0 1
test=&gt; commit;
COMMIT
test=&gt; begin;
BEGIN
test=&gt; insert into foo values(1);
ERROR:  duplicate key value violates unique constraint &quot;foo_pkey&quot;
test=&gt; insert into foo values(2);
ERROR:  current transaction is aborted, commands ignored until end of transaction block</pre></div>
</div>
<p>What SQLAlchemy offers that solves both issues is support of SAVEPOINT, via
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session.begin_nested" title="sqlalchemy.orm.session.Session.begin_nested"><tt class="xref py py-meth docutils literal"><span class="pre">Session.begin_nested()</span></tt></a>. Using <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session.begin_nested" title="sqlalchemy.orm.session.Session.begin_nested"><tt class="xref py py-meth docutils literal"><span class="pre">Session.begin_nested()</span></tt></a>, you can frame an operation that may
potentially fail within a transaction, and then &#8220;roll back&#8221; to the point
before its failure while maintaining the enclosing transaction.</p>
</div>
<div class="section" id="but-why-isn-t-the-one-automatic-call-to-rollback-enough-why-must-i-rollback-again">
<h3>But why isn&#8217;t the one automatic call to ROLLBACK enough?  Why must I ROLLBACK again?<a class="headerlink" href="#but-why-isn-t-the-one-automatic-call-to-rollback-enough-why-must-i-rollback-again" title="Permalink to this headline">¶</a></h3>
<p>This is again a matter of the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><tt class="xref py py-class docutils literal"><span class="pre">Session</span></tt></a> providing a consistent interface and
refusing to guess about what context its being used. For example, the
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><tt class="xref py py-class docutils literal"><span class="pre">Session</span></tt></a> supports &#8220;framing&#8221; above within multiple levels. Such as, suppose
you had a decorator <tt class="docutils literal"><span class="pre">&#64;with_session()</span></tt>, which did this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">with_session</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">go</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
       <span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">subtransactions</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
       <span class="k">try</span><span class="p">:</span>
           <span class="n">ret</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
           <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
           <span class="k">return</span> <span class="n">ret</span>
       <span class="k">except</span><span class="p">:</span>
           <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
           <span class="k">raise</span>
   <span class="k">return</span> <span class="n">go</span></pre></div>
</div>
<p>The above decorator begins a transaction if one does not exist already, and
then commits it, if it were the creator. The &#8220;subtransactions&#8221; flag means that
if <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session.begin" title="sqlalchemy.orm.session.Session.begin"><tt class="xref py py-meth docutils literal"><span class="pre">Session.begin()</span></tt></a> were already called by an enclosing function, nothing happens
except a counter is incremented - this counter is decremented when <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session.commit" title="sqlalchemy.orm.session.Session.commit"><tt class="xref py py-meth docutils literal"><span class="pre">Session.commit()</span></tt></a>
is called and only when it goes back to zero does the actual COMMIT happen. It
allows this usage pattern:</p>
<div class="highlight-python"><div class="highlight"><pre>@with_session
def one():
   # do stuff
   two()


@with_session
def two():
   # etc.

one()

two()</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">one()</span></tt> can call <tt class="docutils literal"><span class="pre">two()</span></tt>, or <tt class="docutils literal"><span class="pre">two()</span></tt> can be called by itself, and the
<tt class="docutils literal"><span class="pre">&#64;with_session</span></tt> decorator ensures the appropriate &#8220;framing&#8221; - the transaction
boundaries stay on the outermost call level. As you can see, if <tt class="docutils literal"><span class="pre">two()</span></tt> calls
<tt class="docutils literal"><span class="pre">flush()</span></tt> which throws an exception and then issues a <tt class="docutils literal"><span class="pre">rollback()</span></tt>, there will
<em>always</em> be a second <tt class="docutils literal"><span class="pre">rollback()</span></tt> performed by the decorator, and possibly a
third corresponding to two levels of decorator. If the <tt class="docutils literal"><span class="pre">flush()</span></tt> pushed the
<tt class="docutils literal"><span class="pre">rollback()</span></tt> all the way out to the top of the stack, and then we said that
all remaining <tt class="docutils literal"><span class="pre">rollback()</span></tt> calls are moot, there is some silent behavior going
on there. A poorly written enclosing method might suppress the exception, and
then call <tt class="docutils literal"><span class="pre">commit()</span></tt> assuming nothing is wrong, and then you have a silent
failure condition. The main reason people get this error in fact is because
they didn&#8217;t write clean &#8220;framing&#8221; code and they would have had other problems
down the road.</p>
<p>If you think the above use case is a little exotic, the same kind of thing
comes into play if you want to SAVEPOINT- you might call <tt class="docutils literal"><span class="pre">begin_nested()</span></tt>
several times, and the <tt class="docutils literal"><span class="pre">commit()</span></tt>/<tt class="docutils literal"><span class="pre">rollback()</span></tt> calls each resolve the most
recent <tt class="docutils literal"><span class="pre">begin_nested()</span></tt>. The meaning of <tt class="docutils literal"><span class="pre">rollback()</span></tt> or <tt class="docutils literal"><span class="pre">commit()</span></tt> is
dependent upon which enclosing block it is called, and you might have any
sequence of <tt class="docutils literal"><span class="pre">rollback()</span></tt>/<tt class="docutils literal"><span class="pre">commit()</span></tt> in any order, and its the level of nesting
that determines their behavior.</p>
<p>In both of the above cases, if <tt class="docutils literal"><span class="pre">flush()</span></tt> broke the nesting of transaction
blocks, the behavior is, depending on scenario, anywhere from &#8220;magic&#8221; to
silent failure to blatant interruption of code flow.</p>
<p><tt class="docutils literal"><span class="pre">flush()</span></tt> makes its own &#8220;subtransaction&#8221;, so that a transaction is started up
regardless of the external transactional state, and when complete it calls
<tt class="docutils literal"><span class="pre">commit()</span></tt>, or <tt class="docutils literal"><span class="pre">rollback()</span></tt> upon failure - but that <tt class="docutils literal"><span class="pre">rollback()</span></tt> corresponds
to its own subtransaction - it doesn&#8217;t want to guess how you&#8217;d like to handle
the external &#8220;framing&#8221; of the transaction, which could be nested many levels
with any combination of subtransactions and real SAVEPOINTs. The job of
starting/ending the &#8220;frame&#8221; is kept consistently with the code external to the
<tt class="docutils literal"><span class="pre">flush()</span></tt>, and we made a decision that this was the most consistent approach.</p>
</div>
</div>
<div class="section" id="how-do-i-make-a-query-that-always-adds-a-certain-filter-to-every-query">
<h2>How do I make a Query that always adds a certain filter to every query?<a class="headerlink" href="#how-do-i-make-a-query-that-always-adds-a-certain-filter-to-every-query" title="Permalink to this headline">¶</a></h2>
<p>See the recipe at <a class="reference external" href="http://www.sqlalchemy.org/trac/wiki/UsageRecipes/PreFilteredQuery">PreFilteredQuery</a>.</p>
</div>
<div class="section" id="i-ve-created-a-mapping-against-an-outer-join-and-while-the-query-returns-rows-no-objects-are-returned-why-not">
<h2>I&#8217;ve created a mapping against an Outer Join, and while the query returns rows, no objects are returned.  Why not?<a class="headerlink" href="#i-ve-created-a-mapping-against-an-outer-join-and-while-the-query-returns-rows-no-objects-are-returned-why-not" title="Permalink to this headline">¶</a></h2>
<p>Rows returned by an outer join may contain NULL for part of the primary key,
as the primary key is the composite of both tables.  The <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><tt class="xref py py-class docutils literal"><span class="pre">Query</span></tt></a> object ignores incoming rows
that don&#8217;t have an acceptable primary key.   Based on the setting of the <tt class="docutils literal"><span class="pre">allow_partial_pks</span></tt>
flag on <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><tt class="xref py py-func docutils literal"><span class="pre">mapper()</span></tt></a>, a primary key is accepted if the value has at least one non-NULL
value, or alternatively if the value has no NULL values.  See <tt class="docutils literal"><span class="pre">allow_partial_pks</span></tt>
at <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><tt class="xref py py-func docutils literal"><span class="pre">mapper()</span></tt></a>.</p>
</div>
<div class="section" id="i-m-using-joinedload-or-lazy-false-to-create-a-join-outer-join-and-sqlalchemy-is-not-constructing-the-correct-query-when-i-try-to-add-a-where-order-by-limit-etc-which-relies-upon-the-outer-join">
<h2>I&#8217;m using <tt class="docutils literal"><span class="pre">joinedload()</span></tt> or <tt class="docutils literal"><span class="pre">lazy=False</span></tt> to create a JOIN/OUTER JOIN and SQLAlchemy is not constructing the correct query when I try to add a WHERE, ORDER BY, LIMIT, etc. (which relies upon the (OUTER) JOIN)<a class="headerlink" href="#i-m-using-joinedload-or-lazy-false-to-create-a-join-outer-join-and-sqlalchemy-is-not-constructing-the-correct-query-when-i-try-to-add-a-where-order-by-limit-etc-which-relies-upon-the-outer-join" title="Permalink to this headline">¶</a></h2>
<p>The joins generated by joined eager loading are only used to fully load related
collections, and are designed to have no impact on the primary results of the query.
Since they are anonymously aliased, they cannot be referenced directly.</p>
<p>For detail on this beahvior, see <tt class="xref doc docutils literal"><span class="pre">orm/loading</span></tt>.</p>
</div>
<div class="section" id="query-has-no-len-why-not">
<h2>Query has no <tt class="docutils literal"><span class="pre">__len__()</span></tt>, why not?<a class="headerlink" href="#query-has-no-len-why-not" title="Permalink to this headline">¶</a></h2>
<p>The Python <tt class="docutils literal"><span class="pre">__len__()</span></tt> magic method applied to an object allows the <tt class="docutils literal"><span class="pre">len()</span></tt>
builtin to be used to determine the length of the collection. It&#8217;s intuitive
that a SQL query object would link <tt class="docutils literal"><span class="pre">__len__()</span></tt> to the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.query.Query.count" title="sqlalchemy.orm.query.Query.count"><tt class="xref py py-meth docutils literal"><span class="pre">Query.count()</span></tt></a>
method, which emits a <cite>SELECT COUNT</cite>. The reason this is not possible is
because evaluating the query as a list would incur two SQL calls instead of
one:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Iterates</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;LEN!&quot;</span>
        <span class="k">return</span> <span class="mi">5</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;ITER!&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="nb">list</span><span class="p">(</span><span class="n">Iterates</span><span class="p">())</span></pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>ITER!
LEN!</pre></div>
</div>
</div>
<div class="section" id="how-do-i-use-textual-sql-with-orm-queries">
<h2>How Do I use Textual SQL with ORM Queries?<a class="headerlink" href="#how-do-i-use-textual-sql-with-orm-queries" title="Permalink to this headline">¶</a></h2>
<p>See:</p>
<ul class="simple">
<li><a class="reference internal" href="../orm/tutorial.html#orm-tutorial-literal-sql"><em>Using Literal SQL</em></a> - Ad-hoc textual blocks with <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><tt class="xref py py-class docutils literal"><span class="pre">Query</span></tt></a></li>
<li><a class="reference internal" href="../orm/persistence_techniques.html#session-sql-expressions"><em>Using SQL Expressions with Sessions</em></a> - Using <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><tt class="xref py py-class docutils literal"><span class="pre">Session</span></tt></a> with textual SQL directly.</li>
</ul>
</div>
<div class="section" id="i-m-calling-session-delete-myobject-and-it-isn-t-removed-from-the-parent-collection">
<h2>I&#8217;m calling <tt class="docutils literal"><span class="pre">Session.delete(myobject)</span></tt> and it isn&#8217;t removed from the parent collection!<a class="headerlink" href="#i-m-calling-session-delete-myobject-and-it-isn-t-removed-from-the-parent-collection" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="../orm/session_basics.html#session-deleting-from-collections"><em>Deleting from Collections</em></a> for a description of this behavior.</p>
</div>
<div class="section" id="why-isn-t-my-init-called-when-i-load-objects">
<h2>why isn&#8217;t my <tt class="docutils literal"><span class="pre">__init__()</span></tt> called when I load objects?<a class="headerlink" href="#why-isn-t-my-init-called-when-i-load-objects" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="../orm/constructors.html#mapping-constructors"><em>Constructors and Object Initialization</em></a> for a description of this behavior.</p>
</div>
<div class="section" id="how-do-i-use-on-delete-cascade-with-sa-s-orm">
<h2>how do I use ON DELETE CASCADE with SA&#8217;s ORM?<a class="headerlink" href="#how-do-i-use-on-delete-cascade-with-sa-s-orm" title="Permalink to this headline">¶</a></h2>
<p>SQLAlchemy will always issue UPDATE or DELETE statements for dependent
rows which are currently loaded in the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><tt class="xref py py-class docutils literal"><span class="pre">Session</span></tt></a>.  For rows which
are not loaded, it will by default issue SELECT statements to load
those rows and udpate/delete those as well; in other words it assumes
there is no ON DELETE CASCADE configured.
To configure SQLAlchemy to cooperate with ON DELETE CASCADE, see
<a class="reference internal" href="../orm/collections.html#passive-deletes"><em>Using Passive Deletes</em></a>.</p>
</div>
<div class="section" id="i-set-the-foo-id-attribute-on-my-instance-to-7-but-the-foo-attribute-is-still-none-shouldn-t-it-have-loaded-foo-with-id-7">
<h2>I set the &#8220;foo_id&#8221; attribute on my instance to &#8220;7&#8221;, but the &#8220;foo&#8221; attribute is still <tt class="docutils literal"><span class="pre">None</span></tt> - shouldn&#8217;t it have loaded Foo with id #7?<a class="headerlink" href="#i-set-the-foo-id-attribute-on-my-instance-to-7-but-the-foo-attribute-is-still-none-shouldn-t-it-have-loaded-foo-with-id-7" title="Permalink to this headline">¶</a></h2>
<p>The ORM is not constructed in such a way as to support
immediate population of relationships driven from foreign
key attribute changes - instead, it is designed to work the
other way around - foreign key attributes are handled by the
ORM behind the scenes, the end user sets up object
relationships naturally. Therefore, the recommended way to
set <tt class="docutils literal"><span class="pre">o.foo</span></tt> is to do just that - set it!:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">foo</span> <span class="o">=</span> <span class="n">Session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span>
<span class="n">Session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p>Manipulation of foreign key attributes is of course entirely legal.  However,
setting a foreign-key attribute to a new value currently does not trigger
an &#8220;expire&#8221; event of the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><tt class="xref py py-func docutils literal"><span class="pre">relationship()</span></tt></a> in which it&#8217;s involved.  This means
that for the following sequence:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">o</span> <span class="o">=</span> <span class="n">Session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="c"># accessing an un-set attribute sets it to None</span>
<span class="n">o</span><span class="o">.</span><span class="n">foo_id</span> <span class="o">=</span> <span class="mi">7</span></pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">o.foo</span></tt> is initialized to <tt class="docutils literal"><span class="pre">None</span></tt> when we first accessed it.  Setting
<tt class="docutils literal"><span class="pre">o.foo_id</span> <span class="pre">=</span> <span class="pre">7</span></tt> will have the value of &#8220;7&#8221; as pending, but no flush
has occurred - so <tt class="docutils literal"><span class="pre">o.foo</span></tt> is still <tt class="docutils literal"><span class="pre">None</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># attribute is already set to None, has not been</span>
<span class="c"># reconciled with o.foo_id = 7 yet</span>
<span class="k">assert</span> <span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="ow">is</span> <span class="bp">None</span></pre></div>
</div>
<p>For <tt class="docutils literal"><span class="pre">o.foo</span></tt> to load based on the foreign key mutation is usually achieved
naturally after the commit, which both flushes the new foreign key value
and expires all state:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c"># expires all attributes</span>

<span class="n">foo_7</span> <span class="o">=</span> <span class="n">Session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="ow">is</span> <span class="n">foo_7</span>  <span class="c"># o.foo lazyloads on access</span></pre></div>
</div>
<p>A more minimal operation is to expire the attribute individually - this can
be performed for any <a class="reference internal" href="../glossary.html#term-persistent"><em class="xref std std-term">persistent</em></a> object using <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session.expire" title="sqlalchemy.orm.session.Session.expire"><tt class="xref py py-meth docutils literal"><span class="pre">Session.expire()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">o</span> <span class="o">=</span> <span class="n">Session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="n">o</span><span class="o">.</span><span class="n">foo_id</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">Session</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">])</span>  <span class="c"># object must be persistent for this</span>

<span class="n">foo_7</span> <span class="o">=</span> <span class="n">Session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="ow">is</span> <span class="n">foo_7</span>  <span class="c"># o.foo lazyloads on access</span></pre></div>
</div>
<p>Note that if the object is not persistent but present in the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><tt class="xref py py-class docutils literal"><span class="pre">Session</span></tt></a>,
it&#8217;s known as <a class="reference internal" href="../glossary.html#term-pending"><em class="xref std std-term">pending</em></a>.   This means the row for the object has not been
INSERTed into the database yet.  For such an object, setting <tt class="docutils literal"><span class="pre">foo_id</span></tt> does not
have meaning until the row is inserted; otherwise there is no row yet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">new_obj</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">()</span>
<span class="n">new_obj</span><span class="o">.</span><span class="n">foo_id</span> <span class="o">=</span> <span class="mi">7</span>

<span class="n">Session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_obj</span><span class="p">)</span>

<span class="c"># accessing an un-set attribute sets it to None</span>
<span class="k">assert</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">foo</span> <span class="ow">is</span> <span class="bp">None</span>

<span class="n">Session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>  <span class="c"># emits INSERT</span>

<span class="c"># expire this because we already set .foo to None</span>
<span class="n">Session</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">])</span>

<span class="k">assert</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">foo</span> <span class="ow">is</span> <span class="n">foo_7</span>  <span class="c"># now it loads</span></pre></div>
</div>
<div class="topic">
<p class="topic-title first">Attribute loading for non-persistent objects</p>
<p>One variant on the &#8220;pending&#8221; behavior above is if we use the flag
<tt class="docutils literal"><span class="pre">load_on_pending</span></tt> on <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><tt class="xref py py-func docutils literal"><span class="pre">relationship()</span></tt></a>.   When this flag is set, the
lazy loader will emit for <tt class="docutils literal"><span class="pre">new_obj.foo</span></tt> before the INSERT proceeds; another
variant of this is to use the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session.enable_relationship_loading" title="sqlalchemy.orm.session.Session.enable_relationship_loading"><tt class="xref py py-meth docutils literal"><span class="pre">Session.enable_relationship_loading()</span></tt></a>
method, which can &#8220;attach&#8221; an object to a <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><tt class="xref py py-class docutils literal"><span class="pre">Session</span></tt></a> in such a way that
many-to-one relationships load as according to foreign key attributes
regardless of the object being in any particular state.
Both techniques are <strong>not recommended for general use</strong>; they were added to suit
specific programming scenarios encountered by users which involve the repurposing
of the ORM&#8217;s usual object states.</p>
</div>
<p>The recipe <a class="reference external" href="http://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange">ExpireRelationshipOnFKChange</a> features an example using SQLAlchemy events
in order to coordinate the setting of foreign key attributes with many-to-one
relationships.</p>
</div>
<div class="section" id="is-there-a-way-to-automagically-have-only-unique-keywords-or-other-kinds-of-objects-without-doing-a-query-for-the-keyword-and-getting-a-reference-to-the-row-containing-that-keyword">
<h2>Is there a way to automagically have only unique keywords (or other kinds of objects) without doing a query for the keyword and getting a reference to the row containing that keyword?<a class="headerlink" href="#is-there-a-way-to-automagically-have-only-unique-keywords-or-other-kinds-of-objects-without-doing-a-query-for-the-keyword-and-getting-a-reference-to-the-row-containing-that-keyword" title="Permalink to this headline">¶</a></h2>
<p>When people read the many-to-many example in the docs, they get hit with the
fact that if you create the same <tt class="docutils literal"><span class="pre">Keyword</span></tt> twice, it gets put in the DB twice.
Which is somewhat inconvenient.</p>
<p>This <a class="reference external" href="http://www.sqlalchemy.org/trac/wiki/UsageRecipes/UniqueObject">UniqueObject</a> recipe was created to address this issue.</p>
</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links">
        Previous:
        <a href="performance.html" title="previous chapter">Performance</a>
        Next:
        <a href="../changelog/index.html" title="next chapter">Changes and Migration</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2015, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.
    </div>
</div>

</div>


        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.0.0b5',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


