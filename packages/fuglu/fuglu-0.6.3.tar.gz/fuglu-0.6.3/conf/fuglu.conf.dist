
[main]

#where should fuglu search for additional plugins
plugindir=

#what SCANNER plugins do we load, comma separated
plugins=archive,attachment,clamav,spamassassin

#what PREPENDER plugins do we load, comma separated
prependers=debug,skip

#what APPENDER plugins do we load, comma separated
#appender plugins are plugins run after the scanning plugins
#appenders will always be run, even if a a scanner plugin decided to delete/bounce/whatever a message
#(unless a mail is deferred in which case running the appender would not make sense as it will come again)
appenders=

#outgoing hostname/ip where postfix is listening for re-injects.
#use ${injecthost} to connect back to the IP where the incoming connection came from
outgoinghost=127.0.0.1

#run as group
group=nobody

#If a plugin decides to delete a message, save a copy here
#default empty, eg. do not save a backup copy
trashdir=

#if this is set to True/1/yes , no Bounces will be sent from Fuglu eg. after a blocked attachment has been detected
#This may be used for debugging/testing to make sure fuglu can not produce backscatter
disablebounces=0

#outgoing port  where postfix is listening for re-injects)
outgoingport=10026

#port where fuglu provides statistics etc (used by fuglu_control). Can also be a path to a unix socket
controlport=/tmp/fuglu_control.sock

#incoming port(s) (postfix connects here)
#you can use multiple comma separated ports here
#f.ex. to separate incoming and outgoing mail and a special port for debugging messages
#10025: standard incoming mail
#10099: outgoing mail
#10888: debug port
incomingport=10025,10099,10888

#identifier can be any string that helps you identifying your config file
#this helps making sure the correct config is loaded. this identifier will be printed out when fuglu is reloading its config
identifier=dist

#String to prepend to added headers
prependaddedheaders=X-Fuglu-

#temp dir where fuglu can store messages while scanning
tempdir=/tmp

#write debug info header to every mail
debuginfoheader=0

#Log pattern to use for all suspects in fuglu log. set empty string to disable logging generic suspect info. Supports the usual template variables plus: ${size}, ${spam} ${highspam}, ${modified} ${decision} ${tags} (short tags representagion) ${fulltags} full tags output, ${decision}
logtemplate=Suspect ${id} from=${from_address} to=${to_address} size=${size} spam=${spam} virus=${virus} modified=${modified} decision=${decision}

##outgoing helo we should use for re-injects
#leave empty to auto-detect current hostname
outgoinghelo=

#run as user
user=nobody

#write suspect ID to every mail
suspectidheader=1

#list all deleted messages in 00-fuglutrash.log in the trashdir
trashlog=0

#address fuglu should listen on. usually 127.0.0.1 so connections are accepted from local host only
bindaddress=127.0.0.1

#run as a daemon? (fork)
daemonize=1

#write mrtg statistics
mrtgdir=

[PluginAlias]
skip=fuglu.plugins.p_skipper.PluginSkipper
clamav=fuglu.plugins.clamav.ClamavPlugin
debug=fuglu.plugins.p_debug.MessageDebugger
sssp=fuglu.plugins.sssp.SSSPPlugin
fprot=fuglu.plugins.fprot.FprotPlugin
icap=fuglu.plugins.icap.ICAPPlugin
archive=fuglu.plugins.archive.ArchivePlugin
spamassassin=fuglu.plugins.sa.SAPlugin
vacation=fuglu.plugins.vacation.VacationPlugin
actionoverride=fuglu.plugins.actionoverride.ActionOverridePlugin
attachment=fuglu.plugins.attachment.FiletypePlugin
scriptfilter=fuglu.plugins.script.ScriptFilter
dkimsign=fuglu.plugins.domainauth.DKIMSignPlugin
spf=fuglu.plugins.domainauth.SPFPlugin
dkimverify=fuglu.plugins.domainauth.DKIMVerifyPlugin
fraction=fuglu.plugins.p_fraction.PluginFraction

[databaseconfig]

#read runtime configuration values from a database. requires sqlalchemy to be installed
dbconnectstring=

#sql query that returns a configuration value override. sql placeholders are ':section',':option' in addition the usual suspect filter default values like ':to_domain', ':to_address' etc
#if the statement returns more than one row/value only the first value in the first row is used
sql=SELECT value FROM fugluconfig WHERE `section`=:section AND `option`=:option AND `scope` IN ('$GLOBAL',CONCAT('%',:to_domain),:to_address) ORDER BY `scope` DESC

[spam]

#what to do with messages if a plugin is sure it is spam ("high spam") 
#in after-queue mode this is probably still DUNNO or maybe DELETE for courageous people
#this is a DEFAULT action, eg. anti spam plugins should take this if you didn't set
# a individual override 
defaulthighspamaction=DUNNO

#what to do with messages that plugins think are spam but  not so sure  ("low spam")
#in normal usage you probably never set this something other than DUNNO
#this is a DEFAULT action, eg. anti spam plugins should take this if you didn't set 
# a individual override
defaultlowspamaction=DUNNO

[smtpconnector]

#confirmation template sent back to the connecting postfix for accepted messages
requeuetemplate=FUGLU REQUEUE(${id}): ${injectanswer}

[environment]

#Optional regex that should be applied to received headers to skip trusted (local) mta helo/ip/reverse dns.
#Only required if plugins need to have information about the last untrusted host and the message doesn't pass a fixed amount of hops to reach this system in your network
trustedhostsregex=

#Distance to the boundary MTA ("how many received headers should fuglu skip to determine the last untrusted host information"). Only required if plugins need to have information about the last untrusted host(SPFPlugin)
boundarydistance=0

[performance]

#maximum scanner threads
maxthreads=40

#minimum scanner threads
minthreads=2

[esmtpconnector]

#confirmation template sent back to the connecting client for accepted messages
queuetemplate=${injectanswer}

[virus]

##what to do with messages if a plugin detects a virus
#in after-queue mode this should probably be DELETE
#in pre-queue mode you could use REJECT
#this is a DEFAULT action, eg. anti-virus plugins should take this if you didn't set 
# a individual override
defaultvirusaction=DELETE

[ArchivePlugin]

#change owner of saved messages (username or numeric id) - this only works if fuglu is running as root (which is NOT recommended)
chown=

#Archiving SuspectFilter File
archiverules=/etc/fuglu/archive.regex

#filename template for the archived messages
filenametemplate=${id}.eml

#subdirectory within archivedir
subdirtemplate=${to_domain}

#if true/1/yes: store original message
#if false/0/no: store message probably altered by previous plugins, eg with spamassassin headers
storeoriginal=1

#storage for archived messages
archivedir=/tmp

#set file permissions of saved messages
chmod=

#change group of saved messages (groupname or numeric id) - the user running fuglu must be a member of the target group for this to work
chgrp=

[FiletypePlugin]

#inform the sender about blocked attachments.
#If a previous plugin tagged the message as spam or infected, no bounce will be sent to prevent backscatter
sendbounce=1

#read runtime configuration values from a database. requires sqlalchemy to be installed
dbconnectstring=

#sql query to load rules from a db. #:scope will be replaced by the recipient address first, then by the recipient domain
#:check will be replaced 'filename','contenttype','archive-filename' or 'archive-contenttype'
query=SELECT action,regex,description FROM attachmentrules WHERE scope=:scope AND checktype=:checktype ORDER BY prio

#Mail template for the bounce to inform sender about blocked attachment
template_blockedfile=/etc/fuglu/templates/blockedfile.tmpl

#directory that contains attachment rules
rulesdir=/etc/fuglu/rules

#enable scanning of filenames within archives (currently, only ZIP archives supported). This does not actually extract the files, it just looks at the filenames found in the archive.
checkarchivenames=0

#what should the plugin do when a blocked attachment is detected
#REJECT : reject the message (recommended in pre-queue mode)
#DELETE : discard messages
#DUNNO  : mark as blocked but continue anyway (eg. if you have a later quarantine plugin)
blockaction=DELETE

#extract compressed archives(only ZIP supported currently) and check file content type with libmagics
#note that the files will be extracted into memory - tune archivecontentmaxsize  accordingly.
#fuglu does not extract archives within the archive(recursion)
checkarchivecontent=0

#only extract and examine files up to this amount of (uncompressed) bytes
archivecontentmaxsize=5000000

[ClamavPlugin]

#how often should fuglu retry the connection before giving up
retries=3

#hostname where clamd runs
host=localhost

#reject message template if running in pre-queue mode and virusaction=REJECT
rejectmessage=threat detected: ${virusname}

#socket timeout
timeout=30

#action if there is a problem (DUNNO, DEFER)
problemaction=DEFER

#maximum message size, larger messages will not be scanned.  
#should match the 'StreamMaxLength' config option in clamd.conf 
maxsize=22000000

#tcp port number or path to clamd.sock for unix domain sockets
#example /var/lib/clamav/clamd.sock or on ubuntu: /var/run/clamav/clamd.ctl 
port=3310

#action if infection is detected (DUNNO, REJECT, DELETE)
virusaction=DEFAULTVIRUSACTION

[SAPlugin]

#how often should fuglu retry the connection before giving up
retries=3

#action if there is a problem (DUNNO, DEFER)
problemaction=DEFER

#reject message template if running in pre-queue mode and virusaction=REJECT
rejectmessage=message identified as spam

#forward the original message or replace the content as returned by spamassassin
#if this is set to True/1/Yes , no spamassassin headers will be visible in the final message.
#"original" in this case means "as passed to spamassassin", eg. if 'scanoriginal' is set to 0 above this will forward the
#message as retreived from previous plugins 
forwardoriginal=0

#consult spamassassins(or any other) sql blacklist for messages that are too big for spam checks
#requires the sql extension to be enabled
check_sql_blacklist=0

#sqlalchemy db connect string
sql_blacklist_dbconnectstring=mysql:///localhost/spamassassin

#SQL query to get the blacklist entries for a suspect
#you may use template variables: ${from_address} ${from_domain} ${to_address} ${to_domain}
sql_blacklist_sql=SELECT value FROM userpref WHERE prefid='blacklist_from' AND username in ('$GLOBAL',concat('%',${to_domain}),${to_address})

#maximum message size, larger messages will not be scanned.  
#should match the 'StreamMaxLength' config option in clamd.conf 
maxsize=256000

#what header does SA set to indicate the spam status
#Note that fuglu requires a standard header template configuration for spamstatus and score extraction
#if forwardoriginal is set to 0
#eg. start with _YESNO_ or _YESNOCAPS_ and contain score=_SCORE_
spamheader=X-Spam-Status

#hostname where clamd runs
host=localhost

#what should we do with high spam (spam score above highspamlevel)
highspamaction=DEFAULTHIGHSPAMACTION

#socket timeout
timeout=30

#spamscore threshold to mark a message as high spam
highspamlevel=15

#enable SA user configuration 
peruserconfig=1

#tcp port number or path to clamd.sock for unix domain sockets
#example /var/lib/clamav/clamd.sock or on ubuntu: /var/run/clamav/clamd.ctl 
port=783

#should we scan the original message as retreived from postfix or scan the current state 
#in fuglu (which might have been altered by previous plugins)
#only set this to disabled if you have a custom plugin that adds special headers to the message that will be 
#used in spamassassin rules
scanoriginal=1

#what should we do with low spam (eg. detected as spam, but score not over highspamlevel)
lowspamaction=DEFAULTLOWSPAMACTION

[debug]

#messages incoming on this port will be debugged to a logfile
#Make sure the debugport is also set in the incomingport configuration option in the main section
debugport=10888

#debug log output
debugfile=/tmp/fuglu_debug.log

#don't re-inject debugged messages back to postfix
noreinject=1

#debugged message can not be bounced
nobounce=1

#don't run appender plugins for debugged messages
noappender=1

[PluginSkipper]
filterfile=/etc/fuglu/skipplugins.regex
