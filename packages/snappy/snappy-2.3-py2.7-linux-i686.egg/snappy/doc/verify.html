<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Verified computations &mdash; SnapPy 2.3 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="SnapPy 2.3 documentation" href="index.html" />
    <link rel="next" title="Other components" href="other.html" />
    <link rel="prev" title="Number theory of hyperbolic 3-manifolds" href="snap.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="other.html" title="Other components"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="snap.html" title="Number theory of hyperbolic 3-manifolds"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SnapPy 2.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="verified-computations">
<h1>Verified computations<a class="headerlink" href="#verified-computations" title="Permalink to this headline">¶</a></h1>
<p>When used inside <a class="reference external" href="http://sagemath.org">Sage</a>, SnapPy can use
interval arithmetic to rigorously verify the hyperbolicity of an
orientable 3-manifold:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&quot;m015&quot;)
sage: M.verify_hyperbolicity()
(True,
 [0.6623589786224? + 0.5622795120623?*I,
  0.6623589786224? + 0.5622795120623?*I,
  0.6623589786224? + 0.5622795120623?*I])
</pre></div>
</div>
<p>It does so by producing intervals that are guaranteed to contain a
true solution to the rectangular gluing equations (give <code class="docutils literal"><span class="pre">bits_prec</span></code> or
<code class="docutils literal"><span class="pre">dec_prec</span></code> for higher precision intervals).  This method works even when
not all tetrahedra are positively oriented:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&quot;m015(3, 1)&quot;)
sage: M.tetrahedra_shapes(&#39;rect&#39;, intervals=True)
[0.625222762246? + 3.177940133813?*I,
 -0.0075523593782? + 0.5131157955971?*I,
 0.6515818912107? - 0.1955023488930?*I]
</pre></div>
</div>
<p>This is all achieved through a reimplementation of <a class="reference external" href="http://www.oishi.info.waseda.ac.jp/~takayasu/hikmot/">HIKMOT</a> which
pioneered the use of interval methods for hyperbolic manifolds.  It
can be used in a very similar way than HIKMOT, but uses Sage&#8217;s complex
interval types and the Newton interval method (instead of the Krawczyk
test) for certification. See <a class="reference external" href="http://ww2.ii.uj.edu.pl/~zgliczyn/cap07/krawczyk.pdf">Zgliczynski&#8217;s notes</a> for a quick
overview of these two tests.</p>
<p>This verification code was contributed by Matthias Goerner.</p>
<div class="section" id="methods-of-verifying-hyperbolicity">
<h2>Methods of verifying hyperbolicity<a class="headerlink" href="#methods-of-verifying-hyperbolicity" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="snappy.verify.verify_hyperbolicity">
<code class="descclassname">snappy.verify.</code><code class="descname">verify_hyperbolicity</code><span class="sig-paren">(</span><em>manifold</em>, <em>verbose=False</em>, <em>bits_prec=53</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.verify.verify_hyperbolicity" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an orientable SnapPy Manifold, verifies its hyperbolicity.
Similar to HIKMOT&#8217;s verify_hyperbolicity, the result is either
(True, listOfShapeIntervals) or (False, []) if verification failed.
listOfShapesIntervals is a list of complex intervals (elements in
sage&#8217;s ComplexIntervalField) certified to contain the true shapes
for the hyperbolic manifold.</p>
<p>Higher precision intervals can be obtained by setting bits_prec:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: from snappy import Manifold
sage: M = Manifold(&quot;m019&quot;)
sage: verify_hyperbolicity(M)
(True, [0.7805525278508? + 0.9144736629678?*I, 0.7805525278508? + 0.91447366296773?*I, 0.46002117557372? + 0.63262419360526?*I])

sage: M = Manifold(&quot;t02333(3,4)&quot;)
sage: verify_hyperbolicity(M)
(True, [2.152188153612? + 0.28494066790?*I, 1.92308491369? + 1.10360701507?*I, 0.014388591584? + 0.143084469681?*I, -2.5493670288? + 3.7453498408?*I, 0.142120333822? + 0.176540027036?*I, 0.50486686588? + 0.82829881681?*I, 0.50479249917? + 0.98036162786?*I, -0.58949570508? + 0.81267480427?*I])
</pre></div>
</div>
<p>A non-hyperbolic manifold:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&quot;t02333(1,0)&quot;)
sage: verify_hyperbolicity(M)
(False, [])
</pre></div>
</div>
<p>Under the hood, the function will call the CertifiedShapesEngine to produce
intervals certified to contain a solution to the rectangular gluing equations.
It then calls check_logarithmic_gluing_equations_and_positively_oriented_tets
to verify that the logarithmic gluing equations are fulfilled and that all
tetrahedra are positively oriented.</p>
</dd></dl>

</div>
<div class="section" id="generating-certified-shape-intervals">
<h2>Generating certified shape intervals<a class="headerlink" href="#generating-certified-shape-intervals" title="Permalink to this headline">¶</a></h2>
<p>The recommeded way to obtain certified intervals for the shapes is via
<code class="docutils literal"><span class="pre">manifold.tetrahedra_shapes(intervals=True)</span></code> as <a class="reference external" href="verify.html">described earlier</a>. Here we document the <code class="docutils literal"><span class="pre">CertifiedShapesEngine</span></code> used
internally to generate these intervals. It is of interest for those
users who want to understand the underlying interval math and
experiment with the Newton interval method.</p>
<span class="target" id="module-snappy.verify"></span><dl class="class">
<dt id="snappy.verify.CertifiedShapesEngine">
<em class="property">class </em><code class="descclassname">snappy.verify.</code><code class="descname">CertifiedShapesEngine</code><span class="sig-paren">(</span><em>M</em>, <em>initial_shapes</em>, <em>bits_prec=None</em>, <em>dec_prec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.verify.CertifiedShapesEngine" title="Permalink to this definition">¶</a></dt>
<dd><p>An engine that is initialized with an approximated candidate solution to
the rectangular gluing equations and produces intervals certified to
contain a true solution. After the engine is successfully run, the
resulting intervals are stored in certified_shapes which is a vector of
elements in a Sage&#8217;s ComplexIntervalField.</p>
<p>A simple example to obtain certified shape intervals that uses
CertifiedShapesEngine under the hood:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: from snappy import Manifold
sage: M = Manifold(&quot;m015&quot;)
sage: M.tetrahedra_shapes(bits_prec = 80, intervals = True)
[{&#39;accuracies&#39;: (None, None, None, None), &#39;log&#39;: -0.140599787161480923256? + 0.703857721301476517492?*I, &#39;rect&#39;: 0.662358978622373012981? + 0.562279512062301243900?*I},
 {&#39;accuracies&#39;: (None, None, None, None), &#39;log&#39;: -0.140599787161480923256? + 0.703857721301476517492?*I, &#39;rect&#39;: 0.662358978622373012981? + 0.562279512062301243900?*I},
 {&#39;accuracies&#39;: (None, None, None, None), &#39;log&#39;: -0.140599787161480923256? + 0.703857721301476517492?*I, &#39;rect&#39;: 0.662358978622373012981? + 0.562279512062301243900?*I}]
</pre></div>
</div>
<p>Its objective is thus the same as HIKMOT and it is certainly HIKMOT
inspired. However, it conceptually differs in that:</p>
<ol class="arabic">
<li><p class="first">It uses the Newton interval method instead of the Krawczyk
test (we implement Gaussian elimination in interval arithmetic to
compute the inverse of an interval matrix having interval arithmetic
semantics, see mat_solve).</p>
</li>
<li><p class="first">It uses complex numbers in it&#8217;s Newton interval method.
We simply use Sage&#8217;s complex interval type avoiding the need of
converting n x n complex matrices into 2n x 2n real matrices as
described Section 3.4 of the HIKMOT paper.</p>
</li>
<li><p class="first">We avoid automatic differentiation.  We pick an independent set of
equations of the following form and try to solve them:</p>
<blockquote>
<div><p>log(LHS) = 0</p>
</div></blockquote>
<p>where</p>
<blockquote>
<div><p>LHS =  c * z0^a0 * (1-z0)^b0 *  z1^a1 * (1-z1)^b1 * ...</p>
</div></blockquote>
<p>with a, b and c&#8217;s as returned by Manifold.gluing_equations(&#8216;rect&#8217;).</p>
<p>The derivative of log (LHS) with respect to zj is simply given by</p>
<blockquote>
<div><p>aj/zj - bj/(1-zj)</p>
</div></blockquote>
<p>and thus no need for automatic differentiation.</p>
</li>
</ol>
<p>In contrast to HIKMOT, we use and return Sage&#8217;s native implementation of
(complex) interval arithmetic here, which allows for increased interoperability. 
Another advantage is that Sage supports arbitrary precision. Unfortunately,
performance suffers and this implementation is 5-10 times slower than HIKMOT.</p>
<p>Here is an example how to explicitly invoke the CertifiedShapesEngine:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: shapes = M.tetrahedra_shapes(&#39;rect&#39;, bits_prec = 80)
sage: C = CertifiedShapesEngine(M, shapes, bits_prec = 80)
sage: C.expand_until_certified()
True
sage: C.certified_shapes
(0.662358978622373012981? + 0.562279512062301243900?*I, 0.662358978622373012981? + 0.562279512062301243900?*I, 0.662358978622373012981? + 0.562279512062301243900?*I)
</pre></div>
</div>
<dl class="staticmethod">
<dt id="snappy.verify.CertifiedShapesEngine.certified_newton_iteration">
<em class="property">static </em><code class="descname">certified_newton_iteration</code><span class="sig-paren">(</span><em>equations</em>, <em>shapes</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.verify.CertifiedShapesEngine.certified_newton_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Given shape intervals z, performs a Newton interval iteration N(z)
as described in newton_iteration. Returns a pair (boolean, N(z)) where
the boolean is True if N(z) is contained in z.</p>
<p>If the boolean is True, it is certified that N(z) contains a true
solution, e.g., a point for which f is truely zero.</p>
<p>This follows from Theorem 1 of <a class="reference external" href="http://ww2.ii.uj.edu.pl/~zgliczyn/cap07/krawczyk.pdf">Zgliczynski&#8217;s notes</a>.</p>
<p>Some examples:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: from snappy import Manifold
sage: M = Manifold(&quot;m019&quot;)
sage: C = CertifiedShapesEngine(M, M.tetrahedra_shapes(&#39;rect&#39;),
...                           bits_prec = 80)
</pre></div>
</div>
<p>Intervals containing the true solution:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: good_shapes = vector([
...       C.CIF(C.RIF(0.78055, 0.78056), C.RIF(0.91447, 0.91448)),
...       C.CIF(C.RIF(0.78055, 0.78056), C.RIF(0.91447, 0.91448)),
...       C.CIF(C.RIF(0.46002, 0.46003), C.RIF(0.63262, 0.63263))])
sage: is_certified, shapes = CertifiedShapesEngine.certified_newton_iteration(C.equations, good_shapes)

sage: is_certified
True
sage: shapes
(0.78055253? + 0.91447366?*I, 0.78055253? + 0.91447367?*I, 0.46002118? + 0.63262420?*I)
</pre></div>
</div>
<p>This means that a true solution to the rectangular gluing equations is
contained in both the given intervals (good_shapes) and the returned
intervals (shapes) which are a refinement of the given intervals.</p>
<p>Intervals not containing a true solution:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: bad_shapes = vector([
...       C.CIF(C.RIF(0.78054, 0.78055), C.RIF(0.91447, 0.91448)),
...       C.CIF(C.RIF(0.78055, 0.78056), C.RIF(0.91447, 0.91448)),
...       C.CIF(C.RIF(0.46002, 0.46003), C.RIF(0.63262, 0.63263))])
sage: is_certified, shapes = CertifiedShapesEngine.certified_newton_iteration(C.equations, bad_shapes)
sage: is_certified
False
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.verify.CertifiedShapesEngine.expand_until_certified">
<code class="descname">expand_until_certified</code><span class="sig-paren">(</span><em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.verify.CertifiedShapesEngine.expand_until_certified" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to Newton interval iterate, then try to expand the shape intervals
until we can certify they contain a true solution.
If succeeded, return True and write certified shapes to
certified_shapes.
Set verbose = True for printing additional information.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="snappy.verify.CertifiedShapesEngine.interval_vector_is_contained_in">
<em class="property">static </em><code class="descname">interval_vector_is_contained_in</code><span class="sig-paren">(</span><em>vecA</em>, <em>vecB</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.verify.CertifiedShapesEngine.interval_vector_is_contained_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two vectors of intervals, return whether the first one
is contained in the second one.  Examples:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: RIF = RealIntervalField(80)
sage: CIF = ComplexIntervalField(80)
sage: box = CIF(RIF(-1,1),RIF(-1,1))
sage: a = [ CIF(0.1), CIF(1) + box ]
sage: b = [ CIF(0) + box, CIF(1) + 2 * box ]
sage: c = [ CIF(0), CIF(1) + 3 * box ]

sage: CertifiedShapesEngine.interval_vector_is_contained_in(a, b)
True
sage: CertifiedShapesEngine.interval_vector_is_contained_in(a, c)
False
sage: CertifiedShapesEngine.interval_vector_is_contained_in(b, a)
False
sage: CertifiedShapesEngine.interval_vector_is_contained_in(b, c)
False
sage: CertifiedShapesEngine.interval_vector_is_contained_in(c, a)
False
sage: CertifiedShapesEngine.interval_vector_is_contained_in(c, b)
False
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="snappy.verify.CertifiedShapesEngine.largest_diameter">
<em class="property">static </em><code class="descname">largest_diameter</code><span class="sig-paren">(</span><em>shapes</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.verify.CertifiedShapesEngine.largest_diameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a vector of complex intervals, return the maximum of all
their diameters:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: RIF = RealIntervalField(80)
sage: CIF = ComplexIntervalField(80)
sage: box = CIF(RIF(1,1.01),RIF(1,1.02))
sage: v = [ CIF(2) + box, CIF(3) + 2 * box ]
sage: CertifiedShapesEngine.largest_diameter(v)
0.019801980198019819393754
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="snappy.verify.CertifiedShapesEngine.log_gluing_LHS_derivatives">
<em class="property">static </em><code class="descname">log_gluing_LHS_derivatives</code><span class="sig-paren">(</span><em>equations</em>, <em>shapes</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.verify.CertifiedShapesEngine.log_gluing_LHS_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Jacobian of the vector-valued function f
described in the above log_gluing_LHSs:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: from snappy import Manifold
sage: M = Manifold(&quot;m019&quot;)
sage: equations = M.gluing_equations(&#39;rect&#39;)
sage: RIF = RealIntervalField(80)
sage: CIF = ComplexIntervalField(80)
sage: shape1 = CIF(RIF(0.78055,0.78056), RIF(0.9144, 0.9145))
sage: shape2 = CIF(RIF(0.46002,0.46003), RIF(0.6326, 0.6327))
sage: shapes = [shape1, shape1, shape2]
sage: CertifiedShapesEngine.log_gluing_LHS_derivatives(equations, shapes)
[  0.292? - 1.667?*I   0.292? - 1.667?*I   0.752? - 1.034?*I]
[-0.5400? + 0.633?*I -0.5400? + 0.633?*I   1.561? + 1.829?*I]
[ 0.2482? + 1.034?*I  0.2482? + 1.034?*I  -2.313? - 0.795?*I]
[ 0.5400? - 0.633?*I -0.5400? + 0.633?*I                   0]
[-0.4963? - 2.068?*I  1.0800? - 1.266?*I   0.752? - 1.034?*I]
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="snappy.verify.CertifiedShapesEngine.log_gluing_LHSs">
<em class="property">static </em><code class="descname">log_gluing_LHSs</code><span class="sig-paren">(</span><em>equations</em>, <em>shapes</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.verify.CertifiedShapesEngine.log_gluing_LHSs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the result of M.gluing_equations(&#8216;rect&#8217;) or a
subset of rows of it and shapes, return a vector of
log(LHS) where</p>
<blockquote>
<div>LHS = c * z0 ** a0 * (1-z0) ** b0 * z1 ** a1 * ...</div></blockquote>
<p>Let f: C^n -&gt; C^n denote the function which takes
shapes and returns the vector of log(LHS).</p>
<p>The reason we take the logarithm of the rectangular
gluing equations is because the logarithmic derivative
is of a particular nice form:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: from snappy import Manifold
sage: M = Manifold(&quot;m019&quot;)
sage: equations = M.gluing_equations(&#39;rect&#39;)
sage: RIF = RealIntervalField(80)
sage: CIF = ComplexIntervalField(80)
sage: zero = CIF(0).center()
sage: shape1 = CIF(RIF(0.78055,0.78056), RIF(0.9144, 0.9145))
sage: shape2 = CIF(RIF(0.46002,0.46003), RIF(0.6326, 0.6327))
</pre></div>
</div>
<p>An interval solution containing the true solution. The log of each
rectangular equation should be 0 for the true solution, hence the interval
should contain zero:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: shapes = [shape1, shape1, shape2]
sage: LHSs = CertifiedShapesEngine.log_gluing_LHSs(equations, shapes)
sage: LHSs
(0.000? + 0.000?*I, 0.000? + 0.000?*I, 0.000? + 0.000?*I, 0.000? + 0.000?*I, 0.000? + 0.000?*I)
sage: zero in LHSs[0]
True
</pre></div>
</div>
<p>An interval not containing the true solution:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: shapes = [shape1, shape1, shape1]
sage: LHSs = CertifiedShapesEngine.log_gluing_LHSs(equations, shapes)
sage: LHSs
(0.430? - 0.078?*I, -0.25? + 0.942?*I, -0.19? - 0.87?*I, 0.000? + 0.000?*I, 0.430? - 0.078?*I)
sage: zero in LHSs[0]
False
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="snappy.verify.CertifiedShapesEngine.mat_solve">
<em class="property">static </em><code class="descname">mat_solve</code><span class="sig-paren">(</span><em>m</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.verify.CertifiedShapesEngine.mat_solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a matrix m and a vector v of (complex) intervals, returns
the vector a such that v = m * a preserving interval
arithmetics: if m&#8217; is a matrix with values in the intervals of m and 
v&#8217; is a vector with values in the intervals of v, then the intervals
of the result a returned by this method are guarenteed to contain
the entries of m&#8217;^-1 * v&#8217;.</p>
<p>Sage already provides a method for inverting matrices. However, it
has a flaw and fails inverting interval matrices even though the
interval determinant is far from containing zero (it returns
unusuable matrices with entries (-inf, inf).</p>
<p>Our implementation improves on this by swapping rows to avoid
diagonal entries close to zero during Gaussian elimination.</p>
<p>Setup a complex interval for example:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: RIF = RealIntervalField(80)
sage: CIF = ComplexIntervalField(80)
sage: fuzzy_four = CIF(RIF(3.9999,4.0001),RIF(-0.0001,0.0001))
</pre></div>
</div>
<p>Construct a matrix/vector with complex interval coefficients. One entry
is a complex interval with non-zero diameter:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: m = matrix(CIF,
...      [  [ fuzzy_four, 3, 2, 3],
...         [          2, 3, 6, 2],
...         [          2, 4, 1, 6],
...         [          3, 2,-5, 2]])
sage: v = vector(CIF, [fuzzy_four, 2, 0 ,1])
</pre></div>
</div>
<p>Now compute the solutions a to v = m * a:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: a = CertifiedShapesEngine.mat_solve(m, v)
sage: a
(1.58? + 0.000?*I, -1.24? + 0.000?*I, 0.346? + 0.0000?*I, 0.24? + 0.000?*I)
sage: m * a
(4.0? + 0.00?*I, 2.0? + 0.00?*I, 0.0? + 0.00?*I, 1.00? + 0.00?*I)
</pre></div>
</div>
<p>The product actually contains the vector v, we check entry wise:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: [s in t for s, t in zip(v, m * a)]
[True, True, True, True]
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="snappy.verify.CertifiedShapesEngine.newton_iteration">
<em class="property">static </em><code class="descname">newton_iteration</code><span class="sig-paren">(</span><em>equations</em>, <em>shapes</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.verify.CertifiedShapesEngine.newton_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a Newton interval method of iteration for
the function f described in log_gluing_LHSs.</p>
<p>Let z denote the shape intervals.
Let z_center be a point close to the center point of the shape
intervals (in the implementation, z_center is an interval of
again, of length zero).</p>
<p>The result returned will be</p>
<blockquote>
<div>N(z) = z_center - ((Df)(z))^-1 f(z_center)</div></blockquote>
<p>A very approximate solution:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: from snappy import Manifold
sage: M = Manifold(&quot;m019&quot;)
sage: shapes = [ 0.7+1j, 0.7+1j, 0.5+0.5j ]
</pre></div>
</div>
<p>Get the equations and initialize zero-length intervals from it:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C = CertifiedShapesEngine(M, shapes, bits_prec = 80)
sage: C.initial_shapes
(0.69999999999999995559107902? + 1*I, 0.69999999999999995559107902? + 1*I, 0.50000000000000000000000000? + 0.50000000000000000000000000?*I)
</pre></div>
</div>
<p>Do several Newton interval operations to get a better solution:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: shape_intervals = C.initial_shapes
sage: for i in range(4):
...     shape_intervals = CertifiedShapesEngine.newton_iteration(C.equations, shape_intervals)
...     print shape_intervals
(0.786746831183814577704? + 0.9208680745160821379529?*I, 0.7867468311838145777038? + 0.9208680745160821379529?*I, 0.4598680582870980309347? + 0.6194087185583516731751?*I)
(0.780561025176326485948? + 0.914496211844675048270?*I, 0.780561025176326485948? + 0.914496211844675048270?*I, 0.4599773577869384936554? + 0.632519407186945386957?*I)
(0.780552531045316100498? + 0.9144736621585220345231?*I, 0.7805525310453161004973? + 0.9144736621585220345231?*I, 0.4600211671037324947004? + 0.6326241909236695020810?*I)
(0.780552527850724832568? + 0.9144736629677264403330?*I, 0.7805525278507248325678? + 0.9144736629677264403330?*I, 0.4600211755737178641204? + 0.6326241936052562241142?*I)
</pre></div>
</div>
<p>For comparison:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.tetrahedra_shapes(&#39;rect&#39;)
[0.780552527850725 + 0.914473662967727*I, 0.780552527850725 + 0.914473662967726*I, 0.460021175573718 + 0.632624193605256*I]
</pre></div>
</div>
<p>Start with a rather big interval, note that the Newton interval method is
stable in the sense that the interval size decreases:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: box = C.CIF(C.RIF(-0.0001,0.0001),C.RIF(-0.0001,0.0001))
sage: shape_intervals = C.initial_shapes.apply_map(lambda shape: shape + box)
sage: shape_intervals
(0.700? + 1.000?*I, 0.700? + 1.000?*I, 0.500? + 0.500?*I)
sage: for i in range(7):
...     shape_intervals = CertifiedShapesEngine.newton_iteration(C.equations, shape_intervals)
...     print shape_intervals
(0.79? + 0.92?*I, 0.79? + 0.92?*I, 0.460? + 0.62?*I)
(0.78? + 0.92?*I, 0.78? + 0.92?*I, 0.46? + 0.64?*I)
(0.781? + 0.915?*I, 0.7806? + 0.9145?*I, 0.4601? + 0.6327?*I)
(0.7805526? + 0.9144737?*I, 0.7805526? + 0.9144737?*I, 0.4600212? + 0.6326242?*I)
(0.780552527850725? + 0.914473662967727?*I, 0.780552527850725? + 0.914473662967727?*I, 0.4600211755737179? + 0.6326241936052562?*I)
(0.780552527850724837987? + 0.9144736629677264559386?*I, 0.7805525278507248379869? + 0.9144736629677264559386?*I, 0.4600211755737178728919? + 0.6326241936052561716379?*I)
(0.780552527850724837987? + 0.9144736629677264559386?*I, 0.7805525278507248379869? + 0.9144736629677264559386?*I, 0.4600211755737178728919? + 0.6326241936052561716379?*I)
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Verified computations</a><ul>
<li><a class="reference internal" href="#methods-of-verifying-hyperbolicity">Methods of verifying hyperbolicity</a></li>
<li><a class="reference internal" href="#generating-certified-shape-intervals">Generating certified shape intervals</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="snap.html"
                        title="previous chapter">Number theory of hyperbolic 3-manifolds</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="other.html"
                        title="next chapter">Other components</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/verify.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="other.html" title="Other components"
             >next</a> |</li>
        <li class="right" >
          <a href="snap.html" title="Number theory of hyperbolic 3-manifolds"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SnapPy 2.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2009-2015, by Marc Culler, Nathan Dunfield, Jeffrey Weeks and others.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>