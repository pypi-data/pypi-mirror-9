<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Manifold: the main class &mdash; SnapPy 2.3 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="SnapPy 2.3 documentation" href="index.html" />
    <link rel="up" title="The snappy module and its classes" href="snappy.html" />
    <link rel="next" title="ManifoldHP: High-precision variant" href="manifoldhp.html" />
    <link rel="prev" title="The snappy module and its classes" href="snappy.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="manifoldhp.html" title="ManifoldHP: High-precision variant"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="snappy.html" title="The snappy module and its classes"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SnapPy 2.3 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="snappy.html" accesskey="U">The snappy module and its classes</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-snappy">
<span id="manifold-the-main-class"></span><h1>Manifold: the main class<a class="headerlink" href="#module-snappy" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="snappy.Manifold">
<em class="property">class </em><code class="descclassname">snappy.</code><code class="descname">Manifold</code><a class="headerlink" href="#snappy.Manifold" title="Permalink to this definition">¶</a></dt>
<dd><p>A Manifold is a Triangulation together with a geometric structure.
That is, a Manifold is an ideal triangulation of the interior of a
compact 3-manifold with torus boundary, where each tetrahedron has
has been assigned the geometry of an ideal tetrahedron in
hyperbolic 3-space.  A Dehn-filling can be specified for each
boundary component, allowing the description of closed 3-manifolds
and some orbifolds.   Here&#8217;s a quick example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;9_42&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
<span class="go">4.05686022</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s">&#39;shape&#39;</span><span class="p">)</span>
<span class="go">[-4.27893632 + 1.95728680*I]</span>
</pre></div>
</div>
<p>A Manifold can be specified in a number of ways, e.g.</p>
<ul>
<li><p class="first">Manifold(&#8216;9_42&#8217;) : The complement of the knot 9_42 in S^3.</p>
</li>
<li><dl class="first docutils">
<dt>Manifold(&#8216;m125(1,2)(4,5)&#8217;) <span class="classifier-delimiter">:</span> <span class="classifier">The SnapPea census manifold m125</span></dt>
<dd><p class="first last">where the first cusp has Dehn filling (1,2) and the second cusp has
filling (4,5).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Manifold() <span class="classifier-delimiter">:</span> <span class="classifier">Opens a link editor window where can you</span></dt>
<dd><p class="first last">specify a link complement.</p>
</dd>
</dl>
</li>
</ul>
<p>In general, the specification can be from among the below, with
information on Dehn fillings added.</p>
<ul>
<li><p class="first">SnapPea cusped census manifolds: e.g. &#8216;m123&#8217;, &#8216;s123&#8217;, &#8216;v123&#8217;.</p>
</li>
<li><dl class="first docutils">
<dt>Link complements:</dt>
<dd><ul class="first last simple">
<li>Rolfsen&#8217;s table: e.g. &#8216;4_1&#8217;, &#8216;04_1&#8217;, &#8216;5^2_6&#8217;, &#8216;6_4^7&#8217;, &#8216;L20935&#8217;, &#8216;l104001&#8217;.</li>
<li>Hoste-Thistlethwaite Knotscape table:  e.g. &#8216;11a17&#8217; or &#8216;12n345&#8217;</li>
<li>Callahan-Dean-Weeks-Champanerkar-Kofman-Patterson knots: e.g. &#8216;K6_21&#8217;.</li>
<li>Dowker-Thistlethwaite code: e.g. &#8216;DT:[(6,8,2,4)]&#8217;</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">Once-punctured torus bundles: e.g. &#8216;b++LLR&#8217;, &#8216;b+-llR&#8217;, &#8216;bo-RRL&#8217;, &#8216;bn+LRLR&#8217;</p>
</li>
<li><p class="first">Fibered manifold associated to a braid: &#8216;Braid[1,2,-3,4]&#8217;</p>
<p>Here, the braid is thought of as a mapping class of the
punctured disc, and this manifold is the corresponding
mapping torus.  If you want the braid closure, do (1,0) filling
of the last cusp.</p>
</li>
<li><p class="first">From mapping class group data using Twister:</p>
<p>&#8216;Bundle(S_{1,1}, [a0, B1])&#8217; or &#8216;Splitting(S_{1,0}, [b1, A0], [a0,B1])&#8217;</p>
<p>See the help for the &#8216;twister&#8217; module for more.</p>
</li>
<li><p class="first">A SnapPea triangulation or link projection file: &#8216;filename&#8217;</p>
<p>The file will be loaded if found in the current directory or the
path given by the shell variable SNAPPEA_MANIFOLD_DIRECTORY.</p>
</li>
<li><p class="first">A string containing the contents of a SnapPea triangulation or link
projection file.</p>
</li>
</ul>
<dl class="method">
<dt id="snappy.Manifold.DT_code">
<code class="descname">DT_code</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.DT_code" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Dowker-Thistlethwaite code of this link complement,
if it is a link complement. The DT code is intended to be an
immutable attribute, for use with knot and link exteriors
only, which is set only when the manifold was created.</p>
<p>Here is the Whitehead link:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;L5a1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">DT_code</span><span class="p">()</span>
<span class="go">[(6, 8), (2, 10, 4)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">DT_code</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;ebbccdaeb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">DT_code</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">flips</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;ebbccdaeb.01110&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">DT_code</span><span class="p">(</span><span class="n">flips</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">([(6, 8), (2, 10, 4)], [0, 1, 1, 1, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.alexander_polynomial">
<code class="descname">alexander_polynomial</code><span class="sig-paren">(</span><em>manifold</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.alexander_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the multivariable Alexander polynomial of the manifold:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&#39;K12n123&#39;)
sage: M.alexander_polynomial()
2*a^6 - 14*a^5 + 34*a^4 - 45*a^3 + 34*a^2 - 14*a + 2

sage: N = Triangulation(&#39;v1539(5,1)&#39;)
sage: N.alexander_polynomial()
a^2*b + a*b^2 + a*b + a + b
</pre></div>
</div>
<p>Any provided keyword arguments are passed to fundamental_group and
so affect the group presentation used in the computation.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.browse">
<code class="descname">browse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.browse" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m125&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">browse</span><span class="p">()</span> <span class="c"># Opens browser window  </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.canonize">
<code class="descname">canonize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.canonize" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the triangulation to an arbitrary retriangulation of
the canonical cell decomposition.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m007&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">num_tetrahedra</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">canonize</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">num_tetrahedra</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
<p>Note: due to rounding error, it is possible that this is not
actually the canonical triangulation.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.chern_simons">
<code class="descname">chern_simons</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.chern_simons" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Chern-Simons invariant of the manifold, if it is known.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span>
<span class="go">-0.15320413</span>
</pre></div>
</div>
<p>The return value has an extra attribute, accuracy, which
is the number of digits of accuracy as <em>estimated</em> by SnapPea.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span><span class="o">.</span><span class="n">accuracy</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">57</span><span class="p">)</span> <span class="c"># Low and High precision</span>
<span class="go">True</span>
</pre></div>
</div>
<p>By default, when the manifold has at least one cusp, Zickert&#8217;s
algorithm is used; when the manifold is closed we use SnapPea&#8217;s
original algorithm, which is based on Meyerhoff-Hodgson-Neumann.</p>
<p>Note: When computing the Chern-Simons invariant of a closed
manifold, one must sometimes compute it first for the unfilled
manifold so as to initialize SnapPea&#8217;s internals.  For instance,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;5_2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span>
<span class="go">-0.15320413</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span>
<span class="go">0.07731787</span>
</pre></div>
</div>
<p>works, but will fail with &#8216;Chern-Simons invariant not
currently known&#8217; if the first call to chern_simons is not
made.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.complex_volume">
<code class="descname">complex_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.complex_volume" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns the complex volume, i.e.</dt>
<dd>volume + i 2 pi^2 (chern simons)</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;5_2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">complex_volume</span><span class="p">()</span>
<span class="go">2.82812209 - 3.02412838*I</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the manifold</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.cover">
<code class="descname">cover</code><span class="sig-paren">(</span><em>permutation_rep</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cover" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Manifold representing the finite cover
specified by a transitive permutation representation.  The
representation is specified by a list of permutations, one for
each generator of the simplified presentation of the
fundamental group.  Each permutation is specified as a list P
such that set(P) == set(range(d)) where d is the degree of the
cover.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N0</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cover</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">N0</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span><span class="o">/</span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0000000001</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If within Sage, the permutations can also be of type
PermutationGroupElement, in which case they act on the set
range(1, d + 1).  Or, you can specify a GAP or Magma subgroup
of the fundamental group.     Some examples:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&#39;m004&#39;)
</pre></div>
</div>
<p>The basic method:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: N0 = M.cover([[1, 3, 0, 4, 2], [0, 2, 1, 4, 3]])
</pre></div>
</div>
<p>From a Gap subgroup:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: G = gap(M.fundamental_group())
sage: H = G.LowIndexSubgroupsFpGroup(5)[9]
sage: N1 = M.cover(H)
sage: N0 == N1
True
</pre></div>
</div>
<p>Or a homomorphism to a permutation group:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: f = G.GQuotients(PSL(2,7))[1]
sage: N2 = M.cover(f)
sage: N2.volume()/M.volume()
8.00000000
</pre></div>
</div>
<p>Or maybe we want larger cover coming from the kernel of this:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: N3 = M.cover(f.Kernel())
sage: N3.volume()/M.volume()
168.00000000
</pre></div>
</div>
<p>Check the homology against what Gap computes directly:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: N3.homology().betti_number()
32
sage: len([ x for x in f.Kernel().AbelianInvariants().sage() if x == 0])
32
</pre></div>
</div>
<p>We can do the same for Magma:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: G = magma(M.fundamental_group())             #doctest: +SKIP
sage: Q, f = G.pQuotient(5, 1, nvals = 2)          #doctest: +SKIP
sage: M.cover(f.Kernel()).volume()                 #doctest: +SKIP
10.14941606
sage: h = G.SimpleQuotients(1, 11, 2, 10000)[1,1]  #doctest: +SKIP
sage: N4 = M.cover(h)                              #doctest: +SKIP
sage: N2 == N4                                     #doctest: +SKIP
True
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.cover_info">
<code class="descname">cover_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cover_info" title="Permalink to this definition">¶</a></dt>
<dd><p>If this is a manifold or triangulation which was constructed as
a covering space, return a dictionary describing the cover.  Otherwise
return 0.  The dictionary keys are &#8216;base&#8217;, &#8216;type&#8217; and &#8216;degree&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.covers">
<code class="descname">covers</code><span class="sig-paren">(</span><em>degree</em>, <em>method=None</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.covers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Manifolds corresponding to all of the
finite covers of the given degree.</p>
<p>WARNING: If the degree is large this might take a very, very,
very long time.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">covers</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">homology</span><span class="p">())</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">covers</span><span class="p">]</span>
<span class="go">[(m003~irr~0(0,0)(0,0), Z/5 + Z + Z), (m003~cyc~1(0,0), Z/3 + Z/15 + Z)]</span>
</pre></div>
</div>
<p>You can also look just at cyclic covers, which is much faster.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">covers</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">cover_type</span><span class="o">=</span><span class="s">&#39;cyclic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">homology</span><span class="p">())</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">covers</span><span class="p">]</span>
<span class="go">[(m003~cyc~0(0,0), Z/3 + Z/15 + Z)]</span>
</pre></div>
</div>
<p>If you are using Sage, you can use GAP to find the subgroups,
which is often much faster, by specifying the optional
argument method = &#8216;gap&#8217; If you have Magma installed, you can
used it to do the heavy lifting by specifying method=&#8217;magma&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.cusp_info">
<code class="descname">cusp_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cusp_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an info object containing information about the given
cusp.   Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;v3227(0,0)(1,2)(3,2)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Cusp 1 : torus cusp with Dehn filling coeffients (M, L) = (1.0, 2.0)</span>
</pre></div>
</div>
<p>To get more detailed information about the cusp, we do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>
<span class="go">0.11044502 + 0.94677098*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">modulus</span>
<span class="go">-0.12155872 + 1.04204128*I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;filling&#39;, &#39;holonomies&#39;, &#39;holonomy_accuracy&#39;, &#39;index&#39;, &#39;is_complete&#39;, &#39;modulus&#39;, &#39;shape&#39;, &#39;shape_accuracy&#39;, &#39;topology&#39;]</span>
</pre></div>
</div>
<p>Here &#8216;shape&#8217; is the shape of the cusp, i.e.
(longitude/meridian)
and &#8216;modulus&#8217; is its shape in the geometrically preferred
basis, i.e.
( (second shortest translation)/(shortest translation)).
For cusps that are filled, one instead cares about the
holonomies:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="s">&#39;holonomies&#39;</span><span class="p">]</span>
<span class="go">(-0.59883089 + 1.09812548*I, 0.89824633 + 1.49440443*I)</span>
</pre></div>
</div>
<p>The complex numbers returned for the shape and for the two
holonomies have an extra attribute, accuracy, which is
SnapPea&#8217;s <em>estimate</em> of their accuracy.</p>
<p>You can also get information about multiple cusps at once:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">()</span>
<span class="go">[Cusp 0 : complete torus cusp of shape 0.11044502 + 0.94677098*I,</span>
<span class="go"> Cusp 1 : torus cusp with Dehn filling coeffients (M, L) = (1.0, 2.0),</span>
<span class="go"> Cusp 2 : torus cusp with Dehn filling coeffients (M, L) = (3.0, 2.0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s">&#39;is_complete&#39;</span><span class="p">)</span>
<span class="go">[True, False, False]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.cusp_neighborhood">
<code class="descname">cusp_neighborhood</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.cusp_neighborhood" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns information about the cusp neighborhoods of the
manifold, in the form of data about the corresponding horoball
diagrams in hyperbolic 3-space.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;s000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">cusp_neighborhood</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
<span class="go">0.32475953</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">CN</span><span class="o">.</span><span class="n">horoballs</span><span class="p">(</span><span class="mf">0.01</span><span class="p">))</span>
<span class="go">178</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>  <span class="c"># Opens picture of the horoballs  </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.dehn_fill">
<code class="descname">dehn_fill</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.dehn_fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the Dehn filling coefficients of the cusps.  This can be
specified in the following ways, where the cusps are numbered
by 0,1,...,(num_cusps - 1).</p>
<ul>
<li><p class="first">Fill cusp 2:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;8^4_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">8^4_1(0,0)(0,0)(2,3)(0,0)</span>
</pre></div>
</div>
</li>
<li><p class="first">Fill the last cusp:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">8^4_1(0,0)(0,0)(2,3)(1,5)</span>
</pre></div>
</div>
</li>
<li><p class="first">Fill the first two cusps:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">[</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">8^4_1(3,0)(1,-4)(2,3)(1,5)</span>
</pre></div>
</div>
</li>
<li><p class="first">When there is only one cusp, there&#8217;s a shortcut</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span>
<span class="go">m004(-3,4)</span>
</pre></div>
</div>
</li>
</ul>
<p>Does not return a new Manifold.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.dirichlet_domain">
<code class="descname">dirichlet_domain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.dirichlet_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a DirichletDomain object representing a Dirichlet
domain of the hyperbolic manifold, typically centered at a
point which is a local maximum of injectivity radius.  It will
have ideal vertices if the manifold is not closed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dirichlet_domain</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>
<span class="go">32 finite vertices, 2 ideal vertices; 54 edges; 22 faces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>   <span class="c">#Shows 3d-graphical view.  </span>
</pre></div>
</div>
<p>Other options can be provided to customize the computation;
the default choices are shown below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dirichlet_domain</span><span class="p">(</span><span class="n">vertex_epsilon</span><span class="o">=</span><span class="mf">10.0</span><span class="o">**-</span><span class="mi">8</span><span class="p">,</span>  <span class="n">displacement</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
<span class="gp">... </span><span class="n">centroid_at_origin</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">maximize_injectivity_radius</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">32 finite vertices, 2 ideal vertices; 54 edges; 22 faces</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.drill">
<code class="descname">drill</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.drill" title="Permalink to this definition">¶</a></dt>
<dd><p>Drills out the specified dual curve from among all dual curves
with at most max_segments, which defaults to 6. The method
dual_curve allows one to see the properties of curves before
chosing which one to drill out.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;v3000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">drill</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_segments</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">(),</span> <span class="n">N</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">())</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.dual_curves">
<code class="descname">dual_curves</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.dual_curves" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a <em>reasonable</em> selection of simple closed curves in
a manifold&#8217;s dual 1-skeleton.  In particular, it returns thos e
that appear to represent geodesics. The resulting curves can
be drilled out.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">curves</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dual_curves</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">curves</span>
<span class="go">[  0: orientation-preserving curve of length 0.56239915 - 2.81543089*I,</span>
<span class="go">   1: orientation-preserving curve of length 1.12479830 + 0.65232354*I,</span>
<span class="go">   2: orientation-preserving curve of length 1.26080402 + 1.97804689*I,</span>
<span class="go">   3: orientation-preserving curve of length 1.58826933 + 1.67347167*I,</span>
<span class="go">   4: orientation-preserving curve of length 1.68719745 + 2.81543089*I]</span>
</pre></div>
</div>
<p>Each curve is returned as an info object with these keys</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;complete_length&#39;, &#39;filled_length&#39;, &#39;index&#39;, &#39;max_segments&#39;, &#39;parity&#39;]</span>
</pre></div>
</div>
<p>We can drill out any of these curves to get a new manifold
with one more cusp.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">drill</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">(),</span> <span class="n">N</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">())</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
<p>By default, this function only finds curves of length 6; this
can be changed by specifying the optional argument
max_segments</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dual_curves</span><span class="p">(</span><span class="n">max_segments</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[  0: orientation-preserving curve of length 0.56239915 - 2.81543089*I]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.edge_valences">
<code class="descname">edge_valences</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.edge_valences" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary whose keys are the valences of the edges
in the triangulation, and the value associated to a key is the
number of edges of that valence.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;v3227&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">edge_valences</span><span class="p">()</span>
<span class="go">{10: 1, 4: 1, 5: 2, 6: 3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.filled_triangulation">
<code class="descname">filled_triangulation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.filled_triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new Manifold where the specified cusps have been
permanently filled in.</p>
<p>Filling all the cusps results in a Triangulation rather
than a Manifold, since SnapPea can&#8217;t deal with hyperbolic
structures when there are no cusps.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m125(1,2)(3,4)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">filled_triangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Filling cusps 0 and 2 :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;v3227(1,2)(3,4)(5,6)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">filled_triangulation</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">v3227_filled(3,4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.fundamental_group">
<code class="descname">fundamental_group</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.fundamental_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a HolonomyGroup representing the fundamental group of
the manifold, together with its holonomy representation.  If
integer Dehn surgery parameters have been set, then the
corresponding peripheral elements are killed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span>
<span class="go">Generators:</span>
<span class="go">   a,b</span>
<span class="go">Relators:</span>
<span class="go">   aaabABBAb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">peripheral_curves</span><span class="p">()</span>
<span class="go">[(&#39;ab&#39;, &#39;aBAbABab&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">SL2C</span><span class="p">(</span><span class="s">&#39;baaBA&#39;</span><span class="p">)</span>
<span class="go">matrix([[ 2.50000000 - 2.59807621*I, -6.06217783 - 0.50000000*I],</span>
<span class="go">        [ 0.86602540 - 2.50000000*I, -4.00000000 + 1.73205081*I]])</span>
</pre></div>
</div>
<p>There are three optional arguments all of which default to True:</p>
<ul class="simple">
<li>simplify_presentation</li>
<li>fillings_may_affect_generators</li>
<li>minimize_number_of_generators</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
<span class="go">Generators:</span>
<span class="go">   a,b,c</span>
<span class="go">Relators:</span>
<span class="go">   CbAcB</span>
<span class="go">   BacA</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.gluing_equations">
<code class="descname">gluing_equations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.gluing_equations" title="Permalink to this definition">¶</a></dt>
<dd><p>In the default mode, this function returns a matrix with rows
of the form</p>
<blockquote>
<div>a b c  d e f  ...</div></blockquote>
<p>which means</p>
<blockquote>
<div>a*log(z0) + b*log(1/(1-z0)) + c*log((z0-1)/z0) + d*log(z1) +... = 2 pi i</div></blockquote>
<p>for an edge equation, and (same) = 0 for a cusp equation.
Here, the cusp equations come at the bottom of the matrix, and
are listed in the form: meridian of cusp 0, longitude of cusp
0, meridian of cusp 1, longitude of cusp 1,...</p>
<p>In terms of the tetrahedra, a is the invariant of the edge
(2,3), b the invariant of the edge (0,2) and c is the
invariant of the edge (1,2).  See kernel_code/edge_classes.c
for a detailed account of the convention used.</p>
<p>If the optional argument form=&#8217;rect&#8217; is given, then this
function returns a list of tuples of the form:</p>
<blockquote>
<div>( [a0, a1,..,a_n], [b_0, b_1,...,b_n], c)</div></blockquote>
<p>where this corresponds to the equation</p>
<blockquote>
<div>z0^a0 (1 - z0)^b0 z1^a1(1 - z1)^b1 ...  = c</div></blockquote>
<p>where c = 1 or -1.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;m004(2,3)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations</span><span class="p">()</span>
<span class="go">matrix([[ 2,  1,  0,  1,  0,  2],</span>
<span class="go">        [ 0,  1,  2,  1,  2,  0],</span>
<span class="go">        [ 2,  0,  0,  0, -8,  6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations</span><span class="p">(</span><span class="n">form</span><span class="o">=</span><span class="s">&#39;rect&#39;</span><span class="p">)</span>
<span class="go">[([2, -1], [-1, 2], 1), ([-2, 1], [1, -2], 1), ([2, -6], [0, 14], 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.gluing_equations_pgl">
<code class="descname">gluing_equations_pgl</code><span class="sig-paren">(</span><em>N = 2</em>, <em>equation_type='all'</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.gluing_equations_pgl" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a NeumannZagierTypeEquations object that contains a matrix
encoding the gluing equations for boundary-parabolic PGL(N,C)
representations together with explanations of the meaning
of the rows and the columns of the matrix.</p>
<p>This method generalizes gluing_equations() to PGL(N,C)-representations
as described in
Stavros Garoufalidis, Matthias Goerner, Christian K. Zickert: 
&#8220;Gluing Equations for PGL(n,C)-Representations of 3-Manifolds&#8221;
(<a class="reference external" href="http://arxiv.org/abs/1207.6711">http://arxiv.org/abs/1207.6711</a>).</p>
<p>The result of the traditional gluing_equations() can be obtained from
the general method by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations_pgl</span><span class="p">()</span><span class="o">.</span><span class="n">matrix</span>
<span class="go">matrix([[ 2,  1,  0,  1,  0,  2],</span>
<span class="go">        [ 0,  1,  2,  1,  2,  0],</span>
<span class="go">        [ 1,  0,  0,  0, -1,  0],</span>
<span class="go">        [ 0,  0,  0,  0, -2,  2]])</span>
</pre></div>
</div>
<p>But besides the matrix, the method also returns explanations of
the columns and rows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&quot;m004&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations_pgl</span><span class="p">()</span>
<span class="go">NeumannZagierTypeEquations(</span>
<span class="go">  matrix([[ 2,  1,  0,  1,  0,  2],</span>
<span class="go">          [ 0,  1,  2,  1,  2,  0],</span>
<span class="go">          [ 1,  0,  0,  0, -1,  0],</span>
<span class="go">          [ 0,  0,  0,  0, -2,  2]]),</span>
<span class="go">  explain_columns = [&#39;z_0000_0&#39;, &#39;zp_0000_0&#39;, &#39;zpp_0000_0&#39;, &#39;z_0000_1&#39;, &#39;zp_0000_1&#39;, &#39;zpp_0000_1&#39;],</span>
<span class="go">  explain_rows = [&#39;edge_0_0&#39;, &#39;edge_0_1&#39;, &#39;meridian_0_0&#39;, &#39;longitude_0_0&#39;])</span>
</pre></div>
</div>
<p>The first row of the matrix means that the edge equation for
edge 0 is</p>
<blockquote>
<div>z_0000_0 ^ 2 * zp_0000_0 * z_0000_1 * zpp_0000_1 ^ 2 = 1.</div></blockquote>
<p>Similarly, the next row encodes the edge equation for the other edge
and the next two rows encode peripheral equations.</p>
<p>Following the SnapPy convention, a z denotes the cross ratio z at the
edge (0,1), a zp the cross ratio z&#8217; at the edge (0,2) and a zpp the cross
ratio z&#8221; at the edge (1,2). The entire symbol z_xxxx_y then
denotes the cross ratio belonging to the subsimplex at integral
point xxxx (always 0000 for N = 2) of the simplex y. Note: the
SnapPy convention is different from the paper
mentioned above, e.g., compare 
kernel_code/edge_classes.c with Figure 3. We follow the SnapPy
convention here so that all computations done in SnapPy are
consistent.</p>
<p>The explanations of the rows and columns can be obtained explicitly by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations_pgl</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">equation_type</span> <span class="o">=</span> <span class="s">&#39;peripheral&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">explain_rows</span>
<span class="go">[&#39;meridian_0_0&#39;, &#39;meridian_1_0&#39;, &#39;longitude_0_0&#39;, &#39;longitude_1_0&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">gluing_equations_pgl</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">explain_columns</span>
<span class="go">[&#39;z_0000_0&#39;, &#39;zp_0000_0&#39;, &#39;zpp_0000_0&#39;, &#39;z_0000_1&#39;, &#39;zp_0000_1&#39;, &#39;zpp_0000_1&#39;]</span>
</pre></div>
</div>
<p>A subset of all gluing equations can be obtained by setting the
equation_type:</p>
<ul class="simple">
<li>all gluing equations: &#8216;all&#8217;</li>
<li>non-peripheral equations: &#8216;non_peripheral&#8217;<ul>
<li>edge gluing equations: &#8216;edge&#8217;</li>
<li>face gluing equations: &#8216;face&#8217;</li>
<li>internal gluing equations: &#8216;internal&#8217;</li>
</ul>
</li>
<li>cusp gluing equations: &#8216;peripheral&#8217;<ul>
<li>cusp gluing equations for meridians: &#8216;meridian&#8217;</li>
<li>cusp gluing equations for longitudes: &#8216;longitude&#8217;</li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.high_precision">
<code class="descname">high_precision</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.high_precision" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high precision version of this manifold.
&gt;&gt;&gt; M = Manifold(&#8216;m004&#8217;)
&gt;&gt;&gt; type(M.high_precision())
&lt;class &#8216;snappy.ManifoldHP&#8217;&gt;</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.homological_longitude">
<code class="descname">homological_longitude</code><span class="sig-paren">(</span><em>manifold</em>, <em>cusp=0</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.homological_longitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the peripheral curve in the given cusp, if any, which is
homologically trivial in the manifold:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&#39;m015&#39;)
sage: M.homological_longitude()
(2, -1)
</pre></div>
</div>
<p>The components of the next link have nontrivial linking number
so there is no such curve:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: W = Manifold(&#39;L7a2&#39;)
sage: W.homological_longitude(cusp=1) == None
True
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.homology">
<code class="descname">homology</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.homology" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an AbelianGroup representing the first integral
homology group of the underlying (Dehn filled) manifold.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;m003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">Z/5 + Z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.hyperbolic_SLN_torsion">
<code class="descname">hyperbolic_SLN_torsion</code><span class="sig-paren">(</span><em>M</em>, <em>N</em>, <em>bits_prec=100</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.hyperbolic_SLN_torsion" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the torsion polynomial of the holonomy representation lifted
to SL(2, C) and then followed by the irreducible representation
from SL(2, C) -&gt; SL(N, C):</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&#39;m016&#39;)
sage: [M.hyperbolic_SLN_torsion(N).degree() for N in [2, 3, 4]]
[18, 27, 36]
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.hyperbolic_adjoint_torsion">
<code class="descname">hyperbolic_adjoint_torsion</code><span class="sig-paren">(</span><em>M</em>, <em>bits_prec=100</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.hyperbolic_adjoint_torsion" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the torsion polynomial of the adjoint representation
a la Dubois-Yamaguichi.   This is not a sign-refined computation
so the result is only defined up to sign, not to mention a power
of the variable &#8216;a&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&#39;K11n42&#39;)
sage: tau = M.hyperbolic_adjoint_torsion()
sage: tau.parent()
Univariate Polynomial Ring in a over Complex Field with 100 bits of precision
sage: tau.degree()
7
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.hyperbolic_torsion">
<code class="descname">hyperbolic_torsion</code><span class="sig-paren">(</span><em>M</em>, <em>bits_prec=100</em>, <em>all_lifts=False</em>, <em>wada_conventions=False</em>, <em>phi=None</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.hyperbolic_torsion" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the hyperbolic torision polynomial as defined in
<a class="reference external" href="http://arxiv.org/abs/1108.3045">[DFJ]</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&#39;K11n42&#39;)
sage: M.alexander_polynomial()
1
sage: tau = M.hyperbolic_torsion(bits_prec=200)
sage: tau.degree()
6
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.identify">
<code class="descname">identify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.identify" title="Permalink to this definition">¶</a></dt>
<dd><p>Look for the manifold in all of the SnapPy databases:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m125&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">identify</span><span class="p">()</span>
<span class="go">[m125(0,0)(0,0), L13n5885(0,0)(0,0)]</span>
</pre></div>
</div>
<p>One can require that there be an isometry taking merdians
to meridians:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">identify</span><span class="p">(</span><span class="n">extends_to_link</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[m125(0,0)(0,0)]</span>
</pre></div>
</div>
<p>For closed manifolds, extends_to_link doesn&#8217;t make sense because
of how the kernel code works:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&quot;m015(1,2)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">identify</span><span class="p">()</span>
<span class="go">[m006(-5,2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">identify</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.invariant_trace_field_gens">
<code class="descname">invariant_trace_field_gens</code><span class="sig-paren">(</span><em>manifold</em>, <em>fundamental_group_args=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.invariant_trace_field_gens" title="Permalink to this definition">¶</a></dt>
<dd><p>The generators of the trace field as ApproximateAlgebraicNumbers. Can be
used to compute the tetrahedra field, where the first two parameters
are bits of precision and maximum degree of the field:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&#39;m007(3,1)&#39;)
sage: K = M.invariant_trace_field_gens().find_field(100, 10, optimize=True)[0]
sage: L = M.trace_field_gens().find_field(100, 10, optimize=True)[0]
sage: K.polynomial(), L.polynomial()
(x^2 - x + 1, x^4 - 2*x^3 + x^2 + 6*x + 3)
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.is_isometric_to">
<code class="descname">is_isometric_to</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.is_isometric_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if M and N are isometric, False if they not.  A
RuntimeError is raised in cases where the SnapPea kernel fails
to determine either answer.  (This is fairly common for closed
manifolds.)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;4_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;5_2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can also get a complete list of isometries between the two
manifolds:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;5^2_1&#39;</span><span class="p">)</span>  <span class="c"># The Whitehead link</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m129&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isoms</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">is_isometric_to</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">return_isometries</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isoms</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="c"># Includes action on cusps</span>
<span class="go">0 -&gt; 1  1 -&gt; 0 </span>
<span class="go">[1  2]  [-1 -2]</span>
<span class="go">[0 -1]  [ 0  1]</span>
<span class="go">Extends to link</span>
</pre></div>
</div>
<p>Each transformation between cusps is given by a matrix which
acts on the left.  That is, the two <em>columns</em> of the matrix
give the image of the meridian and longitude respectively.  In
the above example, the meridian of cusp 0 is sent to the
meridian of cusp 1.</p>
<p>Note: The answer True is rigorous, but the answer False may
not be as there could be numerical errors resulting in finding
an incorrect canonical triangulation.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.is_orientable">
<code class="descname">is_orientable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.is_orientable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the underlying 3-manifold is orientable.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;x124&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_orientable</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.is_two_bridge">
<code class="descname">is_two_bridge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.is_two_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>If the manifold is the complement of a two-bridge knot or link
in S^3, then this method returns (p,q) where p/q is the
fraction describing the link.  Otherwise, returns False.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_two_bridge</span><span class="p">()</span>
<span class="go">(2, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m016&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">is_two_bridge</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note: An answer of &#8216;True&#8217; is rigorous, but not the answer
&#8216;False&#8217;, as there could be numerical errors resulting in
finding an incorrect canonical triangulation.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.isomorphisms_to">
<code class="descname">isomorphisms_to</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.isomorphisms_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a complete list of combinatorial isomorphisms between
the two triangulations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;5^2_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;5^2_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">([[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isoms</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">isomorphisms_to</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isoms</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
<span class="go">0 -&gt; 1  1 -&gt; 0</span>
<span class="go">[ 1 0]  [-1 1]</span>
<span class="go">[-1 1]  [-3 2]</span>
<span class="go">Does not extend to link</span>
</pre></div>
</div>
<p>Each transformation between cusps is given by a matrix which
acts on the left.  That is, the two <em>columns</em> of the matrix
give the image of the meridian and longitude respectively.  In
the above example, the meridian of cusp 0 is sent to the
meridian of cusp 1.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.length_spectrum">
<code class="descname">length_spectrum</code><span class="sig-paren">(</span><em>cutoff=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.length_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of geodesics (with multiplicities) of length
up to the specified cutoff value. (The default cutoff is 1.0.)</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the triangulation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;4_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="go">&#39;4_1&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.normal_boundary_slopes">
<code class="descname">normal_boundary_slopes</code><span class="sig-paren">(</span><em>subset='all'</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.normal_boundary_slopes" title="Permalink to this definition">¶</a></dt>
<dd><p>For a one-cusped manifold, returns all the nonempty boundary slopes of
spun normal surfaces.  Provided the triangulation supports a
genuine hyperbolic structure, then by <a class="reference external" href="http://arxiv.org/abs/math/0503027">Thurston and Walsh</a> any strict boundary slope
(the boundary of an essential surface which is not a fiber or
semifiber) must be listed here.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;K3_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">normal_boundary_slopes</span><span class="p">()</span>
<span class="go">[(16, -1), (20, -1), (37, -2)]</span>
</pre></div>
</div>
<p>If the <code class="docutils literal"><span class="pre">subset</span></code> flag is set to <code class="docutils literal"><span class="pre">'kabaya'</span></code>, then it only
returns boundary slopes associated to vertex surfaces with a quad
in every tetrahedron; by Theorem 1.1. of <a class="reference external" href="http://arxiv.org/abs/1102.4588">[DG]</a> these are all strict boundary
slopes.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m113&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">normal_boundary_slopes</span><span class="p">()</span>
<span class="go">[(1, 1), (1, 2), (2, -1), (2, 3), (8, 11)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">normal_boundary_slopes</span><span class="p">(</span><span class="s">&#39;kabaya&#39;</span><span class="p">)</span>
<span class="go">[(8, 11)]</span>
</pre></div>
</div>
<p>If the <code class="docutils literal"><span class="pre">subset</span></code> flag is set to <code class="docutils literal"><span class="pre">'brasile'</span></code> then it returns
only the boundary slopes that are associated to vertex surfaces
giving isolated rays in the space of embedded normal surfaces.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">normal_boundary_slopes</span><span class="p">(</span><span class="s">&#39;brasile&#39;</span><span class="p">)</span>
<span class="go">[(1, 2), (8, 11)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.normal_surfaces">
<code class="descname">normal_surfaces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.normal_surfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>All the vertex spun-normal surfaces in the current triangulation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">normal_surfaces</span><span class="p">()</span>    
<span class="go">[&lt;Surface 0: [0, 0] [1, 2] (4, 1)&gt;,</span>
<span class="go"> &lt;Surface 1: [0, 1] [1, 2] (4, -1)&gt;,</span>
<span class="go"> &lt;Surface 2: [1, 2] [2, 1] (-4, -1)&gt;,</span>
<span class="go"> &lt;Surface 3: [2, 2] [2, 1] (-4, 1)&gt;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.num_cusps">
<code class="descname">num_cusps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.num_cusps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of cusps.  By giving the optional argument
&#8216;orientable&#8217; or &#8216;nonorientable&#8217; it will only count cusps of that type.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;m125&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">num_cusps</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.num_tetrahedra">
<code class="descname">num_tetrahedra</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.num_tetrahedra" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of tetrahedra in the triangulation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">num_tetrahedra</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.orientation_cover">
<code class="descname">orientation_cover</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.orientation_cover" title="Permalink to this definition">¶</a></dt>
<dd><p>For a non-orientable Triangulation, returns the 2-fold cover which
is orientable.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;x123&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">orientation_cover</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">is_orientable</span><span class="p">(),</span> <span class="n">Y</span><span class="o">.</span><span class="n">is_orientable</span><span class="p">())</span>
<span class="go">(False, True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span>
<span class="go">x123~(0,0)(0,0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span><span class="o">.</span><span class="n">cover_info</span><span class="p">()[</span><span class="s">&#39;type&#39;</span><span class="p">]</span>
<span class="go">&#39;cyclic&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.plink">
<code class="descname">plink</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.plink" title="Permalink to this definition">¶</a></dt>
<dd><p>Brings up a link editor window if there is a link known to be associated
with the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.polished_holonomy">
<code class="descname">polished_holonomy</code><span class="sig-paren">(</span><em>M</em>, <em>bits_prec=100</em>, <em>fundamental_group_args=[]</em>, <em>lift_to_SL2=True</em>, <em>ignore_solution_type=False</em>, <em>dec_prec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.polished_holonomy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the fundamental group of M equipt with a high-precision version of the
holonomy representation:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&#39;m004&#39;)
sage: G = M.polished_holonomy()
sage: G(&#39;a&#39;).trace()
1.5000000000000000000000000000 - 0.86602540378443864676372317075*I
sage: G = M.polished_holonomy(bits_prec=1000)
sage: G(&#39;a&#39;).trace().parent()
Complex Field with 1000 bits of precision
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.ptolemy_generalized_obstruction_classes">
<code class="descname">ptolemy_generalized_obstruction_classes</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.ptolemy_generalized_obstruction_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the obstruction classes needed to compute
PGL(N,C)-representations for any N, i.e., it returns a list with
a representative cocycle for each element in
H^2(M, boundary M; Z/N) / (Z/N)^* where (Z/N)^* are the units in Z/N.
The first element in the list always corresponds to the trivial
obstruction class.
The generalized ptolemy obstruction classes are thus a generalization
of the ptolemy obstruction classes that allow to find all
boundary-unipotent
PGL(N,C)-representations including those that do not lift to
boundary-unipotent SL(N,C)-representations for N odd or
SL(N,C)/{+1,-1}-representations for N even.</p>
<p>For example, 4_1 has three obstruction classes up to equivalence:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&quot;4_1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_generalized_obstruction_classes</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>For 4_1, we only get three obstruction classes even though we have
H^2(M, boundary M; Z/4) = Z/4 because the two obstruction classes 
1 in Z/4 and -1 in Z/4 are related by a unit and thus give
isomorphic Ptolemy varieties.</p>
<p>The primary use of an obstruction class sigma is to construct the
Ptolemy variety of sigma. This variety computes boundary-unipotent
PGL(N,C)-representations whose obstruction class to a
boundary-unipotent lift to SL(N,C) is sigma.</p>
<p>For example for 4_1, there are 2 obstruction classes for N = 3:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&quot;4_1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_generalized_obstruction_classes</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The Ptolemy variety parametrizing boundary-unipotent
SL(3,C)-representations of 4_1 is obtained by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>and the Ptolemy variety parametrizing boundary-unipotent
PSL(3,C)-representations of 4_1 that do not lift to
boundary-unipotent SL(3,C)-representations is obtained by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The cocycle representing the non-trivial obstruction class looks as
follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">PtolemyGeneralizedObstructionClass([2, 0, 0, 1])</span>
</pre></div>
</div>
<p>This means that the cocycle takes the value -1 in Z/3 on the first face
class and 1 on the fourth face class but zero on every other of the
four face classes.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.ptolemy_obstruction_classes">
<code class="descname">ptolemy_obstruction_classes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.ptolemy_obstruction_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the obstruction classes needed to compute
pSL(N,C) = SL(N,C)/{+1,-1} representations for even N, i.e., it
returns a list with a representative cocycle for each class in
H^2(M, boundary M; Z/2). The first element in the list is always
representing the trivial obstruction class.</p>
<p>For example, 4_1 has two obstruction classes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&quot;4_1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_obstruction_classes</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The primary use of these obstruction classes is to construct
the Ptolemy variety as described in Definition 1.7 of 
Stavros Garoufalidis, Dylan Thurston, Christian K. Zickert:
&#8220;The Complex Volume of SL(n,C)-Representations of 3-Manifolds&#8221;
(<a class="reference external" href="http://arxiv.org/abs/1111.2828">http://arxiv.org/abs/1111.2828</a>).</p>
<p>For example, to construct the Ptolemy variety for 
PSL(2,C)-representations of 4_1 that do not lift to boundary-parabolic
SL(2,C)-representations, use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Or the following short-cut:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that this obstruction class only makes sense for even N:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">PtolemyObstructionClass only makes sense for even N, try PtolemyGeneralizedObstructionClass</span>
</pre></div>
</div>
<p>To obtain PGL(N,C)-representations for N &gt; 2, use the generalized
obstruction class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_generalized_obstruction_classes</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The orginal obstruction class encodes a representing cocycle in Z/2 as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_obstruction_classes</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">PtolemyObstructionClass(s_0_0 + 1, s_1_0 - 1, s_2_0 - 1, s_3_0 + 1, s_0_0 - s_0_1, s_1_0 - s_3_1, s_2_0 - s_2_1, s_3_0 - s_1_1)</span>
</pre></div>
</div>
<p>This means that the cocycle to represent this obstruction class in Z/2
takes value 1 in Z/2 on face 0 of tetrahedra 0 (because s_0_0 = -1)
and value 0 in Z/2 on face 1 of tetrahedra 0 (because s_1_0 = +1).</p>
<p>Face 3 of tetrahedra 0 and face 1 of tetrahedra 1 are identified,
hence the cocycle takes the same value on those two faces (s_3_0 = s_1_1).</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.ptolemy_variety">
<code class="descname">ptolemy_variety</code><span class="sig-paren">(</span><em>N</em>, <em>obstruction_class = None</em>, <em>simplify = True</em>, <em>eliminate_fixed_ptolemys = False</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.ptolemy_variety" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Ptolemy variety as described in</p>
<ul class="simple">
<li>Stavros Garoufalidis, Dyland Thurston, Christian K. Zickert: 
&#8220;The Complex Volume of SL(n,C)-Representations of 3-Manifolds&#8221;
(<a class="reference external" href="http://arxiv.org/abs/1111.2828">http://arxiv.org/abs/1111.2828</a>)</li>
<li>Stavros Garoufalidis, Matthias Goerner, Christian K. Zickert:
&#8220;Gluing Equations for PGL(n,C)-Representations of 3-Manifolds &#8221;
(<a class="reference external" href="http://arxiv.org/abs/1207.6711">http://arxiv.org/abs/1207.6711</a>)</li>
</ul>
<p>The variety can be exported to magma or sage and solved there. The
solutions can be processed to compute invariants. The method can also
be used to automatically look up precomputed solutions from the
database at <a class="reference external" href="http://ptolemy.unhyperbolic.org/data">http://ptolemy.unhyperbolic.org/data</a> .</p>
<p>Example for m011 and PSL(2,C)-representations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&quot;m011&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Obtain all Ptolemy varieties for PSL(2,C)-representations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="s">&#39;all&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>There are two Ptolemy varieties for the two obstruction classes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Retrieve the solutions from the database</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sols</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">retrieve_solutions</span><span class="p">()</span> 
</pre></div>
</div>
<p>Compute the solutions using magma (default in SnapPy)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sols</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">compute_solutions</span><span class="p">(</span><span class="n">engine</span> <span class="o">=</span> <span class="s">&#39;magma&#39;</span><span class="p">)</span> 
</pre></div>
</div>
<p>Compute the solutions using singular (default in sage)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sols</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">compute_solutions</span><span class="p">(</span><span class="n">engine</span> <span class="o">=</span> <span class="s">&#39;sage&#39;</span><span class="p">)</span> 
</pre></div>
</div>
<p>Note that magma is significantly faster.</p>
<p>Compute all resulting complex volumes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cvols</span> <span class="o">=</span> <span class="n">sols</span><span class="o">.</span><span class="n">complex_volume_numerical</span><span class="p">()</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">cvols</span>  
<span class="go">[[[-4.29405713186238 E-16 + 0.725471193740844*I,</span>
<span class="go">   -0.942707362776931 + 0.459731436553693*I,</span>
<span class="go">   0.942707362776931 + 0.459731436553693*I]],</span>
<span class="go"> [[3.94159248086745 E-15 + 0.312682687518267*I,</span>
<span class="go">   4.64549527022581 E-15 + 0.680993020093457*I,</span>
<span class="go">   -2.78183391239608 - 0.496837853805869*I,</span>
<span class="go">   2.78183391239608 - 0.496837853805869*I]]]</span>
</pre></div>
</div>
<p>Show complex volumes as a non-nested list:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cvols</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> 
<span class="go">[-4.29405713186238 E-16 + 0.725471193740844*I,</span>
<span class="go"> -0.942707362776931 + 0.459731436553693*I,</span>
<span class="go"> 0.942707362776931 + 0.459731436553693*I,</span>
<span class="go"> 3.94159248086745 E-15 + 0.312682687518267*I,</span>
<span class="go"> 4.64549527022581 E-15 + 0.680993020093457*I,</span>
<span class="go"> -2.78183391239608 - 0.496837853805869*I,</span>
<span class="go"> 2.78183391239608 - 0.496837853805869*I]</span>
</pre></div>
</div>
<p>For more examples, go to <a class="reference external" href="http://ptolemy.unhyperbolic.org/">http://ptolemy.unhyperbolic.org/</a></p>
<p>=== Optional Arguments ===</p>
<p>obstruction_class &#8212; class from Definiton 1.7 of (1).
None for trivial class or a value returned from ptolemy_obstruction_classes.
Short cuts: obstruction_class = &#8216;all&#8217; returns a list of Ptolemy varieties
for each obstruction. For easier iteration, can set obstruction_class to 
an integer.</p>
<p>simplify &#8212; boolean to indicate whether to simplify the equations which
significantly reduces the number of variables.
Simplifying means that several identified Ptolemy coordinates x = y = z = ...
are eliminated instead of adding relations x - y = 0, y - z = 0, ...</p>
<p>eliminate_fixed_ptolemys &#8212; boolean to indicate whether to eliminate
the Ptolemy coordinates that are set to 1 for fixing the decoration.
Even though this simplifies the resulting representation, setting it to
True can cause magma to run longer when finding a Groebner basis.</p>
<p>=== Examples for 4_1 ===</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&quot;4_1&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Get the varieties for all obstruction classes at once (use
help(varieties[0]) for more information):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">varieties</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="s">&quot;all&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Print the variety as an ideal (sage object) for the non-trivial class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">varieties</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ideal</span>    
<span class="go">Ideal (-c_0011_0^2 + c_0011_0*c_0101_0 + c_0101_0^2, -c_0011_0^2 - c_0011_0*c_0101_0 + c_0101_0^2, c_0011_0 - 1) of Multivariate Polynomial Ring in c_0011_0, c_0101_0 over Rational Field                                                       </span>
</pre></div>
</div>
<p>Print the equations of the variety for the non-trivial class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">eqn</span> <span class="ow">in</span> <span class="n">varieties</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">equations</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">eqn</span><span class="p">)</span>          
<span class="go">     - c_0011_0 * c_0101_0 + c_0011_0^2 + c_0101_0^2</span>
<span class="go">     c_0011_0 * c_0101_0 - c_0011_0^2 - c_0101_0^2</span>
<span class="go">     - 1 + c_0011_0</span>
</pre></div>
</div>
<p>Generate a magma file to compute Primary Decomposition for N = 3:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">to_magma</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;ring and ideal&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>     
<span class="go">R&lt;c_0012_0, c_0012_1, c_0102_0, c_0111_0, c_0201_0, c_1011_0, c_1011_1, c_1101_0&gt; := PolynomialRing(RationalField(), 8, &quot;grevlex&quot;);</span>
<span class="go">MyIdeal := ideal&lt;R |</span>
<span class="go">          c_0012_0 * c_1101_0 + c_0102_0 * c_0111_0 - c_0102_0 * c_1011_0,</span>
<span class="go">    ...</span>
</pre></div>
</div>
<p>=== If you have a magma installation ===</p>
<p>Call p.compute_solutions() to automatically call magma on the above output
and produce exact solutions!!!</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">sols</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">compute_solutions</span><span class="p">()</span>
<span class="gp">... </span><span class="k">except</span><span class="p">:</span>
<span class="gp">... </span>    <span class="c"># magma failed, use precomputed_solutions</span>
<span class="gp">... </span>    <span class="n">sols</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>
</div>
<p>Check solutions against manifold
&gt;&gt;&gt; if sols:
...     dummy = sols.check_against_manifold()</p>
<p>=== If you do not have a magma installation ===</p>
<p>Load a precomputed example from magma which is provided with the package:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">snappy.ptolemy.processMagmaFile</span> <span class="kn">import</span> <span class="n">_magma_output_for_4_1__sl3</span><span class="p">,</span> <span class="n">solutions_from_magma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">_magma_output_for_4_1__sl3</span><span class="p">)</span>      

<span class="go">==TRIANGULATION=BEGINS==</span>
<span class="go">% Triangulation</span>
<span class="go">4_1</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>Parse the file and produce solutions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sols</span> <span class="o">=</span> <span class="n">solutions_from_magma</span><span class="p">(</span><span class="n">_magma_output_for_4_1__sl3</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dummy</span> <span class="o">=</span> <span class="n">sols</span><span class="o">.</span><span class="n">check_against_manifold</span><span class="p">()</span>
</pre></div>
</div>
<p>=== Continue here whether you have or do not have magma ===</p>
<p>Pick the first solution of the three different solutions (up to Galois
conjugates):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">sols</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solution</span> <span class="o">=</span> <span class="n">sols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Read the exact value for c_1020_0 (help(solution) for more information
on how to compute cross ratios, volumes and other invariants):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;c_1020_0&#39;</span><span class="p">]</span>
<span class="go">Mod(-1/2*x - 3/2, x^2 + 3*x + 4)</span>
</pre></div>
</div>
<p>Example of simplified vs non-simplified variety for N = 4:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">simplified</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">full</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">ptolemy_variety</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">obstruction_class</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">simplify</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">simplified</span><span class="o">.</span><span class="n">variables</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">full</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
<span class="go">(21, 63)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">simplified</span><span class="o">.</span><span class="n">equations</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">full</span><span class="o">.</span><span class="n">equations</span><span class="p">)</span>
<span class="go">(24, 72)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.randomize">
<code class="descname">randomize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.randomize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform random Pachner moves on the underlying triangulation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;Braid:[1,2,-3,-3,1,2]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">randomize</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.reverse_orientation">
<code class="descname">reverse_orientation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.reverse_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverses the orientation of the Triangulation, presuming that
it is orientable.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cs</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">reverse_orientation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">cs</span> <span class="o">+</span> <span class="n">M</span><span class="o">.</span><span class="n">chern_simons</span><span class="p">()),</span> <span class="mi">15</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.save">
<code class="descname">save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the triangulation as a SnapPea triangulation file.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&#39;fig-eight.tri&#39;</span><span class="p">)</span>     
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.set_name">
<code class="descname">set_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Give the triangulation a new name.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;4_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">&#39;figure-eight-comp&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">figure-eight-comp(0,0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.set_peripheral_curves">
<code class="descname">set_peripheral_curves</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.set_peripheral_curves" title="Permalink to this definition">¶</a></dt>
<dd><p>Each cusp has a preferred marking. In the case of a torus
cusp, this is pair of essential simple curves meeting in one
point; equivalently, a basis of the first homology of the
boundary torus. These curves are called the meridian and the
longitude.</p>
<p>This method changes these markings in various ways.  In many
cases, if the flag return_matrices is True then it returns
a list of change-of-basis matrices is returned, one per
cusp, which will restore the original markings if passed
as peripheral_data.</p>
<ul>
<li><p class="first">Make the shortest curves the meridians, and the second
shortest curves the longitudes.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;5_2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s">&#39;shape&#39;</span><span class="p">)</span>
<span class="go">[-2.49024467 + 2.97944707*I]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cob</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span><span class="s">&#39;shortest&#39;</span><span class="p">,</span> <span class="n">return_matrices</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s">&#39;shape&#39;</span><span class="p">)</span>
<span class="go">[-0.49024467 + 2.97944707*I]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cob</span>
<span class="go">[[[1, 0], [-2, 1]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span><span class="n">cob</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">cusp_info</span><span class="p">(</span><span class="s">&#39;shape&#39;</span><span class="p">)</span>
<span class="go">[-2.49024467 + 2.97944707*I]</span>
</pre></div>
</div>
<p>You can also make just the meridians as short as 
possible while fixing the longitudes via the option
&#8216;shortest_meridians&#8217;, and conversely with
&#8216;shortest_longitudes&#8217;.</p>
</li>
<li><p class="first">If cusps are Dehn filled, make those curves meridians.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m125(0,0)(2,5)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span><span class="s">&#39;fillings&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">m125(0,0)(1,0)</span>
</pre></div>
</div>
</li>
<li><p class="first">Change the basis of a particular cusp, say the first one:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span> <span class="p">[</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">]</span> <span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Here (1,2) is the new meridian written in the old basis, and
(1,3) the new longitude.</p>
</li>
<li><p class="first">Change the basis of all the cusps at once</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">new_curves</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span>  <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_peripheral_curves</span><span class="p">(</span><span class="n">new_curves</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span>
<span class="go">m125(0,0)(-1,-2)</span>
</pre></div>
</div>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.set_target_holonomy">
<code class="descname">set_target_holonomy</code><span class="sig-paren">(</span><em>target</em>, <em>which_cusp=0</em>, <em>recompute=True</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.set_target_holonomy" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a geometric structure in which the Dehn filling curve
on the specified cusp has holonomy equal to the target value.
The holonomies of Dehn filling curves on other cusps are left
unchanged.  If the &#8216;recompute&#8217; flag is False, the Dehn filling
equations are modified, but not solved.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.set_tetrahedra_shapes">
<code class="descname">set_tetrahedra_shapes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.set_tetrahedra_shapes" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces the tetrahedron shapes with those in the given lists,
and sets the Dehn filling coefficients as specified by the
fillings argument.  The shapes will get double precision
values; polishing will be needed for high precision shapes.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.simplify">
<code class="descname">simplify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to simplify the triangulation by doing Pachner moves.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;12n123&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.solution_type">
<code class="descname">solution_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.solution_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of the current solution to the gluing
equations, basically a summary of how degenerate the solution
is.  If the flag enum=True is set, then an integer value is
returned. The possible answers are:</p>
<ul class="simple">
<li>0: &#8216;not attempted&#8217;</li>
<li>1: &#8216;all tetrahedra positively oriented&#8217; aka &#8216;geometric_solution&#8217;
Should correspond to a genuine hyperbolic structure</li>
<li>2: &#8216;contains negatively oriented tetrahedra&#8217; aka &#8216;nongeometric_solution&#8217;
Probably correponds to a hyperbolic structure but some
simplices have reversed orientiations.</li>
<li>3: &#8216;contains flat tetrahedra&#8217; Contains some tetrahedra with
shapes in R - {0, 1}.</li>
<li>4: &#8216;contains degenerate tetrahedra&#8217; Some shapes are close to
{0,1, or infinity}.</li>
<li>5: &#8216;unrecognized solution type&#8217;</li>
<li>6: &#8216;no solution found&#8217;</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m007&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">solution_type</span><span class="p">()</span>
<span class="go">&#39;all tetrahedra positively oriented&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">solution_type</span><span class="p">()</span>
<span class="go">&#39;contains negatively oriented tetrahedra&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">solution_type</span><span class="p">()</span>
<span class="go">&#39;contains degenerate tetrahedra&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.split">
<code class="descname">split</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the manifold open along a surface of positive characteristic found
by the method &#8220;splitting_surfaces&#8221;.  Returns a list of the pieces, with any 
sphere boundary components filled in.</p>
<p>Here&#8217;s an example of a Whitehead double on the trefoil.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;K14n26039&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">splitting_surfaces</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>
<span class="go">Orientable two-sided with euler = 0</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pieces</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">S</span><span class="p">);</span> <span class="n">pieces</span>
<span class="go">[K14n26039.a(0,0)(0,0), K14n26039.b(0,0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
<span class="go">3.66386238</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pieces</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span><span class="o">.</span><span class="n">relators</span><span class="p">()</span>
<span class="go">[&#39;aabbb&#39;]</span>
</pre></div>
</div>
<p>You can also specify a surface by its index.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;L10n111&#39;</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span> <span class="n">P</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
<span class="go">5.33348957</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.splitting_surfaces">
<code class="descname">splitting_surfaces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.splitting_surfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for connected closed normal surfaces of nonnegative Euler
characteristic.  If spheres or projective planes are found, then
tori and Klein bottles aren&#8217;t reported.  There is no guarantee
that all such normal surfaces will be found nor that any given
surface is incompressible.  The search is confined to surfaces
whose quads are in the tetrahedra that have degenerate shapes.</p>
<p>You can split the manifold open along one of these surfaces
using the method &#8220;split&#8221;.</p>
<p>A connect sum of two trefoils:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M1</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;DT: fafBCAEFD&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">M1</span><span class="o">.</span><span class="n">splitting_surfaces</span><span class="p">())</span>
<span class="go">2</span>
</pre></div>
</div>
<p>First satellite knot in the table.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M2</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;K13n4587&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M2</span><span class="o">.</span><span class="n">splitting_surfaces</span><span class="p">()</span>
<span class="go">[Orientable two-sided with euler = 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.symmetric_triangulation">
<code class="descname">symmetric_triangulation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.symmetric_triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Dehn filling description of the manifold realizing
the symmetry group.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m003(-3,1)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">symmetry_group</span><span class="p">()</span>
<span class="go">D6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">symmetric_triangulation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span>
<span class="go">m003(1,0)(1,0)(1,0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">dehn_fill</span><span class="p">(</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">symmetry_group</span><span class="p">(</span><span class="n">of_link</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">D6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.symmetry_group">
<code class="descname">symmetry_group</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.symmetry_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the symmetry group of the Manifold.
If the flag &#8220;of_link&#8221; is set, then it only returns symmetries
that preserves the meridians.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.tetrahedra_field_gens">
<code class="descname">tetrahedra_field_gens</code><span class="sig-paren">(</span><em>manifold</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.tetrahedra_field_gens" title="Permalink to this definition">¶</a></dt>
<dd><p>The shapes of the tetrahedra as ApproximateAlgebraicNumbers. Can be
used to compute the tetrahedra field, where the first two parameters
are bits of precision and maximum degree of the field:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&#39;m015&#39;)
sage: tets = M.tetrahedra_field_gens()
sage: tets.find_field(100, 10, optimize=True)    # doctest: +NORMALIZE_WHITESPACE
(Number Field in z with defining polynomial x^3 - x - 1,
&lt;ApproxAN: -0.662358978622 - 0.562279512062*I&gt;, [-z, -z, -z])
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.tetrahedra_shapes">
<code class="descname">tetrahedra_shapes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.tetrahedra_shapes" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the shapes of the tetrahedra in the current solution to
the gluing equations.  Returns a list containing one info object
for each tetrahedron.  The keys are:</p>
<ul class="simple">
<li>rect : the shape of the tetrahedron, as a point in the
complex plane.</li>
<li>log : the log of the shape</li>
<li>accuracies: a list of the approximate accuracies of the
shapes, in order (rect re, rect im, log re, log im)</li>
</ul>
<p>If the optional variable &#8216;part&#8217; is set to one of the above,
then the function returns only that component of the data.</p>
<p>If the flag &#8216;fixed_alignment&#8217; is set to False, then the edges
used to report the shape parameters are choosen so as to
normalize the triangle.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m015&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">tetrahedra_shapes</span><span class="p">(</span><span class="n">part</span><span class="o">=</span><span class="s">&#39;rect&#39;</span><span class="p">)</span>
<span class="go">[0.66235898 + 0.56227951*I, 0.66235898 + 0.56227951*I, 0.66235898 + 0.56227951*I]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">tetrahedra_shapes</span><span class="p">()</span> 
<span class="go">[{&#39;accuracies&#39;: (11, 11, 12, 11), &#39;log&#39;: -0.14059979 + 0.70385772*I, &#39;rect&#39;: 0.66235898 + 0.56227951*I},</span>
<span class="go"> {&#39;accuracies&#39;: (11, 11, 11, 11), &#39;log&#39;: -0.14059979 + 0.70385772*I, &#39;rect&#39;: 0.66235898 + 0.56227951*I},</span>
<span class="go"> {&#39;accuracies&#39;: (11, 11, 11, 11), &#39;log&#39;: -0.14059979 + 0.70385772*I, &#39;rect&#39;: 0.66235898 + 0.56227951*I}]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.trace_field_gens">
<code class="descname">trace_field_gens</code><span class="sig-paren">(</span><em>manifold</em>, <em>fundamental_group_args=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.trace_field_gens" title="Permalink to this definition">¶</a></dt>
<dd><p>The generators of the trace field as ApproximateAlgebraicNumbers. Can be
used to compute the tetrahedra field, where the first two parameters
are bits of precision and maximum degree of the field:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&#39;m125&#39;)
sage: traces = M.trace_field_gens()
sage: traces.find_field(100, 10, optimize=True)    # doctest: +NORMALIZE_WHITESPACE
(Number Field in z with defining polynomial x^2 + 1,
&lt;ApproxAN: -1.0*I&gt;, [z + 1, -z, -z - 1])
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.use_field_conversion">
<code class="descname">use_field_conversion</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.use_field_conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>A class method for specifying a numerical conversion function.</p>
<p>SnapPy includes its own number type, snappy.Number, which can
represent floating point real or complex numbers of varying
precision.  (In fact, Number is a wrapper for a pari number of
type &#8216;t_INT&#8217;, &#8216;t_FRAC&#8217;, &#8216;t_REAL&#8217; or &#8216;t_COMPLEX&#8217;, and the pari
gen can be extracted as an attribute: x.gen .)  Methods of
SnapPy objects which return numerical values will first compute
the value as a Number, and then optionally convert the Number
to a different numerical type which can be specified by calling
this class method.</p>
<p>By default SnapPy returns Numbers when loaded into python, and
elements of a Sage RealField or ComplexField when loaded into
Sage.  These will be 64 bit numbers for ordinary Manifolds and
212 bit numbers for high precision manifolds.</p>
<p>The func argument should be a function which accepts a number and
returns a numerical type of your choosing.  Alternatively, the
strings &#8216;sage&#8217; or &#8216;snappy&#8217; can be passed as arguments to select
either of the two default behaviors.</p>
<p>EXAMPLE:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&#39;m004&#39;)
sage: parent(M.volume())
Real Field with 64 bits of precision
sage: Manifold.use_field_conversion(&#39;snappy&#39;)
sage: M = Manifold(&#39;m004&#39;)
sage: parent(M.volume())
SnapPy Numbers with 64 bits precision
sage: Manifold.use_field_conversion(&#39;sage&#39;)
sage: M = Manifold(&#39;m004&#39;)
sage: parent(M.volume())
Real Field with 64 bits of precision
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.verify_hyperbolicity">
<code class="descname">verify_hyperbolicity</code><span class="sig-paren">(</span><em>manifold</em>, <em>verbose=False</em>, <em>bits_prec=53</em><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.verify_hyperbolicity" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an orientable SnapPy Manifold, verifies its hyperbolicity.
Similar to HIKMOT&#8217;s verify_hyperbolicity, the result is either
(True, listOfShapeIntervals) or (False, []) if verification failed.
listOfShapesIntervals is a list of complex intervals (elements in
sage&#8217;s ComplexIntervalField) certified to contain the true shapes
for the hyperbolic manifold.</p>
<p>Higher precision intervals can be obtained by setting bits_prec:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: from snappy import Manifold
sage: M = Manifold(&quot;m019&quot;)
sage: verify_hyperbolicity(M)
(True, [0.7805525278508? + 0.9144736629678?*I, 0.7805525278508? + 0.91447366296773?*I, 0.46002117557372? + 0.63262419360526?*I])

sage: M = Manifold(&quot;t02333(3,4)&quot;)
sage: verify_hyperbolicity(M)
(True, [2.152188153612? + 0.28494066790?*I, 1.92308491369? + 1.10360701507?*I, 0.014388591584? + 0.143084469681?*I, -2.5493670288? + 3.7453498408?*I, 0.142120333822? + 0.176540027036?*I, 0.50486686588? + 0.82829881681?*I, 0.50479249917? + 0.98036162786?*I, -0.58949570508? + 0.81267480427?*I])
</pre></div>
</div>
<p>A non-hyperbolic manifold:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = Manifold(&quot;t02333(1,0)&quot;)
sage: verify_hyperbolicity(M)
(False, [])
</pre></div>
</div>
<p>Under the hood, the function will call the CertifiedShapesEngine to produce
intervals certified to contain a solution to the rectangular gluing equations.
It then calls check_logarithmic_gluing_equations_and_positively_oriented_tets
to verify that the logarithmic gluing equations are fulfilled and that all
tetrahedra are positively oriented.</p>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.volume">
<code class="descname">volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the volume of the current solution to the hyperbolic
gluing equations; if the solution is sufficiently non-degenerate,
this is the sum of the volumes of the hyperbolic pieces in
the geometric decomposition of the manifold.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
<span class="go">2.02988321</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">solution_type</span><span class="p">()</span>
<span class="go">&#39;all tetrahedra positively oriented&#39;</span>
</pre></div>
</div>
<p>The return value has an extra attribute, accuracy, which is the
number of digits of accuracy as <em>estimated</em> by SnapPea.  When
printing the volume, the result is rounded to 1 more than this
number of digits.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span><span class="o">.</span><span class="n">accuracy</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">63</span><span class="p">)</span> <span class="c"># Low precision, High precision</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.with_hyperbolic_structure">
<code class="descname">with_hyperbolic_structure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.with_hyperbolic_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a (possibly degenerate) hyperbolic structure, turning the
Triangulation into a Manifold.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="s">&#39;m004&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">with_hyperbolic_structure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
<span class="go">2.02988321</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="snappy.Manifold.without_hyperbolic_structure">
<code class="descname">without_hyperbolic_structure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#snappy.Manifold.without_hyperbolic_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self as a Triangulation, forgetting the hyperbolic
structure in the process.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">(</span><span class="s">&#39;9_42&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">without_hyperbolic_structure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="s">&#39;volume&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="snappy.html"
                        title="previous chapter">The snappy module and its classes</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="manifoldhp.html"
                        title="next chapter">ManifoldHP: High-precision variant</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/manifold.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="manifoldhp.html" title="ManifoldHP: High-precision variant"
             >next</a> |</li>
        <li class="right" >
          <a href="snappy.html" title="The snappy module and its classes"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SnapPy 2.3 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="snappy.html" >The snappy module and its classes</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2009-2015, by Marc Culler, Nathan Dunfield, Jeffrey Weeks and others.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>