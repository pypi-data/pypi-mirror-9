#!/usr/bin/env python

import argparse
import distutils.spawn
import imp
import os
import sys
import tempfile

# retrieved from bin/ansible-playbook
local_module_path = os.path.abspath(
    os.path.join(os.path.dirname(__file__), '..', 'lib')
)
sys.path.append(local_module_path)

from ansible import runner
from ansible import errors
from ansible.utils import plugins
from ansible.callbacks import display

from ansibledebugger import __version__
from ansibledebugger import action_plugin_wrapper
from ansibledebugger import runner_wrapper
from ansibledebugger import utils


def main(args):
    """Wrap some funcs so that a debugger is invoked, then run ansible-playbook"""
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('--version', action='version', version='%(prog)s ' + __version__)
    parser.parse_known_args()

    dummy_runner = runner.Runner(host_list=[])
    action_loader = plugins.action_loader
    action_plugins = list(action_loader.all(dummy_runner))

    for action_plugin in action_plugins:
        wrapper = action_plugin_wrapper.ActionPluginWrapper()
        wrapper.wrap(action_plugin.__class__)

    wrapper = runner_wrapper.RunnerWrapper()
    wrapper.wrap(runner.Runner)

    ansibleplaybook_path = distutils.spawn.find_executable("ansible-playbook")
    if not ansibleplaybook_path:
        raise errors.AnsibleError("Failed to find 'ansible-playbook' script in PATH")
    ansibleplaybook = imp.load_source('ansibledebugger', ansibleplaybook_path)
    return ansibleplaybook.main(args)

if __name__ == "__main__":
    display(" ", log_only=True)
    display(" ".join(sys.argv), log_only=True)
    display(" ", log_only=True)
    try:
        sys.exit(main(sys.argv[1:]))
    except errors.AnsibleError, e:
        display("ERROR: %s" % e, color='red', stderr=True)
        sys.exit(1)
    except KeyboardInterrupt, ke:
        display("ERROR: interrupted", color='red', stderr=True)
        sys.exit(1)
