{"name":"django-ajax","tagline":"Fast and easy AJAX libraries for django projects. Contains ajax decorator, ajax middleware, shortcuts, jquery plugins and more.","body":"# django-ajax\r\n\r\nFast and easy AJAX libraries for django projects.\r\n\r\n## Requirements\r\n\r\n* [python](http://www.python.org) >= 2.6\r\n* [django](https://djangoproject.com) >= 1.3\r\n* [jQuery](http://jquery.com) >= 1.5\r\n\r\n## Installation\r\n\r\nInstall django-ajax in your python environment\r\n\r\n1- Download and install package:\r\n\r\n```sh\r\n$ pip install djangoajax\r\n```\r\n\r\nThrough Github:\r\n\r\n```sh\r\npip install -e git://github.com/yceruto/django-ajax#egg=django-ajax\r\n```\r\n\r\nor simply with:\r\n\r\n```sh\r\n$ python setup.py install\r\n```\r\n\r\n2- Add `'django_ajax'` into the `INSTALLED_APPS` list.\r\n\r\n3- Read usage section and enjoy its advantages!\r\n\r\n\r\n## Usage\r\n\r\n### @ajax Decorator\r\n\r\n```python\r\n    from django_ajax.decorators import ajax\r\n\r\n    @ajax\r\n    def my_view(request)\r\n        do_something()\r\n```\r\n        \r\nWhen nothing is returned as result of view then returns (JSON format):\r\n\r\n```javascript\r\n    {\"status\": 200, \"statusText\": \"OK\", \"content \": null}\r\n```\r\n\r\n#### Sending custom data in the response\r\n\r\n```python\r\n    @ajax\r\n    def my_view(request):\r\n        c = 2 + 3\r\n        return {'result': c}\r\n```\r\n\r\nThe result is send to the browser in the following way (JSON format)\r\n\r\n```javascript\r\n    {\"status\": 200, \"statusText\": \"OK\", \"content\": {\"result\": 5}}\r\n```\r\n\r\n#### Combining with others decorators\r\n\r\n```python\r\n    from django.contrib.auth.decorators import login_required\r\n    from django_ajax.decorators import ajax\r\n\r\n    @ajax\r\n    @login_required\r\n    def my_view(request):\r\n        # if the request.user is anonymous then this view not proceed \r\n        return {'user_id': request.user.id}\r\n```\r\n\r\nThe JSON response:\r\n\r\n```javascript\r\n    {\"status\": 302, \"statusText\": \"FOUND\", \"content\": \"/login\"}\r\n```\r\n\r\n#### Template response\r\n\r\n```python\r\n    from django.shortcuts import render\r\n    from django_ajax.decorators import ajax\r\n\r\n    @ajax\r\n    def my_view(request):\r\n        return render(request, 'home.html')\r\n```\r\n\r\nThe JSON response:\r\n\r\n```javascript\r\n    {\"status\": 200, \"statusText\": \"OK\", \"content\": \"<html>...</html>\"}\r\n```\r\n\r\n#### Catch exceptions\r\n\r\n```python\r\n    @ajax\r\n    def my_view(request):\r\n        a = 23 / 0  # this line throws an exception\r\n        return a\r\n```\r\n\r\nThe JSON response:\r\n\r\n```javascript\r\n    {\"status\": 500, \"statusText\": \"INTERNAL SERVER ERROR\", \"content\": \"integer division or modulo by zero\"}\r\n```\r\n\r\n### AJAXMiddleware\r\n\r\nIf you use AJAX quite frequently in your project, we suggest using the AJAXMiddleware described below.\r\n\r\nAdd `django_ajax.middleware.AJAXMiddleware` into the `MIDDLEWARE_CLASSES` list in `settings.py`.\r\n\r\nAll your responses will be converted to JSON if the request was made by AJAX, otherwise is return a HttpResponse.\r\n\r\n> **Caution**\r\n> If you use this middleware cannot use `@ajax` decorator.\r\n\r\n\r\n### AJAXMixin for class-based views\r\n\r\n`AJAXMixin` is an object that calls the AJAX decorator.\r\n\r\n```python\r\n    from django.views.generic import TemplateView\r\n    from django_ajax.mixin import AJAXMixin\r\n\r\n    class SimpleView(AJAXMixin, TemplateView):\r\n        template_name = 'home.html'\r\n```\r\n\r\nThe JSON response:\r\n\r\n```javascript\r\n    {\"status\": 200, \"statusText\": \"OK\", \"content\": \"<html>...</html>\"}\r\n```\r\n\r\n### AJAX on client side\r\n\r\nInclude `jquery.ajax.min.js` into `base.html` template:\r\n\r\n```html\r\n    <script type=\"text/javascript\" src=\"{% static 'django_ajax/js/jquery.ajax.min.js' %}\"></script>\r\n```\r\n\r\nCall to AJAX request using the `ajaxPost` or `ajaxGet` functions:\r\n\r\n```html\r\n    <script type=\"text/javascript\">\r\n        ajaxPost('/save', {'foo': 'bar'}, function(content){\r\n            //onSuccess\r\n            alert(content);\r\n        })\r\n    </script>\r\n```\r\n\r\nor\r\n\r\n```html\r\n    <script type=\"text/javascript\">\r\n        ajaxGet('/', function(content){\r\n            //onSuccess\r\n            alert(content);\r\n        })\r\n    </script>\r\n```\r\n\r\nIf the response is not successful, itÂ´s shown an alert with the message appropriated.\r\n\r\n### AJAX plugin Based on [eldarion-ajax](https://github.com/eldarion/eldarion-ajax)\r\n\r\nInclude `jquery.ajax-plugin.min.js` into `base.html` template:\r\n\r\n```html\r\n    <script type=\"text/javascript\" src=\"{% static 'django_ajax/js/jquery.ajax-plugin.min.js' %}\"></script>\r\n```\r\n\r\nIn this moment any tag with the attribute `data-ajax` will be controlled by ajax plugin. Each request is sent using AJAX and the response will be handle on JSON format.\r\n\r\nThe value of the attribute `data-success` will be used as callback function if the request is successful. This function is called with an argument that represent the content response:\r\n\r\n```html\r\n    <a href=\"/hello-world/\" class=\"btn btn-primary\" data-ajax=\"true\" data-success=\"processResponse\">Show Alert</a>\r\n```\r\n\r\nWhere \"processResponse\" in this case is a callback function:\r\n\r\n```html\r\n   <script type=\"text/javascript\">\r\n        function processResponse(content) {\r\n            do_something(content);\r\n        }\r\n    </script>\r\n```\r\n\r\n#### Process fragments\r\n\r\nInspired on [eldarion-ajax](https://github.com/eldarion/eldarion-ajax) the data\r\nreceived by the names `'fragments'`, `'inner-fragments'`, `'append-fragments'`\r\nor `'prepend-fragments'` will be processed by default, unless you pass in the\r\nrequest the option \"process-fragments\" equal false. Here's an example:\r\n\r\n```python\r\n    @ajax\r\n    def fragments_view(request):\r\n        data = {\r\n            'fragments': {\r\n                '#id1': 'replace element with this content1'\r\n            },\r\n            'inner-fragments': {\r\n                '#id2': 'replace inner content'\r\n            },\r\n            'append-fragments': {\r\n                '.class1': 'append this content'\r\n            },\r\n            'prepend-fragments': {\r\n                '.class2': 'prepend this content'\r\n            }\r\n        }\r\n        return data\r\n```\r\n\r\nThese data are sent in response:\r\n\r\n```javascript\r\n    {\"status\": 200, \"statusText\": \"OK\", \"content\": {\r\n            \"fragments\": {\"#id1\": \"replace element with this content1\"},\r\n            \"inner-fragments\": {\"#id2\": \"replace inner content\"},\r\n            \"append-fragments\": {\".class1\": \"append this content\"},\r\n            \"prepend-fragments\": {\".class2\": \"prepend this content\"}\r\n        }}\r\n```\r\n\r\nThen, using AJAX (`ajax`, `ajaxPost` or `ajaxGet`) functions these fragments to be processed automatically before calling to success function.\r\n\r\n```html\r\n   <script type=\"text/javascript\">\r\n        function fragments() {\r\n            ajaxGet('/fragments-view-url', function(content){\r\n                alert('The fragments was processed successfully!');\r\n            });\r\n        }\r\n    </script>\r\n```\r\n\r\nIf you do not want to process the fragments never, modify the AJAX configuration\r\nthat comes by default:\r\n\r\n```html\r\n    <script type=\"text/javascript\">\r\n        ajax.DEFAULTS[\"process-fragments\"] = false; //true by default\r\n    </script>\r\n```\r\n\r\nor as option on the request:\r\n\r\n```html\r\n    <script type=\"text/javascript\">\r\n        function fragments() {\r\n            ajaxGet('/fragments-view-url', function(content){\r\n                do_something_with(content.fragments);\r\n            }, {\"process-fragments\": false});\r\n        }\r\n    </script>\r\n```\r\n\r\n### Enjoy!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}