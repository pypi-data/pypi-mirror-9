# Copyright 2006-2012 Brian Harring <ferringb@gmail.com>
# License GPL2/BSD3

# Internal logging function, don't use this in ebuilds
__elog_base() {
	local messagetype
	[[ -z $1 || -z ${T} || ! -d ${T}/logging ]] && return 1
	case $1 in
		INFO|WARN|ERROR|LOG|QA)
			messagetype=$1
			shift
			;;
		*)
			echo -e " ${PKGCORE_RC_BAD}*${PKGCORE_RC_NORMAL} Invalid use of internal function __elog_base(), next message will not be logged" >&2
			return 1
			;;
	esac
	echo "$*" >> "${T}/logging/${EBUILD_PHASE}.${messagetype}"
	return 0
}

__colored_output_disable() {
	PKGCORE_RC_COLS="25 80"
	PKGCORE_RC_ENDCOL=
	PKGCORE_RC_GOOD=
	PKGCORE_RC_WARN=
	PKGCORE_RC_BAD=
	PKGCORE_RC_NORMAL=
	PKGCORE_RC_HILITE=
	PKGCORE_RC_BRACKET=
} &> /dev/null

__colored_output_enable() {
	# try setting the column width to bash's internal COLUMNS variable,
	# then try to get it via stty.  no go? hardcode it to 80.
	PKGCORE_RC_COLS=${COLUMNS:-0}
	if (( PKGCORE_RC_COLS <= 0 )); then
		PKGCORE_RC_COLS=$(set -- $(stty size 2>/dev/null) ; echo ${2:-0})
		if (( PKGCORE_RC_COLS <= 0 )); then
			PKGCORE_RC_COLS=80
		fi
	fi
	export COLUMNS=${PKGCORE_RC_COLS}
	PKGCORE_RC_COLS=$(( PKGCORE_RC_COLS - 8 )) # width of [ ok ] == 7

	export PKGCORE_RC_ENDCOL=$'\e[A\e['${PKGCORE_RC_COLS}'C'
	# Now, ${PKGCORE_RC_ENDCOL} will move us to the end of the
	# column;  irregardless of character width

	export PKGCORE_RC_GOOD=$'\e[32;01m'
	export PKGCORE_RC_WARN=$'\e[33;01m'
	export PKGCORE_RC_BAD=$'\e[31;01m'
	export PKGCORE_RC_HILITE=$'\e[36;01m'
	export PKGCORE_RC_BRACKET=$'\e[34;01m'
	export PKGCORE_RC_NORMAL=$'\e[0m'
} &> /dev/null

__safe_has() {
	# Version of has, only to be used when the invoker knows that that
	# the needle/targets will never have \001 in them
	local needle=$1
	shift
	local IFS=$'\001'
	[[ "${IFS}${*}${IFS}" == *"${IFS}${needle}${IFS}"* ]]
}

__feature_is_enabled() {
	local IFS=$' \t\n'
	__safe_has "$1" ${FEATURES}
} &> /dev/null


__is_function() {
	declare -F "$1" &> /dev/null
} &> /dev/null

__run_function_if_exists() {
	__is_function "$1" || return 0
	"$@"
}

__qa_run_function_if_exists() {
	__is_function "$1" || return 0
	__qa_invoke "$@"
}

__directory_is_empty() {
	__shopt_push -s dotglob nullglob
	local files=( ${1}/* )
	__shopt_pop
	[[ ${#files[@]} -gt 0 ]] && return 1
	return 0
}

__strip_duplicate_slashes() {
	if [[ -n $1 ]]; then
		local removed=$1
		while [[ ${removed} == *//* ]]; do
			removed=${removed//\/\///}
		done
		echo "${removed}"
	fi
}

__get_func_code() {
	__IFS_push $'\n'
	local code=( $(declare -f "$1") )
	__IFS_pop

	[[ -z ${code[@]} ]] && return

	# drop function name and surrounding brackets
	code=( ${code[@]:2:${#code[@]}-3} )
	echo "${code[@]}"
}

__inject_func_code() {
	local funcname=$1 code=$2 line=${3:-0}
	local func_src=() index

	if [[ ${line} -gt 0 ]]; then
		func_src=( $(__get_func_code ${funcname}) )
		if [[ ${line} -gt ${#func_src[@]} ]]; then
			# code injected to line numbers bigger than the what the target function
			# has appends code to the function
			index=${#func_src[@]}
		else
			index=$(( line - 1 ))
		fi
	else
		# code injected to line numbers <= 0 replaces the function code entirely
		# (replacement occurs by default if the line number argument is empty or unset)
		index=0
	fi

	eval "${funcname}() {
		${func_src[@]:0:${index}}
		${code}
		${func_src[@]:${index}:${#func_src[@]}-${index}}
	}" || die "failed evaluating function '${funcname}'"
}

PKGCORE_SHOPT_STACK=()

__shopt_push() {
	PKGCORE_SHOPT_STACK[${#PKGCORE_SHOPT_STACK[@]}]=${BASHOPTS}
	PKGCORE_SHOPT_STACK[${#PKGCORE_SHOPT_STACK[@]}]=$-
	if [[ $1 == -[su] ]]; then
		# shopt modification
		shopt "$@" || die "bad shopt options: $@"
	elif [[ -n $@ ]]; then
		set "$@" || die "bad set invocation: $@"
	fi
	return 0
} &> /dev/null

__shopt_pop() {
	[[ $# -ne 0 ]] && die "bad invocation of __shopt_pop; no args should be supplied, got $@"
	local count=$(( ${#PKGCORE_SHOPT_STACK[@]} - 1 ))
	[[ ${count} -le 0 ]] && die "bad __shopt_pop invocation; no matching push, stack was empty"

	local set_val=${PKGCORE_SHOPT_STACK[${count}]}
	if [[ $- != ${set_val} ]]; then
		set ${-:++${-}} ${set_val:+-${set_val}} || die "failed enforcing set state of ${set_val}"
	fi
	unset PKGCORE_SHOPT_STACK[${count}]

	count=$(( count - 1 ))

	local previous=${PKGCORE_SHOPT_STACK[${count}]}
	unset PKGCORE_SHOPT_STACK[${count}]
	[[ ${BASHOPTS} == ${previous} ]] && return 0

	local IFS=' '
	local current=${BASHOPTS}
	if [[ -n ${current} ]]; then
		shopt -u ${current//:/ } >&2 || die "failed wiping current shopt settings of ${current}"
	fi
	if [[ -n ${previous} ]]; then
		shopt -s ${previous//:/ } >&2 || die "failed forcing old shopt settings to ${previous}"
	fi
	return 0
} &> /dev/null

declare -a PKGCORE_SAVED_IFS

__IFS_push() {
	PKGCORE_SAVED_IFS[${#PKGCORE_SAVED_IFS[@]}]=${IFS-unset}
	if [[ $1 == unset ]]; then
		unset IFS
	else
		IFS=$1
	fi
	:
}

__IFS_pop() {
	if [[ ${#PKGCORE_SAVED_IFS[@]} -eq 0 ]]; then
		die "__IFS_pop invoked with nothing on the stack..."
	fi
	IFS=${PKGCORE_SAVED_IFS[$(( ${#PKGCORE_SAVED_IFS[@]} - 1 ))]}
	[[ ${IFS} == unset ]] && unset IFS
	unset PKGCORE_SAVED_IFS[$(( ${#PKGCORE_SAVED_IFS[@]} - 1 ))]
	:
}

__qa_invoke() {
	if ${PKGCORE_QA_SUPPRESSED:-false}; then
		"$@"
		return $(( $? ))
	fi
	local pkgcore_should_fail=false
	# save env and shopt settings.
	# in addition, protect the stack from bad pkgcore calls, or bad consumers accessing internals
	local PKGCORE_SAVED_IFS=()
	local PKGCORE_SHOPT_STACK=()

	__IFS_push "${IFS}"
	__shopt_push

	"$@"
	local ret=$?

	if [[ ${#PKGCORE_SAVED_IFS[@]} -ne 1 ]]; then
		echo "QA warning: unbalanced __IFS_push/__IFS_pop detected.  internal error?" \
			" count was ${#PKGCORE_SAVED_IFS[@]}"
		pkgcore_should_fail=true
	fi
	if [[ ${#PKGCORE_SHOPT_STACK[@]} -ne 2 ]]; then
		echo "QA warning: unbalanced __shopt_push/__shopt_pop detected. internal error? count was ${#PKGCORE_SHOPT_STACK[@]}"
		pkgcore_should_fail=true
	fi

	if [[ ${PKGCORE_SAVED_IFS[0]} != ${IFS-unset} ]]; then
		echo "QA WARNING: invocation $@ manipulated IFS to ${IFS}, but didn't restore it to its original value!"
	fi
	__IFS_pop

	# while these echo statements are ugly, written this way to ensure bash does it as a single write-
	# aka, keep it within the size of atomic writes for pipes.
	# relevant for threaded output straight to term
	if [[ ${PKGCORE_SHOPT_STACK[0]} != ${BASHOPTS} ]]; then
		echo "QA warning: shopt modification bled out of invocation $@"$'\n'"          : was ${PKGCORE_SHOPT_STACK[0]}"$'\n'"          : now ${BASHOPTS}" >&2
	fi

	if [[ ${PKGCORE_SHOPT_STACK[1]} != $- ]]; then
		echo "QA warning: set modification bled out of invocation $@"$'\n'"          : was ${PKGCORE_SHOPT_STACK[1]}"$'\n'"          : now $-" >&2
	fi
	__shopt_pop

	${pkgcore_should_fail} && die "invocation $@ modified globals and didn't clean up"
	return $(( ret ))
}

:
