#
# helper code: we define our match tokens
lastval = ''
def monitor(location,value):
    global lastval
    #print 'At %s: %s' % (location,`value`)
    lastval = `value`
    return value


# Begin -- grammar generated by Yapps
import sys, re
import yapps3_compiled_rt as yappsrt

class TypeParserScanner(yappsrt.Scanner):
    patterns = [
        ('([ \t\n\r])', re.compile('([ \t\n\r])')),
        ('container', re.compile('[A-Za-z]+\\(')),
        ('identifier', re.compile('[A-Za-z]+')),
        ('c_c_b', re.compile('\\)')),
        ('o_c_b', re.compile('\\(')),
        ('comma', re.compile('\\,')),
        ('END', re.compile('$')),
    ]
    def __init__(self, str):
        yappsrt.Scanner.__init__(self,None,['([ \t\n\r])'],str)

class TypeParser(yappsrt.Parser):
    Context = yappsrt.Context
    def input(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'input', [])
        base_element = self.base_element(_context)
        p = [base_element]
        while self._peek('END', 'comma') == 'comma':
            comma = self._scan('comma')
            base_element = self.base_element(_context)
            p.append(base_element)
        if self._peek() not in ['END', 'comma']:
            raise yappsrt.SyntaxError(charpos=self._scanner.get_prev_char_pos(), context=_context, msg='Need one of ' + ', '.join(['comma', 'END']))
        END = self._scan('END')
        if len(p)==1: p = p[0]
        return p

    def base_element(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'base_element', [])
        _token = self._peek('container', 'identifier')
        if _token == 'container':
            container = self._scan('container')
            element_list = self.element_list(_context)
            c_c_b = self._scan('c_c_b')
            return element_list
        else: # == 'identifier'
            identifier = self._scan('identifier')
        return identifier

    def element_list(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'element_list', [])
        base_element = self.base_element(_context)
        p = [base_element]
        while self._peek('comma', 'c_c_b') == 'comma':
            comma = self._scan('comma')
            base_element = self.base_element(_context)
            p.append(base_element)
        if self._peek() not in ['comma', 'c_c_b']:
            raise yappsrt.SyntaxError(charpos=self._scanner.get_prev_char_pos(), context=_context, msg='Need one of ' + ', '.join(['comma', 'c_c_b']))
        return p


def parse(rule, text):
    P = TypeParser(TypeParserScanner(text))
    return yappsrt.wrap_error_reporter(P, rule)

# End -- grammar generated by Yapps



