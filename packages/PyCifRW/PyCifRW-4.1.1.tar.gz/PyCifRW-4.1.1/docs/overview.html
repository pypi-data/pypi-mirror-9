<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="markdown4.css" type="text/css" />
</head>
<body>
<h1 id="programming-with-pycifrw">Programming with PyCIFRW</h1>
<p>PyCIFRW provides facilities for reading, manipulating and writing CIF and STAR files. In addition, CIF files and dictionaries may be validated against DDL1/2/m dictionaries.</p>
<h2 id="installing-and-initialising-pycifrw">Installing and Initialising PyCIFRW</h2>
<p>(Note: these instructions refer to version 4.0 and higher. For older versions, see the documentation provided with those versions).</p>
<p>As of version 4.0, it is sufficient to install the PyCIFRW “wheel” using <code>pip</code>, for example:</p>
<pre><code>pip install --use-wheel PyCifRW-4.1-cp27-none-linux_i686.whl</code></pre>
<p>or using the platform independent source package found on PyPI:</p>
<pre><code>pip install pycifrw</code></pre>
<p>If you want to include PyCIFRW with your package, you can install the PyCIFRW wheel into your development environment and then bundle the contents of the <code>CifFile</code> directory found in the Python local libraries directory (usually <code>site-packages</code>).</p>
<p>If PyCIFRW has installed properly, the following command should complete without any errors:</p>
<pre><code>  import CifFile</code></pre>
<h2 id="working-with-cif-files">Working with CIF files</h2>
<h3 id="reading-cif-files">Reading CIF files</h3>
<p>CIF files are represented in PyCIFRW as <code>CifFile</code> objects. These objects behave identically to Python dictionaries, with some additional methods. <code>CifFile</code> objects can be created by calling the <code>ReadCif</code> function on a filename or URL:</p>
<pre><code>      cf = CifFile.ReadCif(&quot;mycif.cif&quot;)    
      df = CifFile.ReadCif(&quot;ftp://ftp.iucr.org/pub/cifdics/cifdic.register&quot;)</code></pre>
<p>Errors are raised if CIF syntax/grammar violations are encountered in the input file or line length limits are exceeded.</p>
<p>A compiled extension (<code>StarScan.so</code>) is available on Linux which increases parsing speed by a factor of three or more. To use this facility, include the keyword argument <code>scantype='flex'</code> in <code>ReadCif</code> commands:</p>
<pre><code>      cf = CifFile.ReadCif(&quot;mycif.cif&quot;,scantype=&quot;flex&quot;)</code></pre>
<h4 id="grammar-options">Grammar options</h4>
<p>There are three variations in CIF file syntax. An early, little-used version of the standard allowed non-quoted data strings to begin with square bracket characters ('['). This was disallowed in version 1.1 in order to reserve such usage for later developments. The recently introduced CIF2 standard adds list and table datastructures to CIF1. Detection of the appropriate CIF grammar is automatic, but potentially time-consuming for multiple files, so specification of the particular version to use is possible with the grammar keyword:</p>
<pre><code>     cf = CifFile.ReadCif(&#39;oldcif.cif&#39;,grammar=&#39;1.0&#39;) #oldest CIF syntax      
     cf = CifFile.ReadCif(&#39;normcif.cif&#39;,grammar=&#39;1.1&#39;) #widespread
     cf = CifFile.ReadCif(&#39;future.cif&#39;,grammar=&#39;2.0&#39;) #latest standard
     cf = CifFile.ReadCif(&#39;unknown.cif&#39;,grammar=&#39;auto&#39;) #try 2.0-&gt;1.1-&gt;1.0</code></pre>
<p>Reading of STAR2 files is also possible by setting <code>grammar='STAR2'</code>.</p>
<h3 id="creating-a-new-ciffile">Creating a new CifFile</h3>
<p>A new <code>CifFile</code> object is usually created empty:</p>
<pre class="sourceCode python"><code class="sourceCode python">        cf = CifFile.CifFile()</code></pre>
<p>You will need to create at least one <code>CifBlock</code> object to hold your data. The <code>CifBlock</code> is then added to the <code>CifFile</code> using the usual Python dictionary notation. The dictionary 'key' becomes the blockname used for output.</p>
<pre class="sourceCode python"><code class="sourceCode python">        myblock = CifFile.CifBlock()        
        cf[<span class="st">&#39;a_block&#39;</span>] = myblock</code></pre>
<p>A <code>CifBlock</code> object may be initialised with another <code>CifBlock</code>, in which case a copy operation is performed.</p>
<p>Note that most operations on data provided by PyCIFRW involve <code>CifBlock</code> objects.</p>
<h2 id="manipulating-values-in-a-cif-file">Manipulating values in a CIF file</h2>
<h3 id="accessing-data">Accessing data</h3>
<p>The simplest form of access is using standard Python square bracket notation. Data blocks and data names within each data block are referenced identically to normal Python dictionaries:</p>
<pre class="sourceCode python"><code class="sourceCode python">      my_data = cf[<span class="st">&#39;a_data_block&#39;</span>][<span class="st">&#39;_a_data_name&#39;</span>]</code></pre>
<p>All values read in are stored as strings <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, with CIF syntactical elements stripped, that is, no enclosing quotation marks or semicolons are included in the values. The value associated with a <code>CifFile</code> dictionary key is always a <code>CifBlock</code> object. All standard Python dictionary methods (e.g. <code>get</code>, <code>update</code>, <code>items()</code>, <code>keys()</code>) are available for both <code>CifFile</code> and <code>CifBlock</code> objects. Note also the convenience method <code>first_block()</code>, which will return the first datablock in a CIF file:</p>
<pre class="sourceCode python"><code class="sourceCode python">    my_data = cf.first_block()</code></pre>
<p>If a data name occurs in a loop, a list of values is returned for the value of that dataname - the next section describes ways to access looped data.</p>
<h4 id="tabular-looped-data">Tabular (“looped”) data</h4>
<p>For the purpose of the following examples, we use the following example CIF file:</p>
<pre><code>data_testblock
loop_
  _item_5   
  _item_7   
  _item_6    
  1  a  5    
  2  b  6    
  3  c  7    
  4  d  8 </code></pre>
<p>Any table can be interacted with in a column-based or a row-based way. A PyCIFRW <code>CifBlock</code> object provides column-based access using normal square bracket syntax as described above: for example <code>cf['testblock']['_item_6']</code> will return <code>['5','6','7','8']</code>.</p>
<h4 id="table-row-access">Table row access</h4>
<p>The <code>CifLoopBlock</code> object represents a loop structure in the CIF file and facilitates row-based access. A <code>CifLoopBlock</code> object can be obtained by calling the <code>CifBlock</code> method <code>GetLoop(dataname)</code>. Column-based access remains available for this object (e.g. <code>keys()</code> returns a list of datanames in the loop and square bracket notation returns a list of column values).</p>
<p>A particular row can be selected using the <code>CifLoopBlock</code> <code>GetKeyedPacket</code> method:</p>
<pre class="sourceCode python"><code class="sourceCode python">    &gt;&gt;&gt; lb = cf[<span class="st">&#39;testblock&#39;</span>].GetLoop(<span class="st">&#39;_item_6&#39;</span>)
    &gt;&gt;&gt; myrow = lb.GetKeyedPacket(<span class="st">&#39;_item_7&#39;</span>,<span class="st">&#39;c&#39;</span>) 
    &gt;&gt;&gt; myrow._item_5
    <span class="co">&#39;3&#39;</span></code></pre>
<p>In this example, the first packet with a value of <code>'c'</code> for <code>_item_7</code> is returned, and packet values can then be accessed using the dataname as an attribute of the packet. Note that a <code>KeyError</code> is raised if more than one packet matches, or no packets match, and that the packet returned is a copy of the data read in from the file, and therefore can be changed without affecting the <code>CifBlock</code> object.</p>
<p>You may also access the nth value in this <code>CifLoopBlock</code> object. <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>, and values can be obtained from these packets as attributes.</p>
<pre class="sourceCode python"><code class="sourceCode python">    &gt;&gt;&gt; lb = cb.GetLoop(<span class="st">&quot;_item_5&quot;</span>)
    &gt;&gt;&gt; lb[<span class="dv">0</span>]
    [<span class="st">&#39;1&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;5&#39;</span>]
    &gt;&gt;&gt; lb[<span class="dv">0</span>]._item_7
    <span class="co">&#39;a&#39;</span></code></pre>
<p>An alternative way of accessing loop data uses Python iterators, allowing the following syntax:</p>
<pre class="sourceCode python"><code class="sourceCode python">    &gt;&gt;&gt; <span class="kw">for</span> a in lb: <span class="dt">print</span> `a[<span class="st">&quot;_item_7&quot;</span>]` 
    <span class="co">&#39;a&#39;</span> <span class="st">&#39;b&#39;</span> <span class="st">&#39;c&#39;</span> <span class="st">&#39;d&#39;</span> </code></pre>
<p>Note that in both the above examples the row packet is a copy of the looped data, and therefore changes to it will not silently alter the contents of the original <code>CifFile</code> object, unlike the lists returned when column-based access is used.</p>
<h3 id="changing-or-adding-data-values">Changing or adding data values</h3>
<p>If many operations are going to be performed on a single data block, it is convenient to assign that block to a new variable:</p>
<pre class="sourceCode python"><code class="sourceCode python">    cb = cf[<span class="st">&#39;my_block&#39;</span>]</code></pre>
<p>A new data name and value may be added, or the value of an existing name changed, by straight assignment:</p>
<pre class="sourceCode python"><code class="sourceCode python">    cb[<span class="st">&#39;_new_data_name&#39;</span>] = <span class="fl">4.5</span>
    cb[<span class="st">&#39;_old_data_name&#39;</span>] = <span class="st">&#39;cucumber&#39;</span></code></pre>
<p>Old values are overwritten silently. Note that values may be strings or numbers.</p>
<h4 id="creating-loops">Creating loops</h4>
<p>Loop creation has been simplified in PyCIFRW 4.0. To create a loop, simply set the column values to same-length lists, and then call the <code>CifBlock</code> method <code>CreateLoop</code> with a list of the looped datanames as a single argument. This method will raise an error if the datanames have different length columns assigned to them. For example, the following commands create the example loop above:</p>
<pre class="sourceCode python"><code class="sourceCode python">    cb[<span class="st">&#39;_item_5&#39;</span>]  = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]
    cb[<span class="st">&#39;_item_7&#39;</span>]  = [<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>,<span class="st">&#39;c&#39;</span>,<span class="st">&#39;d&#39;</span>]
    cb[<span class="st">&#39;_item_6&#39;</span>]  = [<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>]
    cb.CreateLoop([<span class="st">&#39;_item_5&#39;</span>,<span class="st">&#39;_item_7&#39;</span>,<span class="st">&#39;_item_6&#39;</span>])</code></pre>
<p>Another method, <code>AddToLoop(dataname,newdata)</code>, adds columns in <code>newdata</code> to the pre-existing loop containing <code>dataname</code>, silently overwriting duplicate data. <code>newdata</code> should be a Python dictionary of dataname - datavalue pairs.</p>
<p>Note that lists (and other listlike objects except packets) returned by PyCIFRW actually point to the list currently inside the <code>CifBlock</code> object, and therefore any modification to them will modify the stored list. While this is often the desired behaviour, if you intend to manipulate such a list in other parts of your program while preserving the original CIF information, you should first copy the list to avoid destroying the loop structure:</p>
<pre class="sourceCode python"><code class="sourceCode python">    mysym = cb[<span class="st">&#39;_symmetry_ops&#39;</span>][:]
    mysym.append(<span class="st">&#39;x-1/2,y+1/2,z&#39;</span>)</code></pre>
<h4 id="changing-item-order">Changing item order</h4>
<p>Item order has <em>no</em> semantic significance in CIF files. However, the readability of CIF files in simple text editors leads to a desire to organise the output order for human readers. The <code>ChangeItemOrder</code> method allows the order in which data items appear in the printed file to be changed:</p>
<pre class="sourceCode python"><code class="sourceCode python">    mycif[<span class="st">&#39;testblock&#39;</span>].ChangeItemOrder(<span class="st">&#39;_item_5&#39;</span>,<span class="dv">0</span>)</code></pre>
<p>will move <code>_item_5</code> to the beginning of the datablock. When changing the order inside a loop block, the loop block's method must be called i.e.:</p>
<pre class="sourceCode python"><code class="sourceCode python">aloop = mycif[<span class="st">&#39;testblock&#39;</span>].GetLoop(<span class="st">&#39;_loop_item_1&#39;</span>)
aloop.ChangeItemOrder(<span class="st">&#39;_loop_item_1&#39;</span>,<span class="dv">4</span>)</code></pre>
<p>Note also that the position of a loop within the file can be changed in this way as well, by passing the 'block number' object as the first argument. Each loop is assigned a simple integer number, which can be found by calling <code>FindLoop</code> with the name of a column in that loop:</p>
<pre class="sourceCode python"><code class="sourceCode python">loop_id = mycif[<span class="st">&#39;testblock&#39;</span>].FindLoop(<span class="st">&#39;_item_6&#39;</span>)
mycif[<span class="st">&#39;testblock&#39;</span>].ChangeItemOrder(loop_id,<span class="dv">0</span>)</code></pre>
<p>will move the loop block to the beginning of the printed datablock.</p>
<h4 id="adding-and-removing-table-rows">Adding and removing table rows</h4>
<p>While it is most efficient to add columns to the <code>CifBlock</code> and then bind them together once into a loop, it is possible to add a new row into an existing loop using the <code>AddPacket(packet)</code> method of <code>CifLoopBlock</code> objects:</p>
<pre class="sourceCode python"><code class="sourceCode python">    aloop = mycif[<span class="st">&#39;testblock&#39;</span>].GetLoop(<span class="st">&#39;_item_7&#39;</span>)
    template = aloop.GetKeyedPacket(<span class="st">&#39;_item_7&#39;</span>,<span class="st">&#39;d&#39;</span>)
    template._item_5 = <span class="st">&#39;5&#39;</span>
    template._item_7 = <span class="st">&#39;e&#39;</span>
    template._item_6 = <span class="st">&#39;9&#39;</span>
    aloop.AddPacket(template)</code></pre>
<p>Note we use an existing packet as a template in this example. If you wish to create a packet from scratch, you should instantiate a <code>StarPacket</code>:</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="ch">import</span> StarFile   <span class="co">#installed with PyCIFRW</span>
    newpack = StarFile.StarPacket()
    newpack._item_5 = <span class="st">&#39;5&#39;</span>  
    ...
    aloop.AddPacket(newpack)</code></pre>
<p>Note that an error will be raised when calling <code>AddPacket</code> if the packet attributes do not exactly match the item names in the loop.</p>
<p>A packet may be removed using the <code>RemoveKeyedPacket</code> method, which chooses the packet to be removed based on the value of the given dataname:</p>
<pre class="sourceCode python"><code class="sourceCode python">    aloop.RemoveKeyedPacket(<span class="st">&#39;_item_7&#39;</span>,<span class="st">&#39;a&#39;</span>)</code></pre>
<h2 id="writing-cif-files">Writing CIF Files</h2>
<p>The <code>CifFile</code> method <code>WriteOut</code> returns a string which may be passed to an open file descriptor:</p>
<pre class="sourceCode python"><code class="sourceCode python">    outfile = <span class="dt">open</span>(<span class="st">&quot;mycif.cif&quot;</span>)
    outfile.write(cf.WriteOut())</code></pre>
<p>Or the built-in Python <code>str()</code> function can be used:</p>
<pre><code>outfile.write(str(cf))</code></pre>
<p><code>WriteOut</code> takes an optional keyword argument, <code>comment</code>, which should be a string containing a comment which will be placed at the top of the output file. This comment string must already contain # characters at the beginning of lines:</p>
<pre><code>outfile.write(cf.WriteOut(&quot;#This is a test file&quot;))</code></pre>
<p>Two additional keyword arguments control line length in the output file: <code>wraplength</code> and <code>maxoutlength</code>. Lines in the output file are guaranteed to be shorter than <code>maxoutlength</code> characters, and PyCIFRW will additionally insert a line break if putting two data values or a dataname/datavalue pair together on the same line would exceed <code>wraplength</code>. In other words, unless data values are longer than <code>maxoutlength</code> characters long, no line breaks will be inserted in the output file. By default, <code>wraplength = 80</code> and <code>maxoutlength = 2048</code>.</p>
<p>These values may be set on a per block basis by calling the <code>SetOutputLength</code> method of the block.</p>
<p>The order of output of items within a <code>CifFile</code> or <code>CifBlock</code> is specified using the <code>ChangeItemOrder</code> method (see above). The default order is the order that items were inserted or read in to the <code>CifFile</code>/<code>CifBlock</code>.</p>
<h3 id="templating-system">Templating system</h3>
<p>If you want precise control of the layout of your CIF file, you can pass a template file to the <code>CifBlock.process_template</code> method. A 'template' is a CIF file containing a single block, where the datanames are laid out in the way that the user desires. The layout elements that are picked up from this template are:</p>
<ol style="list-style-type: decimal">
<li>order (overrides current order of <code>CifBlock</code>)</li>
<li>column position of datavalues (only the first row of a loop block is inspected)</li>
<li>delimiters</li>
</ol>
<p>Constraints on the template:</p>
<ol style="list-style-type: decimal">
<li>There should only ever be one dataname on each line</li>
<li><code>loop_</code> and and <code>datablock</code> tokens should appear as the only non-blank characters on their lines</li>
<li>Comments are flagged by a '#' as the first character in the line</li>
<li>Blank lines are acceptable (and ignored)</li>
<li>The dummy datavalues should use only alphanumeric characters</li>
<li>Semicolon-delimited strings are not allowed in loops</li>
</ol>
<p>After calling <code>process_template</code> with the template file as the argument, subsequent calls to <code>WriteOut</code> will respect the template information, and revert to default behaviour for any datanames that were not found in the template. Templating is most useful when formatting CIF dictionaries which are read heavily by human readers, and have many (thousands!) of datablocks, each containing the same limited number of datanames.</p>
<h4 id="output-format">Output format</h4>
<p>CIF files are output by default in CIF2 grammar, but with the CIF2-only triple quotes avoided unless explicitly requested. Therefore, as long as CIF2-only datastructures (lists and tables) are absent, the output CIF files will conform to 1.0,1.1 and 2.0 grammar. The grammar of the output files can be changed by calling <code>CifFile.set_grammar</code> with the choices being 1.0,1.1,2.0 or STAR2.</p>
<h2 id="unsupported-operations">Unsupported operations</h2>
<p>The following notes are from previous versions of PyCIFRW. The operations described have not been updated to new internal datastructures and may not work in this release.</p>
<h3 id="merging-dictionaries">Merging dictionaries</h3>
<p>PyCIFRW provides a top-level function to merge DDL1/2 dictionary files. It takes a list of CIF filenames or <code>CifFile</code> objects, and a <code>mergemode</code> keyword argument. CIF files are merged from left to right, that is, the second file in the list is merged into the first file in the list and so on.</p>
<p>For completeness we list the arguments of the <code>CifFile</code> merge method, which actually performs the merging operation:</p>
<dl>
<dt>new_block_set</dt>
<dd>(first argument, no keyword) The new dictionary
</dd>
</dl>
<p>to be merged into the current dictionary</p>
<dl>
<dt>mode</dt>
<dd><p>merging mode to use ('strict', 'overlay' or 'replace')</p>
</dd>
<dt>single_block</dt>
<dd>a two element list [oldblockname, newblockname],
</dd>
</dl>
<p>where oldblockname in the current file is merged with newblockname in the new file. This is useful when blocknames don't match</p>
<dl>
<dt>idblock</dt>
<dd>This block is ignored when merging - useful when
</dd>
</dl>
<p>merging DDL1 dictionaries in strict mode, in which case the on_this_dictionary block would cause an error.</p>
<h4 id="limitations-on-merging">Limitations on merging</h4>
<p>In overlay mode, the COMCIFS recommendations require that, when both definitions contain identical unlooped attributes which can be looped, the merging process should construct those loops and include both sets of data in the new loop.</p>
<p>This is not yet implemented in PyCIFRW, as it involves checking the DDL1/DDL2 spec to determine which attributes may be looped together.</p>
<h1 id="example-programs">Example programs</h1>
<p>A program which uses PyCIFRW for validation, <code>validate_cif.py</code>, is included in the distribution in the <code>Programs</code> subdirectory. It will validate a CIF file (including dictionaries) against one or more dictionaries which may be specified by name and version or as a filename on the local disk. If name and version are specified, the IUCr canonical registry or a local registry is used to find the dictionary and download it if necessary.</p>
<h2 id="usage">Usage</h2>
<pre><code>python validate_cif.py [options] ciffile</code></pre>
<h2 id="options">Options</h2>
<pre><code>--version show version number and exit
-h,--help print short help message
-d dirname directory to find/store dictionary files
-f dictname filename of locally-stored dictionary
-u version dictionary version to resolve using registry
-n name dictionary name to resolve using registry
-s store downloaded dictionary locally (default True)
-c fetch and use canonical registry from IUCr
-r registry location of registry as filename or URL
-t The file to be checked is itself a DDL2 dictionary</code></pre>
<h1 id="further-information">Further information</h1>
<p>The source files are in a literate programming format (noweb) with file extension .nw. HTML documentation generated from these files and containing both code and copious comments is included in the downloaded package. Details of interpretation of the current standards as relates to validation can be found in these files.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This deviates from the current CIF standard, which mandates interpreting unquoted strings as numbers where possible and in the absence of dictionary definitions to the contrary (International Tables, Vol. G., p24).<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Warning: row and column order in a CIF loop is arbitrary; while PyCIFRW currently maintains the row order seen in the input file, there is nothing in the CIF standards which mandates this behaviour, and later implementations may change this behaviour<a href="#fnref2">↩</a></p></li>
</ol>
</div>
</body>
</html>
