<!DOCTYPE html>
<html>
	<head>
		<!--
Copyright (c) 2014, 2015  StorPool.
All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

		-->
		<title>StorPool API Reference</title>
		<style>
			pre {
				border: 1px dashed #333333;
				padding: 1em;
				margin-top: 5px;
				margin-bottom: 5px;
				overflow: auto;
				width: 95%;
				color: #000066;
			}
			
			pre var {
				font-weight: bold;
				color: #FF0000;
			}
			
			strong {
				font-style: italic;
				color: #000066;
			}
			
			li.attribute {
				margin-bottom: 0.2em;
			}
			table {
				position: relative;
				left: 20px;
				border-collapse: collapse;
			}
			td {
				border-bottom: 1px dashed #aaa;
			}
			
			pre.code {
				position: relative;
				left: 50px;
			}
			.opt {
				font-style: italic;
				font-weight: bold;
			}
			
			pre .opt {
				color: #444;
			}
		</style>
	</head>
	<body>
	
<h1>StorPool API Reference</h1>
<p>Copyright (c) 2014-2015 StorPool. All rights reserved.</p>
<p>This reference document describes the StorPool API version 14.10 and
the supported API calls.</p>
<ol>
<li><a href="#General">General</a></li>
<ol>
</ol>
<li><a href="#Peers">Peers</a></li>
<ol>
<li><a href="#NetworkPeersList">List the network peers</a></li>
</ol>
<li><a href="#Tasks">Tasks</a></li>
<ol>
<li><a href="#TasksList">List tasks</a></li>
</ol>
<li><a href="#Services">Services</a></li>
<ol>
<li><a href="#ServicesList">List all StorPool services</a></li>
<li><a href="#ServersListBlocked">List all blocked StorPool servers</a></li>
</ol>
<li><a href="#Servers">Servers</a></li>
<ol>
<li><a href="#ServerDisksList">List all disks on a server</a></li>
<li><a href="#ServerDiskDescribe">Describe a disk on a server</a></li>
</ol>
<li><a href="#Clients">Clients</a></li>
<ol>
<li><a href="#ClientsConfigDump">Get the current status of all the clients</a></li>
<li><a href="#ClientConfigWait">Wait until a client updates to the current configuration</a></li>
<li><a href="#ClientActiveRequests">List all the active requests on a client</a></li>
</ol>
<li><a href="#AoE-Targets">AoE Targets</a></li>
<ol>
<li><a href="#AoeStatus">Display AoE status</a></li>
<li><a href="#AoeExportVolume">Export a volume</a></li>
<li><a href="#AoeExportSnapshot">Unexport a volume</a></li>
<li><a href="#AoeUnexportVolume">Export a snapshot</a></li>
<li><a href="#AoeUnexportSnapshot">Unexport a snaphot</a></li>
<li><a href="#AoeTargetActiveRequests">List all active requests on an AoE target</a></li>
</ol>
<li><a href="#Disks">Disks</a></li>
<ol>
<li><a href="#DisksList">List all disks</a></li>
<li><a href="#DiskDescribe">Describe a disk</a></li>
<li><a href="#DiskGetInfo">Get disk info</a></li>
<li><a href="#DiskEject">Eject a disk</a></li>
<li><a href="#DiskForget">Forget a disk</a></li>
<li><a href="#DiskSoftEject">Soft-eject a disk</a></li>
<li><a href="#DiskSoftEjectPause">Pause a disk&apos;s soft-eject operation</a></li>
<li><a href="#DiskSoftEjectCancel">Cancel a disk&apos;s soft-eject operation</a></li>
<li><a href="#DiskSetDescription">Set a disk&apos;s description</a></li>
<li><a href="#DiskActiveRequests">List all the active requests on a disk</a></li>
</ol>
<li><a href="#Volumes">Volumes</a></li>
<ol>
<li><a href="#VolumesList">List all volumes</a></li>
<li><a href="#VolumesGetStatus">Get volume and snapshot status</a></li>
<li><a href="#Volume">List a single volume</a></li>
<li><a href="#VolumeDescribe">Describe a volume</a></li>
<li><a href="#VolumeGetInfo">Get volume info</a></li>
<li><a href="#VolumeListSnapshots">List the parent snapshots of a volume</a></li>
<li><a href="#VolumeCreate">Create a new volume</a></li>
<li><a href="#VolumeUpdate">Update a volume</a></li>
<li><a href="#VolumeFreeze">Freeze a volume</a></li>
<li><a href="#VolumeRebase">Rebase a volume</a></li>
<li><a href="#VolumeDelete">Delete a volume</a></li>
</ol>
<li><a href="#Snapshots">Snapshots</a></li>
<ol>
<li><a href="#SnapshotsList">List all snapshots</a></li>
<li><a href="#Snapshot">List a single snapshot</a></li>
<li><a href="#SnapshotDescribe">Describe a snapshot</a></li>
<li><a href="#SnapshotGetInfo">Get snapshot info</a></li>
<li><a href="#VolumeSnapshot">Snapshot a volume</a></li>
<li><a href="#SnapshotUpdate">Update a snapshot</a></li>
<li><a href="#SnapshotRebase">Rebase a snapshot</a></li>
<li><a href="#SnapshotDelete">Delete a snapshot</a></li>
</ol>
<li><a href="#Attachments">Attachments</a></li>
<ol>
<li><a href="#AttachmentsList">List all attachments</a></li>
<li><a href="#VolumesReassign">Reassign volumes and/or snapshots</a></li>
</ol>
<li><a href="#Placement-Groups">Placement Groups</a></li>
<ol>
<li><a href="#PlacementGroupsList">List all placement groups</a></li>
<li><a href="#PlacementGroupDescribe">Describe a single placement group</a></li>
<li><a href="#PlacementGroupUpdate">Create and/or update a placement group</a></li>
<li><a href="#PlacementGroupDelete">Delete a placement group</a></li>
</ol>
<li><a href="#Volume-Templates">Volume Templates</a></li>
<ol>
<li><a href="#VolumeTemplatesList">List all volume templates</a></li>
<li><a href="#VolumeTemplateDescribe">Describe a single volume template</a></li>
<li><a href="#VolumeTemplateCreate">Create a volume template</a></li>
<li><a href="#VolumeTemplateUpdate">Update a volume template</a></li>
<li><a href="#VolumeTemplateDelete">Delete a volume template</a></li>
</ol>
<li><a href="#Volume-Relocator">Volume Relocator</a></li>
<ol>
<li><a href="#VolumeRelocatorOn">Turn the relocator on</a></li>
<li><a href="#VolumeRelocatorOff">Turn the relocator off</a></li>
<li><a href="#VolumeRelocatorStatus">Get the relocator&apos;s status</a></li>
</ol>
<li><a href="#Balancer">Balancer</a></li>
<ol>
<li><a href="#VolumeBalancerOn">Turn the balancer on</a></li>
<li><a href="#VolumeBalancerOff">Turn the balancer off</a></li>
<li><a href="#VolumeBalancerStatus">Get the balancer&apos;s status</a></li>
</ol>
<li><a href="#types">Data Types</a></li>
</ol>
<h2 id="General">General</h2>
<p>The StorPool API can be used with any tool that can generate HTTP requests with the GET and POST methods.
The only requirement is to supply the Authorization header and, if required by the request, valid JSON data.</p>
<p>For each call there is an explanation of the HTTP request and response
and an example in raw format as it should be sent to the StorPool management service.</p>
<p>Here are two examples using curl using the GET and POST methods respectively and their counterparts as issued by the StorPool CLI:</p>
<p></p>
<pre class="code"><code>curl -H &quot;Authorization: Storpool v1:1556129910218014736&quot; 192.168.42.208:81/ctrl/1.0/DisksList
storpool disk list
</code></pre>
<p></p>
<p></p>
<pre class="code"><code>curl -d &apos;{&quot;addDisks&quot;:[&quot;1&quot;]}&apos; -H &quot;Authorization: Storpool v1:1556129910218014736&quot; 192.168.42.208:81/ctrl/1.0/PlacementGroupUpdate/hdd
storpool placementGroup hdd addDisk 1
</code></pre>
<p></p>
<p>Python programs may use the API by importing the Python StorPool bindings (use &apos;pypi install storpool&apos; to install them):</p>
<p></p>
<pre class="code"><code>&gt;&gt;&gt;import spapi
&gt;&gt;&gt;api=spapi.Api(&apos;192.168.0.5&apos;, 80, &apos;1556560560218011653&apos;)
&gt;&gt;&gt;a.peersList()

{
  1: {
       &apos;networks&apos;: {
         0: {
          &apos;mac&apos;: &apos;00:4A:E6:5F:34:C3&apos;
         }
       }
  },
  2: {
       &apos;networks&apos;: {
         0: {
          &apos;mac&apos;: &apos;52:54:E6:5F:34:DF&apos;
         }
       }
  },
  3: {
        &apos;networks&apos;: {
          0: {
           &apos;mac&apos;: &apos;52:57:5F:54:E6:3A&apos;
          }
        }
  }
}
</code></pre>
<p></p>
<p>The calls that may be used may be found in the file spapi.py</p>
<p>Note: Requests will sometimes use GET instead of POST and consequently,
will not require JSON. Responses on the other hand always produce JSON content.</p>
<h2 id="Peers">Peers</h2>
<p></p>
<h3 id="NetworkPeersList">List the network peers (<strong>NetworkPeersList</strong>)</h3>
<p>List the network nodes running the StorPool beacon including information
	such as the ID of the node,
	the networks it communicates through and the corresponding MAC addresses.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/NetworkPeersList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/NetworkPeersList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>PeerID</var>": {
      "networks": {
        "<var>NetID</var>": {
          "mac": <var>MAC Address</var>
        }, ...
      }
    }, ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from PeerID to PeerDesc
<ul>
<li>Key type: <strong><a href="#PeerID">PeerID</a></strong></li>
<li>Value type: <strong>PeerDesc</strong><ul>
<li class="attribute">networks:  List of the networks that StorPool communicates through on this node.A dict from NetID to NetDesc
<ul>
<li>Key type: <strong><a href="#NetID">NetID</a></strong></li>
<li>Value type: <strong>NetDesc</strong><ul>
<li class="attribute">mac:  (<strong><a href="#MAC Address">MAC Address</a></strong>)</li></ul>
</li>
</ul>
</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Tasks">Tasks</h2>
<p></p>
<h3 id="TasksList">List tasks (<strong>TasksList</strong>)</h3>
<p>List the currently active recovery tasks. This call will return JSON
	data only when there is a relocation in progress. Under normal operation
	of the cluster it will return no data.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/TasksList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/TasksList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "allObjects": <var>int</var>,
    "completedObjects": <var>int</var>,
    "diskId": <var>DiskID</var>,
    "dispatchedObjects": <var>int</var>,
    "transactionId": <var>long</var>,
    "unresolvedObjects": <var>int</var> <span class="opt">/* Internal */</span>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>Task</strong><ul>
<li class="attribute">allObjects:  (<strong><a href="#int">int</a></strong>): The number of all the objects that the task is performing actions on.</li><li class="attribute">completedObjects:  (<strong><a href="#int">int</a></strong>): The number of objects that the task has finished working on.</li><li class="attribute">diskId:  (<strong><a href="#DiskID">DiskID</a></strong>)</li><li class="attribute">dispatchedObjects:  (<strong><a href="#int">int</a></strong>): Objects that the task has started working on.</li><li class="attribute">transactionId:  (<strong><a href="#long">long</a></strong>): An ID associated with the currently running task. This ID is the same for all the tasks running on different disks but initiated by the same action (e.g. when reallocating a volume, all tasks associated with that volume will have the same ID).</li><li class="attribute">unresolvedObjects:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Services">Services</h2>
<p></p>
<h3 id="ServicesList">List all StorPool services (<strong>ServicesList</strong>)</h3>
<p>List all the services in the cluster (StorPool servers, clients, management, etc).
	If the whole cluster is
	not operational this call will return an error.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ServicesList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ServicesList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "aoeTargets": {
      "<var>AoeTargetID</var>": {
        "id": <var>AoeTargetID</var>,
        "nodeId": <var>NodeID</var>,
        "status": <var>ClientStatus</var>,
        "version": <var>string</var>
      }, ...
    },
    "clients": {
      "<var>ClientID</var>": {
        "id": <var>ClientID</var>,
        "nodeId": <var>NodeID</var>,
        "status": <var>ClientStatus</var>,
        "version": <var>string</var>
      }, ...
    },
    "clusterStatus": <var>ClusterStatus</var>,
    "mgmt": {
      "<var>MgmtID</var>": {
        "active": <var>bool</var>,
        "id": <var>MgmtID</var>,
        "nodeId": <var>NodeID</var>,
        "prio": <var>int</var> <span class="opt">/* Internal */</span>,
        "status": <var>ClientStatus</var>,
        "version": <var>string</var>
      }, ...
    },
    "servers": {
      "<var>ServerID</var>": {
        "id": <var>ServerID</var>,
        "missingDisks": [<var>DiskID</var>, ...],
        "nodeId": <var>NodeID</var>,
        "pendingDisks": [<var>DiskID</var>, ...],
        "status": <var>ServerStatus</var>,
        "version": <var>string</var>
      }, ...
    }
  }
}
</code></pre></li>
<li>Response Data:
<strong>ClusterStatus</strong><ul>
<li class="attribute">aoeTargets: A dict from AoeTargetID to AoeTarget
<ul>
<li>Key type: <strong><a href="#AoeTargetID">AoeTargetID</a></strong></li>
<li>Value type: <strong>AoeTarget</strong><ul>
<li class="attribute">id:  (<strong><a href="#AoeTargetID">AoeTargetID</a></strong>): The ID of the service.</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">status:  (<strong><a href="#ClientStatus">ClientStatus</a></strong>): The current status of the AoE target.</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li><li class="attribute">clients: A dict from ClientID to Client
<ul>
<li>Key type: <strong><a href="#ClientID">ClientID</a></strong></li>
<li>Value type: <strong>Client</strong><ul>
<li class="attribute">id:  (<strong><a href="#ClientID">ClientID</a></strong>): The ID of the service. Currently this is the same as the ID of the node.</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">status:  (<strong><a href="#ClientStatus">ClientStatus</a></strong>): The current status of the client.</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li><li class="attribute">clusterStatus:  (<strong><a href="#ClusterStatus">ClusterStatus</a></strong>): The current status of the whole cluster. running - At least one running server; a cluster is formed. waiting - In quorum but negotiations between servers are not over yet. down - No quorum; most likely because more beacons are needed.</li><li class="attribute">mgmt: A dict from MgmtID to Mgmt
<ul>
<li>Key type: <strong><a href="#MgmtID">MgmtID</a></strong></li>
<li>Value type: <strong>Mgmt</strong><ul>
<li class="attribute">active:  (<strong><a href="#bool">bool</a></strong>): If the instance is currently active. For a given cluster one mgmt instance will be active at any given time.</li><li class="attribute">id:  (<strong><a href="#MgmtID">MgmtID</a></strong>): The ID of the service.</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">prio:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">status:  (<strong><a href="#ClientStatus">ClientStatus</a></strong>): The current status of the mgmt instance.</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li><li class="attribute">servers: A dict from ServerID to Server
<ul>
<li>Key type: <strong><a href="#ServerID">ServerID</a></strong></li>
<li>Value type: <strong>Server</strong><ul>
<li class="attribute">id:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the service. Currently this is the same as the ID of the node.</li><li class="attribute">missingDisks:  The cluster will remain down until these disks are seen again. This happens in the case of simultaneous failure of the whole cluster (power failure); the servers keep track of where the most recent configuration and data was stored.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">pendingDisks:  Similar to missingDisks, these are the disks that are ready and waiting for the missing ones.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">status:  (<strong><a href="#ServerStatus">ServerStatus</a></strong>): down - There is no storpool_server daemon running or it is still recovering its drives from a crashed state. waiting - storpool_server is running but waiting for some disks to appear to prevent split-brain situations. booting - No missing disks; the server is in the process of joining the cluster ...</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="ServersListBlocked">List all blocked StorPool servers (<strong>ServersListBlocked</strong>)</h3>
<p>List the currently active StorPool servers even before the cluster has become
	operational, along with information about any missing disks that the cluster
	is waiting for.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ServersListBlocked HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ServersListBlocked</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "aoeTargets": {
      "<var>AoeTargetID</var>": {
        "id": <var>AoeTargetID</var>,
        "nodeId": <var>NodeID</var>,
        "status": <var>ClientStatus</var>,
        "version": <var>string</var>
      }, ...
    },
    "clients": {
      "<var>ClientID</var>": {
        "id": <var>ClientID</var>,
        "nodeId": <var>NodeID</var>,
        "status": <var>ClientStatus</var>,
        "version": <var>string</var>
      }, ...
    },
    "clusterStatus": <var>ClusterStatus</var>,
    "mgmt": {
      "<var>MgmtID</var>": {
        "active": <var>bool</var>,
        "id": <var>MgmtID</var>,
        "nodeId": <var>NodeID</var>,
        "prio": <var>int</var> <span class="opt">/* Internal */</span>,
        "status": <var>ClientStatus</var>,
        "version": <var>string</var>
      }, ...
    },
    "servers": {
      "<var>ServerID</var>": {
        "id": <var>ServerID</var>,
        "missingDisks": [<var>DiskID</var>, ...],
        "nodeId": <var>NodeID</var>,
        "pendingDisks": [<var>DiskID</var>, ...],
        "status": <var>ServerStatus</var>,
        "version": <var>string</var>
      }, ...
    }
  }
}
</code></pre></li>
<li>Response Data:
<strong>ClusterStatus</strong><ul>
<li class="attribute">aoeTargets: A dict from AoeTargetID to AoeTarget
<ul>
<li>Key type: <strong><a href="#AoeTargetID">AoeTargetID</a></strong></li>
<li>Value type: <strong>AoeTarget</strong><ul>
<li class="attribute">id:  (<strong><a href="#AoeTargetID">AoeTargetID</a></strong>): The ID of the service.</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">status:  (<strong><a href="#ClientStatus">ClientStatus</a></strong>): The current status of the AoE target.</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li><li class="attribute">clients: A dict from ClientID to Client
<ul>
<li>Key type: <strong><a href="#ClientID">ClientID</a></strong></li>
<li>Value type: <strong>Client</strong><ul>
<li class="attribute">id:  (<strong><a href="#ClientID">ClientID</a></strong>): The ID of the service. Currently this is the same as the ID of the node.</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">status:  (<strong><a href="#ClientStatus">ClientStatus</a></strong>): The current status of the client.</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li><li class="attribute">clusterStatus:  (<strong><a href="#ClusterStatus">ClusterStatus</a></strong>): The current status of the whole cluster. running - At least one running server; a cluster is formed. waiting - In quorum but negotiations between servers are not over yet. down - No quorum; most likely because more beacons are needed.</li><li class="attribute">mgmt: A dict from MgmtID to Mgmt
<ul>
<li>Key type: <strong><a href="#MgmtID">MgmtID</a></strong></li>
<li>Value type: <strong>Mgmt</strong><ul>
<li class="attribute">active:  (<strong><a href="#bool">bool</a></strong>): If the instance is currently active. For a given cluster one mgmt instance will be active at any given time.</li><li class="attribute">id:  (<strong><a href="#MgmtID">MgmtID</a></strong>): The ID of the service.</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">prio:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">status:  (<strong><a href="#ClientStatus">ClientStatus</a></strong>): The current status of the mgmt instance.</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li><li class="attribute">servers: A dict from ServerID to Server
<ul>
<li>Key type: <strong><a href="#ServerID">ServerID</a></strong></li>
<li>Value type: <strong>Server</strong><ul>
<li class="attribute">id:  (<strong><a href="#ServerID">ServerID</a></strong>): The ID of the service. Currently this is the same as the ID of the node.</li><li class="attribute">missingDisks:  The cluster will remain down until these disks are seen again. This happens in the case of simultaneous failure of the whole cluster (power failure); the servers keep track of where the most recent configuration and data was stored.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">nodeId:  (<strong><a href="#NodeID">NodeID</a></strong>): The ID of the node on which the service is running.</li><li class="attribute">pendingDisks:  Similar to missingDisks, these are the disks that are ready and waiting for the missing ones.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">status:  (<strong><a href="#ServerStatus">ServerStatus</a></strong>): down - There is no storpool_server daemon running or it is still recovering its drives from a crashed state. waiting - storpool_server is running but waiting for some disks to appear to prevent split-brain situations. booting - No missing disks; the server is in the process of joining the cluster ...</li><li class="attribute">version:  (<strong><a href="#string">string</a></strong>): The version of the running StorPool service.</li></ul>
</li>
</ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Servers">Servers</h2>
<p></p>
<h3 id="ServerDisksList">List all disks on a server (<strong>ServerDisksList</strong>)</h3>
<p>Return detailed information about each disk on the given server.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ServerDisksList/{serverId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ServerDisksList/{serverId}</em></li>
<li>Arguments: 
<ul>
<li>serverId - <strong>ServerID</strong>: <em>integer, 1 &lt;= value &lt;= 32767</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>DiskID</var>": {
      "agAllocated": <var>int</var> <span class="opt">/* Internal */</span>,
      "agCount": <var>int</var> <span class="opt">/* Internal */</span>,
      "agFree": <var>int</var> <span class="opt">/* Internal */</span>,
      "agFreeing": <var>int</var> <span class="opt">/* Internal */</span>,
      "agFull": <var>int</var> <span class="opt">/* Internal */</span>,
      "agMaxSizeFull": <var>int</var> <span class="opt">/* Internal */</span>,
      "agMaxSizePartial": <var>int</var> <span class="opt">/* Internal */</span>,
      "agPartial": <var>int</var> <span class="opt">/* Internal */</span>,
      "description": <var>DiskDescritpion</var>,
      "device": <var>string</var>,
      "empty": <var>bool</var>,
      "entriesAllocated": <var>int</var>,
      "entriesCount": <var>int</var>,
      "entriesFree": <var>int</var>,
      "generationLeft": <var>long</var>,
      "id": <var>DiskID</var>,
      "model": <var>string</var>,
      "objectsAllocated": <var>int</var>,
      "objectsCount": <var>int</var>,
      "objectsFree": <var>int</var>,
      "objectsOnDiskSize": <var>long</var>,
      "sectorsCount": <var>long</var>,
      "serial": <var>string</var>,
      "serverId": <var>ServerID</var>,
      "softEject": <var>DiskSoftEjectStatus</var>,
      "ssd": <var>bool</var>
    }, ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from DiskID to DiskSummary
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: <strong>DiskSummary</strong><ul>
<li class="attribute">agAllocated:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agCount:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFree:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFreeing:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizeFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizePartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agPartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li><li class="attribute">device:  (<strong><a href="#string">string</a></strong>): The name of the physical disk device on the server.</li><li class="attribute">empty:  (<strong><a href="#bool">bool</a></strong>): True if no volumes or snapshots are on this disk.</li><li class="attribute">entriesAllocated:  (<strong><a href="#int">int</a></strong>): Used entries of the disk.</li><li class="attribute">entriesCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of entries that can exists on the disk.</li><li class="attribute">entriesFree:  (<strong><a href="#int">int</a></strong>): The remaining number of entries that can be stored on the disk.</li><li class="attribute">generationLeft:  (<strong><a href="#long">long</a></strong>): The last cluster generation when the disk was active on a running server, or -1 if the disk is currently active.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>)</li><li class="attribute">model:  (<strong><a href="#string">string</a></strong>)</li><li class="attribute">objectsAllocated:  (<strong><a href="#int">int</a></strong>): Used objects of the disk.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">objectsFree:  (<strong><a href="#int">int</a></strong>): The remaining number of objects that can be stored on the disk.</li><li class="attribute">objectsOnDiskSize:  (<strong><a href="#long">long</a></strong>): Total size occupied by objects. In essence, this is the estimated disk usage by StorPool.</li><li class="attribute">sectorsCount:  (<strong><a href="#long">long</a></strong>): The amount of 512-byte sectors on the disk.</li><li class="attribute">serial:  (<strong><a href="#string">string</a></strong>)</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>)</li><li class="attribute">softEject:  (<strong><a href="#DiskSoftEjectStatus">DiskSoftEjectStatus</a></strong>): The status of the soft-eject process.</li><li class="attribute">ssd:  (<strong><a href="#bool">bool</a></strong>): Whether the device is an SSD.</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="ServerDiskDescribe">Describe a disk on a server (<strong>ServerDiskDescribe</strong>)</h3>
<p>Return detailed information about a disk on the given server and the
	objects on it.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ServerDiskDescribe/{serverId}/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ServerDiskDescribe/{serverId}/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
<li>serverId - <strong>ServerID</strong>: <em>integer, 1 &lt;= value &lt;= 32767</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "agAllocated": <var>int</var> <span class="opt">/* Internal */</span>,
    "agCount": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFree": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFreeing": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFull": <var>int</var> <span class="opt">/* Internal */</span>,
    "agMaxSizeFull": <var>int</var> <span class="opt">/* Internal */</span>,
    "agMaxSizePartial": <var>int</var> <span class="opt">/* Internal */</span>,
    "agPartial": <var>int</var> <span class="opt">/* Internal */</span>,
    "description": <var>DiskDescritpion</var>,
    "device": <var>string</var>,
    "empty": <var>bool</var>,
    "entriesAllocated": <var>int</var>,
    "entriesCount": <var>int</var>,
    "entriesFree": <var>int</var>,
    "generationLeft": <var>long</var>,
    "id": <var>DiskID</var>,
    "model": <var>string</var>,
    "objects": {
      "<var>int</var>": {
        "generation": <var>long</var>,
        "objectId": <var>int</var> <span class="opt">/* Internal */</span>,
        "onDiskSize": <var>int</var>,
        "parentVolume": <var>string</var>,
        "state": <var>ObjectState</var>,
        "storedSize": <var>int</var>,
        "version": <var>long</var>,
        "volume": <var>string</var>,
        "volumeId": <var>long</var> <span class="opt">/* Internal */</span>
      }, ...
    },
    "objectsAllocated": <var>int</var>,
    "objectsCount": <var>int</var>,
    "objectsFree": <var>int</var>,
    "objectsOnDiskSize": <var>long</var>,
    "sectorsCount": <var>long</var>,
    "serial": <var>string</var>,
    "serverId": <var>ServerID</var>,
    "softEject": <var>DiskSoftEjectStatus</var>,
    "ssd": <var>bool</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>Disk</strong><ul>
<li class="attribute">agAllocated:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agCount:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFree:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFreeing:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizeFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizePartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agPartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li><li class="attribute">device:  (<strong><a href="#string">string</a></strong>): The name of the physical disk device on the server.</li><li class="attribute">empty:  (<strong><a href="#bool">bool</a></strong>): True if no volumes or snapshots are on this disk.</li><li class="attribute">entriesAllocated:  (<strong><a href="#int">int</a></strong>): Used entries of the disk.</li><li class="attribute">entriesCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of entries that can exists on the disk.</li><li class="attribute">entriesFree:  (<strong><a href="#int">int</a></strong>): The remaining number of entries that can be stored on the disk.</li><li class="attribute">generationLeft:  (<strong><a href="#long">long</a></strong>): The last cluster generation when the disk was active on a running server, or -1 if the disk is currently active.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>)</li><li class="attribute">model:  (<strong><a href="#string">string</a></strong>)</li><li class="attribute">objects:  Detailed information about each object on the disk.A dict from int to DiskObject
<ul>
<li>Key type: <strong><a href="#int">int</a></strong></li>
<li>Value type: <strong>DiskObject</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The generation when the last write to this object occurred.</li><li class="attribute">objectId:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">onDiskSize:  (<strong><a href="#int">int</a></strong>): The space allocated on the disk for the object. This can go up to 32MB.</li><li class="attribute">parentVolume:  (<strong><a href="#string">string</a></strong>): The name of the parent snapshot.</li><li class="attribute">state:  (<strong><a href="#ObjectState">ObjectState</a></strong>)</li><li class="attribute">storedSize:  (<strong><a href="#int">int</a></strong>): The size of the actual data in that object (&lt;= onDiskSize).</li><li class="attribute">version:  (<strong><a href="#long">long</a></strong>): With each write the version is increased.</li><li class="attribute">volume:  (<strong><a href="#string">string</a></strong>): The name of the volume for which the object contains data.</li><li class="attribute">volumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li></ul>
</li>
</ul>
</li><li class="attribute">objectsAllocated:  (<strong><a href="#int">int</a></strong>): Used objects of the disk.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">objectsFree:  (<strong><a href="#int">int</a></strong>): The remaining number of objects that can be stored on the disk.</li><li class="attribute">objectsOnDiskSize:  (<strong><a href="#long">long</a></strong>): Total size occupied by objects. In essence, this is the estimated disk usage by StorPool.</li><li class="attribute">sectorsCount:  (<strong><a href="#long">long</a></strong>): The amount of 512-byte sectors on the disk.</li><li class="attribute">serial:  (<strong><a href="#string">string</a></strong>)</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>)</li><li class="attribute">softEject:  (<strong><a href="#DiskSoftEjectStatus">DiskSoftEjectStatus</a></strong>): The status of the soft-eject process.</li><li class="attribute">ssd:  (<strong><a href="#bool">bool</a></strong>): Whether the device is an SSD.</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Clients">Clients</h2>
<p></p>
<h3 id="ClientsConfigDump">Get the current status of all the clients (<strong>ClientsConfigDump</strong>)</h3>
<p>Return the status of each client including its current generation and
	generation update status.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ClientsConfigDump HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ClientsConfigDump</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "clientGeneration": <var>long</var>,
    "configStatus": <var>client status</var>,
    "delay": <var>int</var>,
    "generation": <var>long</var>,
    "id": <var>ClientID</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>ClientConfigStatus</strong><ul>
<li class="attribute">clientGeneration:  (<strong><a href="#long">long</a></strong>): The generation of the specific client.</li><li class="attribute">configStatus:  (<strong><a href="#client status">client status</a></strong>): Whether there is an update of the configuration in progress.</li><li class="attribute">delay:  (<strong><a href="#int">int</a></strong>): The time it took for the client generation to reach the cluster generation. Only applicable to ClientConfigWait. Always 0 in ClientsConfigDump.</li><li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">id:  (<strong><a href="#ClientID">ClientID</a></strong>)</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="ClientConfigWait">Wait until a client updates to the current configuration (<strong>ClientConfigWait</strong>)</h3>
<p>Return the same JSON as ClientsConfigDump but block until the client
	has updated its configuration information to the current generation at
	the time of the request.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ClientConfigWait/{clientId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ClientConfigWait/{clientId}</em></li>
<li>Arguments: 
<ul>
<li>clientId - <strong>ClientID</strong>: <em>integer, 1 &lt;= value &lt;= 24575</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "clientGeneration": <var>long</var>,
    "configStatus": <var>client status</var>,
    "delay": <var>int</var>,
    "generation": <var>long</var>,
    "id": <var>ClientID</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>ClientConfigStatus</strong><ul>
<li class="attribute">clientGeneration:  (<strong><a href="#long">long</a></strong>): The generation of the specific client.</li><li class="attribute">configStatus:  (<strong><a href="#client status">client status</a></strong>): Whether there is an update of the configuration in progress.</li><li class="attribute">delay:  (<strong><a href="#int">int</a></strong>): The time it took for the client generation to reach the cluster generation. Only applicable to ClientConfigWait. Always 0 in ClientsConfigDump.</li><li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">id:  (<strong><a href="#ClientID">ClientID</a></strong>)</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="ClientActiveRequests">List all the active requests on a client (<strong>ClientActiveRequests</strong>)</h3>
<p>List detailed information about the requests being currently processed on
	the given client.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/ClientActiveRequests/{clientId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/ClientActiveRequests/{clientId}</em></li>
<li>Arguments: 
<ul>
<li>clientId - <strong>ClientID</strong>: <em>integer, 1 &lt;= value &lt;= 24575</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "clientId": <var>ClientID</var>,
    "requests": [{
      "address": <var>long</var>,
      "drOp": <var>string</var> <span class="opt">/* Internal */</span>,
      "msecActive": <var>int</var>,
      "op": <var>RequestOp</var>,
      "prevState": <var>string</var> <span class="opt">/* Internal */</span>,
      "requestId": <var>string</var>,
      "requestIdx": <var>int</var>,
      "size": <var>int</var>,
      "state": <var>string</var> <span class="opt">/* Internal */</span>,
      "volume": Either(<var>VolumeName</var>, <var>SnapshotName</var>)
    }, ...]
  }
}
</code></pre></li>
<li>Response Data:
<strong>ClientActiveRequests</strong><ul>
<li class="attribute">clientId:  (<strong><a href="#ClientID">ClientID</a></strong>)</li><li class="attribute">requests:  A detailed listing of all the requests associated with the given client.<ul>Element type: <strong>ActiveRequestDesc</strong><ul>
<li class="attribute">address:  (<strong><a href="#long">long</a></strong>): The offset in bytes within the logical volume.</li><li class="attribute">drOp:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">msecActive:  (<strong><a href="#int">int</a></strong>): Time in microseconds since the request was submitted.</li><li class="attribute">op:  (<strong><a href="#RequestOp">RequestOp</a></strong>): The type of the requested operation; one of read, write, system, merge, entries flush, #bad_state, #bad_drOp</li><li class="attribute">prevState:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">requestId:  (<strong><a href="#string">string</a></strong>): A unique request ID that may be matched between clients and disks.</li><li class="attribute">requestIdx:  (<strong><a href="#int">int</a></strong>): A temporary local request identifier for this request on this client or disk.</li><li class="attribute">size:  (<strong><a href="#int">int</a></strong>): The size of the request in bytes.</li><li class="attribute">state:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">volume: The value must be of one of the following types: VolumeName, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#VolumeName">VolumeName</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li></ul>

</li></ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="AoE-Targets">AoE Targets</h2>
<p></p>
<h3 id="AoeStatus">Display AoE status (<strong>AoeStatus</strong>)</h3>
<p>List the StorPool volumes and snapshots exported over AoE.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/AoeStatus HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/AoeStatus</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "aoeId": <var>string</var>,
    "name": Either(<var>VolumeName</var>, <var>SnapshotName</var>),
    "snapshot": <var>bool</var>,
    "status": <var>AoeExportStatus</var>,
    "target": Either(<var>null</var>, <var>AoeTargetID</var>)
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>AoeExport</strong><ul>
<li class="attribute">aoeId:  (<strong><a href="#string">string</a></strong>): The AoE identifier that the volume is exported as.</li><li class="attribute">name:  The name of the StorPool volume.The value must be of one of the following types: VolumeName, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#VolumeName">VolumeName</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">snapshot:  (<strong><a href="#bool">bool</a></strong>): True if this entry describes a snapshot instead of a volume.</li><li class="attribute">status:  (<strong><a href="#AoeExportStatus">AoeExportStatus</a></strong>): The status of the StorPool AoE target node if target is set.</li><li class="attribute">target:  The StorPool node that serves as an AoE target to export this volume.The value must be of one of the following types: null, AoeTargetID.
<ul><em>Subtypes:</em>
<li><strong><a href="#null">null</a></strong></li>
<li><strong><a href="#AoeTargetID">AoeTargetID</a></strong></li>
</ul>
</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="AoeExportVolume">Export a volume (<strong>AoeExportVolume</strong>)</h3>
<p>Export the specified volume over AoE.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/AoeExportVolume/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/AoeExportVolume/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="AoeExportSnapshot">Unexport a volume (<strong>AoeExportSnapshot</strong>)</h3>
<p>Export the specified snapshot over AoE.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/AoeExportSnapshot/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/AoeExportSnapshot/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="AoeUnexportVolume">Export a snapshot (<strong>AoeUnexportVolume</strong>)</h3>
<p>Stop exporting the specified volume over AoE.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/AoeUnexportVolume/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/AoeUnexportVolume/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="AoeUnexportSnapshot">Unexport a snaphot (<strong>AoeUnexportSnapshot</strong>)</h3>
<p>Stop exporting the specified snapshot over AoE.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/AoeUnexportSnapshot/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/AoeUnexportSnapshot/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="AoeTargetActiveRequests">List all active requests on an AoE target (<strong>AoeTargetActiveRequests</strong>)</h3>
<p>List detailed information about the requests being currently processed on
	the given AoE target</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/AoeTargetActiveRequests/{aoeTargetId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/AoeTargetActiveRequests/{aoeTargetId}</em></li>
<li>Arguments: 
<ul>
<li>aoeTargetId - <strong>AoeTargetID</strong>: <em>integer, 1 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "aoeTargetId": <var>AoeTargetID</var>,
    "requests": [{
      "address": <var>long</var>,
      "drOp": <var>string</var> <span class="opt">/* Internal */</span>,
      "msecActive": <var>int</var>,
      "op": <var>RequestOp</var>,
      "prevState": <var>string</var> <span class="opt">/* Internal */</span>,
      "requestId": <var>string</var>,
      "requestIdx": <var>int</var>,
      "size": <var>int</var>,
      "state": <var>string</var> <span class="opt">/* Internal */</span>,
      "volume": Either(<var>VolumeName</var>, <var>SnapshotName</var>)
    }, ...]
  }
}
</code></pre></li>
<li>Response Data:
<strong>AoeTargetActiveRequests</strong><ul>
<li class="attribute">aoeTargetId:  (<strong><a href="#AoeTargetID">AoeTargetID</a></strong>)</li><li class="attribute">requests:  A detailed listing of all the requests associated with the given AoE target.<ul>Element type: <strong>ActiveRequestDesc</strong><ul>
<li class="attribute">address:  (<strong><a href="#long">long</a></strong>): The offset in bytes within the logical volume.</li><li class="attribute">drOp:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">msecActive:  (<strong><a href="#int">int</a></strong>): Time in microseconds since the request was submitted.</li><li class="attribute">op:  (<strong><a href="#RequestOp">RequestOp</a></strong>): The type of the requested operation; one of read, write, system, merge, entries flush, #bad_state, #bad_drOp</li><li class="attribute">prevState:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">requestId:  (<strong><a href="#string">string</a></strong>): A unique request ID that may be matched between clients and disks.</li><li class="attribute">requestIdx:  (<strong><a href="#int">int</a></strong>): A temporary local request identifier for this request on this client or disk.</li><li class="attribute">size:  (<strong><a href="#int">int</a></strong>): The size of the request in bytes.</li><li class="attribute">state:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">volume: The value must be of one of the following types: VolumeName, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#VolumeName">VolumeName</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li></ul>

</li></ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Disks">Disks</h2>
<p></p>
<h3 id="DisksList">List all disks (<strong>DisksList</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/DisksList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/DisksList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>DiskID</var>": {
      "agAllocated": <var>int</var> <span class="opt">/* Internal */</span>,
      "agCount": <var>int</var> <span class="opt">/* Internal */</span>,
      "agFree": <var>int</var> <span class="opt">/* Internal */</span>,
      "agFreeing": <var>int</var> <span class="opt">/* Internal */</span>,
      "agFull": <var>int</var> <span class="opt">/* Internal */</span>,
      "agMaxSizeFull": <var>int</var> <span class="opt">/* Internal */</span>,
      "agMaxSizePartial": <var>int</var> <span class="opt">/* Internal */</span>,
      "agPartial": <var>int</var> <span class="opt">/* Internal */</span>,
      "description": <var>DiskDescritpion</var>,
      "device": <var>string</var>,
      "empty": <var>bool</var>,
      "entriesAllocated": <var>int</var>,
      "entriesCount": <var>int</var>,
      "entriesFree": <var>int</var>,
      "generationLeft": <var>long</var>,
      "id": <var>DiskID</var>,
      "model": <var>string</var>,
      "objectsAllocated": <var>int</var>,
      "objectsCount": <var>int</var>,
      "objectsFree": <var>int</var>,
      "objectsOnDiskSize": <var>long</var>,
      "sectorsCount": <var>long</var>,
      "serial": <var>string</var>,
      "serverId": <var>ServerID</var>,
      "softEject": <var>DiskSoftEjectStatus</var>,
      "ssd": <var>bool</var>
    }, ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from DiskID to DiskSummary
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: <strong>DiskSummary</strong><ul>
<li class="attribute">agAllocated:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agCount:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFree:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFreeing:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizeFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizePartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agPartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li><li class="attribute">device:  (<strong><a href="#string">string</a></strong>): The name of the physical disk device on the server.</li><li class="attribute">empty:  (<strong><a href="#bool">bool</a></strong>): True if no volumes or snapshots are on this disk.</li><li class="attribute">entriesAllocated:  (<strong><a href="#int">int</a></strong>): Used entries of the disk.</li><li class="attribute">entriesCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of entries that can exists on the disk.</li><li class="attribute">entriesFree:  (<strong><a href="#int">int</a></strong>): The remaining number of entries that can be stored on the disk.</li><li class="attribute">generationLeft:  (<strong><a href="#long">long</a></strong>): The last cluster generation when the disk was active on a running server, or -1 if the disk is currently active.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>)</li><li class="attribute">model:  (<strong><a href="#string">string</a></strong>)</li><li class="attribute">objectsAllocated:  (<strong><a href="#int">int</a></strong>): Used objects of the disk.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">objectsFree:  (<strong><a href="#int">int</a></strong>): The remaining number of objects that can be stored on the disk.</li><li class="attribute">objectsOnDiskSize:  (<strong><a href="#long">long</a></strong>): Total size occupied by objects. In essence, this is the estimated disk usage by StorPool.</li><li class="attribute">sectorsCount:  (<strong><a href="#long">long</a></strong>): The amount of 512-byte sectors on the disk.</li><li class="attribute">serial:  (<strong><a href="#string">string</a></strong>)</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>)</li><li class="attribute">softEject:  (<strong><a href="#DiskSoftEjectStatus">DiskSoftEjectStatus</a></strong>): The status of the soft-eject process.</li><li class="attribute">ssd:  (<strong><a href="#bool">bool</a></strong>): Whether the device is an SSD.</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskDescribe">Describe a disk (<strong>DiskDescribe</strong>)</h3>
<p>List all disks including detailed information about the objects on each disk.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/DiskDescribe/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/DiskDescribe/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "agAllocated": <var>int</var> <span class="opt">/* Internal */</span>,
    "agCount": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFree": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFreeing": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFull": <var>int</var> <span class="opt">/* Internal */</span>,
    "agMaxSizeFull": <var>int</var> <span class="opt">/* Internal */</span>,
    "agMaxSizePartial": <var>int</var> <span class="opt">/* Internal */</span>,
    "agPartial": <var>int</var> <span class="opt">/* Internal */</span>,
    "description": <var>DiskDescritpion</var>,
    "device": <var>string</var>,
    "empty": <var>bool</var>,
    "entriesAllocated": <var>int</var>,
    "entriesCount": <var>int</var>,
    "entriesFree": <var>int</var>,
    "generationLeft": <var>long</var>,
    "id": <var>DiskID</var>,
    "model": <var>string</var>,
    "objects": {
      "<var>int</var>": {
        "generation": <var>long</var>,
        "objectId": <var>int</var> <span class="opt">/* Internal */</span>,
        "onDiskSize": <var>int</var>,
        "parentVolume": <var>string</var>,
        "state": <var>ObjectState</var>,
        "storedSize": <var>int</var>,
        "version": <var>long</var>,
        "volume": <var>string</var>,
        "volumeId": <var>long</var> <span class="opt">/* Internal */</span>
      }, ...
    },
    "objectsAllocated": <var>int</var>,
    "objectsCount": <var>int</var>,
    "objectsFree": <var>int</var>,
    "objectsOnDiskSize": <var>long</var>,
    "sectorsCount": <var>long</var>,
    "serial": <var>string</var>,
    "serverId": <var>ServerID</var>,
    "softEject": <var>DiskSoftEjectStatus</var>,
    "ssd": <var>bool</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>Disk</strong><ul>
<li class="attribute">agAllocated:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agCount:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFree:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFreeing:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizeFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizePartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agPartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li><li class="attribute">device:  (<strong><a href="#string">string</a></strong>): The name of the physical disk device on the server.</li><li class="attribute">empty:  (<strong><a href="#bool">bool</a></strong>): True if no volumes or snapshots are on this disk.</li><li class="attribute">entriesAllocated:  (<strong><a href="#int">int</a></strong>): Used entries of the disk.</li><li class="attribute">entriesCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of entries that can exists on the disk.</li><li class="attribute">entriesFree:  (<strong><a href="#int">int</a></strong>): The remaining number of entries that can be stored on the disk.</li><li class="attribute">generationLeft:  (<strong><a href="#long">long</a></strong>): The last cluster generation when the disk was active on a running server, or -1 if the disk is currently active.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>)</li><li class="attribute">model:  (<strong><a href="#string">string</a></strong>)</li><li class="attribute">objects:  Detailed information about each object on the disk.A dict from int to DiskObject
<ul>
<li>Key type: <strong><a href="#int">int</a></strong></li>
<li>Value type: <strong>DiskObject</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The generation when the last write to this object occurred.</li><li class="attribute">objectId:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">onDiskSize:  (<strong><a href="#int">int</a></strong>): The space allocated on the disk for the object. This can go up to 32MB.</li><li class="attribute">parentVolume:  (<strong><a href="#string">string</a></strong>): The name of the parent snapshot.</li><li class="attribute">state:  (<strong><a href="#ObjectState">ObjectState</a></strong>)</li><li class="attribute">storedSize:  (<strong><a href="#int">int</a></strong>): The size of the actual data in that object (&lt;= onDiskSize).</li><li class="attribute">version:  (<strong><a href="#long">long</a></strong>): With each write the version is increased.</li><li class="attribute">volume:  (<strong><a href="#string">string</a></strong>): The name of the volume for which the object contains data.</li><li class="attribute">volumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li></ul>
</li>
</ul>
</li><li class="attribute">objectsAllocated:  (<strong><a href="#int">int</a></strong>): Used objects of the disk.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">objectsFree:  (<strong><a href="#int">int</a></strong>): The remaining number of objects that can be stored on the disk.</li><li class="attribute">objectsOnDiskSize:  (<strong><a href="#long">long</a></strong>): Total size occupied by objects. In essence, this is the estimated disk usage by StorPool.</li><li class="attribute">sectorsCount:  (<strong><a href="#long">long</a></strong>): The amount of 512-byte sectors on the disk.</li><li class="attribute">serial:  (<strong><a href="#string">string</a></strong>)</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>)</li><li class="attribute">softEject:  (<strong><a href="#DiskSoftEjectStatus">DiskSoftEjectStatus</a></strong>): The status of the soft-eject process.</li><li class="attribute">ssd:  (<strong><a href="#bool">bool</a></strong>): Whether the device is an SSD.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskGetInfo">Get disk info (<strong>DiskGetInfo</strong>)</h3>
<p>List all disks including information about the volumes stored on each disk.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/DiskGetInfo/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/DiskGetInfo/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "agAllocated": <var>int</var> <span class="opt">/* Internal */</span>,
    "agCount": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFree": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFreeing": <var>int</var> <span class="opt">/* Internal */</span>,
    "agFull": <var>int</var> <span class="opt">/* Internal */</span>,
    "agMaxSizeFull": <var>int</var> <span class="opt">/* Internal */</span>,
    "agMaxSizePartial": <var>int</var> <span class="opt">/* Internal */</span>,
    "agPartial": <var>int</var> <span class="opt">/* Internal */</span>,
    "description": <var>DiskDescritpion</var>,
    "device": <var>string</var>,
    "empty": <var>bool</var>,
    "entriesAllocated": <var>int</var>,
    "entriesCount": <var>int</var>,
    "entriesFree": <var>int</var>,
    "generationLeft": <var>long</var>,
    "id": <var>DiskID</var>,
    "model": <var>string</var>,
    "objectStates": {
      "<var>ObjectState</var>": <var>int</var>, ...
    },
    "objectsAllocated": <var>int</var>,
    "objectsCount": <var>int</var>,
    "objectsFree": <var>int</var>,
    "objectsOnDiskSize": <var>long</var>,
    "sectorsCount": <var>long</var>,
    "serial": <var>string</var>,
    "serverId": <var>ServerID</var>,
    "softEject": <var>DiskSoftEjectStatus</var>,
    "ssd": <var>bool</var>,
    "volumeInfos": {
      "<var>string</var>": {
        "name": <var>string</var>,
        "objectStates": {
          "<var>ObjectState</var>": <var>int</var>, ...
        },
        "objectsCount": <var>long</var>,
        "onDiskSize": <var>long</var>,
        "storedSize": <var>long</var>
      }, ...
    }
  }
}
</code></pre></li>
<li>Response Data:
<strong>DiskInfo</strong><ul>
<li class="attribute">agAllocated:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agCount:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFree:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFreeing:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizeFull:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agMaxSizePartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">agPartial:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li><li class="attribute">device:  (<strong><a href="#string">string</a></strong>): The name of the physical disk device on the server.</li><li class="attribute">empty:  (<strong><a href="#bool">bool</a></strong>): True if no volumes or snapshots are on this disk.</li><li class="attribute">entriesAllocated:  (<strong><a href="#int">int</a></strong>): Used entries of the disk.</li><li class="attribute">entriesCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of entries that can exists on the disk.</li><li class="attribute">entriesFree:  (<strong><a href="#int">int</a></strong>): The remaining number of entries that can be stored on the disk.</li><li class="attribute">generationLeft:  (<strong><a href="#long">long</a></strong>): The last cluster generation when the disk was active on a running server, or -1 if the disk is currently active.</li><li class="attribute">id:  (<strong><a href="#DiskID">DiskID</a></strong>)</li><li class="attribute">model:  (<strong><a href="#string">string</a></strong>)</li><li class="attribute">objectStates: A dict from ObjectState to int
<ul>
<li>Key type: <strong><a href="#ObjectState">ObjectState</a></strong></li>
<li>Value type: <strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">objectsAllocated:  (<strong><a href="#int">int</a></strong>): Used objects of the disk.</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The maximum amount of object that can exists on the disk.</li><li class="attribute">objectsFree:  (<strong><a href="#int">int</a></strong>): The remaining number of objects that can be stored on the disk.</li><li class="attribute">objectsOnDiskSize:  (<strong><a href="#long">long</a></strong>): Total size occupied by objects. In essence, this is the estimated disk usage by StorPool.</li><li class="attribute">sectorsCount:  (<strong><a href="#long">long</a></strong>): The amount of 512-byte sectors on the disk.</li><li class="attribute">serial:  (<strong><a href="#string">string</a></strong>)</li><li class="attribute">serverId:  (<strong><a href="#ServerID">ServerID</a></strong>)</li><li class="attribute">softEject:  (<strong><a href="#DiskSoftEjectStatus">DiskSoftEjectStatus</a></strong>): The status of the soft-eject process.</li><li class="attribute">ssd:  (<strong><a href="#bool">bool</a></strong>): Whether the device is an SSD.</li><li class="attribute">volumeInfos:  Detailed information about the volumes that have data stored on the disk.A dict from str to DiskVolumeInfo
<ul>
<li>Key type: <strong><a href="#string">string</a></strong></li>
<li>Value type: <strong>DiskVolumeInfo</strong><ul>
<li class="attribute">name:  (<strong><a href="#string">string</a></strong>)</li><li class="attribute">objectStates:  For each state, the number of objects that are in that state. 0-undefined 1-ok 2-outdated 3-in_recovery 4-waiting_for_version 5-waiting_for_disk 6-data_not_present 7-data_lost 8-waiting_for_chain 9-wait_idleA dict from ObjectState to int
<ul>
<li>Key type: <strong><a href="#ObjectState">ObjectState</a></strong></li>
<li>Value type: <strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#long">long</a></strong>): The number of objects of the volume stored on this disk.</li><li class="attribute">onDiskSize:  (<strong><a href="#long">long</a></strong>): The space allocated on the disk for the object. This can go up to 32MB.</li><li class="attribute">storedSize:  (<strong><a href="#long">long</a></strong>): The size of the actual data in that object (&lt;= onDiskSize).</li></ul>
</li>
</ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskEject">Eject a disk (<strong>DiskEject</strong>)</h3>
<p>Stop operations on the given disk even if it is not empty.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskEject/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskEject/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskForget">Forget a disk (<strong>DiskForget</strong>)</h3>
<p>Remove the disk from any placement groups or volumes that it is used in.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskForget/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskForget/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskSoftEject">Soft-eject a disk (<strong>DiskSoftEject</strong>)</h3>
<p>Stop writes to the given disk and start relocating all the data stored on it to other disks.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskSoftEject/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskSoftEject/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskSoftEjectPause">Pause a disk&apos;s soft-eject operation (<strong>DiskSoftEjectPause</strong>)</h3>
<p>Temporarily pause the relocation tasks for the disk. This can be helpful in heavy load situations.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskSoftEjectPause/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskSoftEjectPause/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskSoftEjectCancel">Cancel a disk&apos;s soft-eject operation (<strong>DiskSoftEjectCancel</strong>)</h3>
<p>Stop the relocation tasks for the disk and mark it as usable again. After this operation data will be moved back to the disk.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskSoftEjectCancel/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskSoftEjectCancel/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskSetDescription">Set a disk&apos;s description (<strong>DiskSetDescription</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/DiskSetDescription/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "description": <var>DiskDescritpion</var>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/DiskSetDescription/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <strong>DiskDescUpdate</strong><ul>
<li class="attribute">description:  (<strong><a href="#DiskDescritpion">DiskDescritpion</a></strong>): A user-defined description of the disk for easier identification of the device.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="DiskActiveRequests">List all the active requests on a disk (<strong>DiskActiveRequests</strong>)</h3>
<p>List detailed information about the requests being currently processed
	on the given disk.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/DiskActiveRequests/{diskId} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/DiskActiveRequests/{diskId}</em></li>
<li>Arguments: 
<ul>
<li>diskId - <strong>DiskID</strong>: <em>integer, 0 &lt;= value &lt;= 4095</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "diskId": <var>DiskID</var>,
    "requests": [{
      "address": <var>long</var>,
      "drOp": <var>string</var> <span class="opt">/* Internal */</span>,
      "msecActive": <var>int</var>,
      "op": <var>RequestOp</var>,
      "prevState": <var>string</var> <span class="opt">/* Internal */</span>,
      "requestId": <var>string</var>,
      "requestIdx": <var>int</var>,
      "size": <var>int</var>,
      "state": <var>string</var> <span class="opt">/* Internal */</span>,
      "volume": Either(<var>VolumeName</var>, <var>SnapshotName</var>)
    }, ...]
  }
}
</code></pre></li>
<li>Response Data:
<strong>DiskActiveRequests</strong><ul>
<li class="attribute">diskId:  (<strong><a href="#DiskID">DiskID</a></strong>)</li><li class="attribute">requests:  A detailed listing of all the requests associated with the given disk.<ul>Element type: <strong>ActiveRequestDesc</strong><ul>
<li class="attribute">address:  (<strong><a href="#long">long</a></strong>): The offset in bytes within the logical volume.</li><li class="attribute">drOp:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">msecActive:  (<strong><a href="#int">int</a></strong>): Time in microseconds since the request was submitted.</li><li class="attribute">op:  (<strong><a href="#RequestOp">RequestOp</a></strong>): The type of the requested operation; one of read, write, system, merge, entries flush, #bad_state, #bad_drOp</li><li class="attribute">prevState:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">requestId:  (<strong><a href="#string">string</a></strong>): A unique request ID that may be matched between clients and disks.</li><li class="attribute">requestIdx:  (<strong><a href="#int">int</a></strong>): A temporary local request identifier for this request on this client or disk.</li><li class="attribute">size:  (<strong><a href="#int">int</a></strong>): The size of the request in bytes.</li><li class="attribute">state:  (<span class="opt">Internal</span> <strong><a href="#string">string</a></strong>): An internal attribute used only for debugging. We strongly recommend that you do not use this attribute in any kind of automation.</li><li class="attribute">volume: The value must be of one of the following types: VolumeName, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#VolumeName">VolumeName</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li></ul>

</li></ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Volumes">Volumes</h2>
<p></p>
<h3 id="VolumesList">List all volumes (<strong>VolumesList</strong>)</h3>
<p>Return configuration information about all the volumes.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumesList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumesList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objectsCount": <var>int</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>VolumeSummary</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>)</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">templateName:  The template that the volume&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumesGetStatus">Get volume and snapshot status (<strong>VolumesGetStatus</strong>)</h3>
<p>Return the status of each volume and snapshot.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumesGetStatus HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumesGetStatus</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>VolumeName</var>": {
      "balancerBlocked": <var>bool</var>,
      "decreasedRedundancy": <var>bool</var>,
      "downBytes": <var>int</var>,
      "downDrives": [<var>DiskID</var>, ...],
      "migrating": <var>bool</var>,
      "missingDrives": [<var>DiskID</var>, ...],
      "missingTargetDrives": [<var>DiskID</var>, ...],
      "name": <var>VolumeName</var>,
      "onDiskSize": <var>int</var>,
      "replication": <var>Replication</var>,
      "size": <var>Size</var>,
      "snapshot": <var>bool</var>,
      "softEjectingDrives": [<var>DiskID</var>, ...],
      "status": <var>VolumeCurentStatus</var>,
      "storedSize": <var>int</var>,
      "syncingDataBytes": <var>int</var>,
      "syncingMetaObjects": <var>int</var>
    }, ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from VolumeName to VolumeStatus
<ul>
<li>Key type: <strong><a href="#VolumeName">VolumeName</a></strong></li>
<li>Value type: <strong>VolumeStatus</strong><ul>
<li class="attribute">balancerBlocked:  (<strong><a href="#bool">bool</a></strong>)</li><li class="attribute">decreasedRedundancy:  (<strong><a href="#bool">bool</a></strong>): True if any of the replicas of the volume are missing.</li><li class="attribute">downBytes:  (<strong><a href="#int">int</a></strong>): The number of bytes of the volume that are not accessible at the moment.</li><li class="attribute">downDrives:  The IDs of the drives that are not accessible at the moment but needed by this volume. The volume will be in the &apos;down&apos; status until all or some of these drives reappear.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">migrating:  (<strong><a href="#bool">bool</a></strong>): True if there are tasks for reallocation of the volume.</li><li class="attribute">missingDrives:  The IDs of the drives that are not accessible at the moment. The volume has all the needed data on the rest of the disks and can continue serving requests but it is in the &apos;degraded&apos; status.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">missingTargetDrives: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>)</li><li class="attribute">onDiskSize:  (<strong><a href="#int">int</a></strong>): The actual size that the objects of this volume occupy on the disks.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">snapshot:  (<strong><a href="#bool">bool</a></strong>): True if this response describes a snapshot instead of a volume.</li><li class="attribute">softEjectingDrives: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">status:  (<strong><a href="#VolumeCurentStatus">VolumeCurentStatus</a></strong>): up - The volume is operational. up soon - Synchronizing versions of objects after a disk has come back up. data lost - The last copy of some of the data in the volume has been lost. down - Some or all of the objects of the volume are missing and the volume is not in a state to continue serving operations.</li><li class="attribute">storedSize:  (<strong><a href="#int">int</a></strong>): The number of bytes of client data on the volume. This does not take into account the StorPool replication and overhead, thus it is never larger than the volume size.</li><li class="attribute">syncingDataBytes:  (<strong><a href="#int">int</a></strong>): The total number of bytes in objects currently being synchronized (degraded objects or objects with not yet known version)</li><li class="attribute">syncingMetaObjects:  (<strong><a href="#int">int</a></strong>): The number of objects currently being synchronized (degraded objects or objects with not yet known version)</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Volume">List a single volume (<strong>Volume</strong>)</h3>
<p>Same as VolumeList but only return information about a given volume.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/Volume/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/Volume/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objectsCount": <var>int</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>VolumeSummary</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>)</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">templateName:  The template that the volume&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeDescribe">Describe a volume (<strong>VolumeDescribe</strong>)</h3>
<p>Return detailed information about the distribution of the volume&apos;s data on
	the disks.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeDescribe/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeDescribe/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objects": [[<var>DiskID</var>, ...], ...],
    "objectsCount": <var>int</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "targetDiskSets": [[<var>DiskID</var>, ...], ...],
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>Volume</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>)</li><li class="attribute">objects:  Where each object is actually stored.<ul>Element type: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>

</li></ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">targetDiskSets:  Sets of disks that the volume&apos;s data should be stored on.<ul>Element type: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>

</li></ul>
</li><li class="attribute">templateName:  The template that the volume&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeGetInfo">Get volume info (<strong>VolumeGetInfo</strong>)</h3>
<p>Return general information about the distribution of the volume&apos;s data on
	the disks.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeGetInfo/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeGetInfo/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "disksCount": <var>int</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objectsCount": <var>int</var>,
    "objectsPerChain": [{
      "count": <var>int</var>,
      "disks": [<var>DiskID</var>, ...]
    }, ...],
    "objectsPerDisk": {
      "<var>DiskID</var>": <var>int</var>, ...
    },
    "objectsPerDiskSet": [{
      "count": <var>int</var>,
      "disks": [<var>DiskID</var>, ...]
    }, ...],
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>VolumeInfo</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>)</li><li class="attribute">disksCount:  (<strong><a href="#int">int</a></strong>)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>)</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">objectsPerChain: <ul>Element type: <strong>VolumeChainStat</strong><ul>
<li class="attribute">count:  (<strong><a href="#int">int</a></strong>): The number of objects on the disks.</li><li class="attribute">disks:  IDs of the disks.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li></ul>

</li></ul>
</li><li class="attribute">objectsPerDisk: A dict from DiskID to int
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: <strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">objectsPerDiskSet: <ul>Element type: <strong>VolumeChainStat</strong><ul>
<li class="attribute">count:  (<strong><a href="#int">int</a></strong>): The number of objects on the disks.</li><li class="attribute">disks:  IDs of the disks.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li></ul>

</li></ul>
</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">templateName:  The template that the volume&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeListSnapshots">List the parent snapshots of a volume (<strong>VolumeListSnapshots</strong>)</h3>
<p>List a volume&apos;s parent snapshots in the same format as
	VolumeList</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeListSnapshots/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeListSnapshots/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objectsCount": <var>int</var>,
    "onVolume": <var>VolumeName</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>SnapshotSummary</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>)</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">onVolume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume that this is a parent of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">templateName:  The template that the volume&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeCreate">Create a new volume (<strong>VolumeCreate</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeCreate HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "bw": <var>Bandwidth</var> <span class="opt">/* Optional */</span>,
  "iops": <var>IOPS</var> <span class="opt">/* Optional */</span>,
  "name": <var>VolumeName</var>,
  "parent": <var>SnapshotName</var> <span class="opt">/* Optional */</span>,
  "placeAll": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeTail": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "replication": <var>Replication</var> <span class="opt">/* Optional */</span>,
  "size": <var>Size</var>,
  "template": <var>VolumeTemplateName</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeCreate</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>VolumeCreateDesc</strong><ul>
<li class="attribute">bw:  (<span class="opt">Optional</span> <strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">iops:  (<span class="opt">Optional</span> <strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume to be created.</li><li class="attribute">parent:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the snapshot that the new volume is based on.</li><li class="attribute">placeAll:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<span class="opt">Optional</span> <strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">template:  (<span class="opt">Optional</span> <strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>): The name of the template that the settings of the new volume are based on.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeUpdate">Update a volume (<strong>VolumeUpdate</strong>)</h3>
<p>Alter the configuration of an existing volume.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeUpdate/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "bw": <var>Bandwidth</var> <span class="opt">/* Optional */</span>,
  "iops": <var>IOPS</var> <span class="opt">/* Optional */</span>,
  "placeAll": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeTail": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "rename": <var>VolumeName</var> <span class="opt">/* Optional */</span>,
  "replication": <var>Replication</var> <span class="opt">/* Optional */</span>,
  "shrinkOk": <var>bool</var> <span class="opt">/* Optional */</span>,
  "size": <var>Size</var> <span class="opt">/* Optional */</span>,
  "sizeAdd": <var>SizeAdd</var> <span class="opt">/* Optional */</span>,
  "template": <var>VolumeTemplateName</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeUpdate/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <strong>VolumeUpdateDesc</strong><ul>
<li class="attribute">bw:  (<span class="opt">Optional</span> <strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">iops:  (<span class="opt">Optional</span> <strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">placeAll:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">rename:  (<span class="opt">Optional</span> <strong><a href="#VolumeName">VolumeName</a></strong>): The new name to be set.</li><li class="attribute">replication:  (<span class="opt">Optional</span> <strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">shrinkOk:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>)</li><li class="attribute">size:  (<span class="opt">Optional</span> <strong><a href="#Size">Size</a></strong>): The new size in bytes.</li><li class="attribute">sizeAdd:  (<span class="opt">Optional</span> <strong><a href="#SizeAdd">SizeAdd</a></strong>): The number of bytes that the volume&apos;s size should be increased by.</li><li class="attribute">template:  (<span class="opt">Optional</span> <strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>): The new template that the volume&apos;s settings should be based on.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeFreeze">Freeze a volume (<strong>VolumeFreeze</strong>)</h3>
<p>Convert the volume to a snapshot</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeFreeze/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeFreeze/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeRebase">Rebase a volume (<strong>VolumeRebase</strong>)</h3>
<p>Change the parent of the volume by choosing from the ones higher in
	the hierarchy or by rebasing it to no parent.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeRebase/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "parentName": <var>SnapshotName</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeRebase/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <strong>VolumeRebaseDesc</strong><ul>
<li class="attribute">parentName:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of one of the volume&apos;s parents on which to re-base. If left out, it will be re-based to base.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeDelete">Delete a volume (<strong>VolumeDelete</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeDelete/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeDelete/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Snapshots">Snapshots</h2>
<p>Snapshots in their essence are very similar to volumes in the sense
that many operations supported by volumes are also supported by
snapshots (all except write-related operations). They can not be
modified and play an essential role in copy-on-write scenarios.</p>
<h3 id="SnapshotsList">List all snapshots (<strong>SnapshotsList</strong>)</h3>
<p>List all the snapshots in the cluster in the same
	format as VolumeList.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/SnapshotsList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotsList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objectsCount": <var>int</var>,
    "onVolume": <var>VolumeName</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>SnapshotSummary</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>)</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">onVolume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume that this is a parent of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">templateName:  The template that the volume&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="Snapshot">List a single snapshot (<strong>Snapshot</strong>)</h3>
<p>Same as SnapshotList but only return information about a given snapshot.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/Snapshot/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/Snapshot/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objectsCount": <var>int</var>,
    "onVolume": <var>VolumeName</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>SnapshotSummary</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>)</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">onVolume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume that this is a parent of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">templateName:  The template that the volume&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotDescribe">Describe a snapshot (<strong>SnapshotDescribe</strong>)</h3>
<p>Return detailed information about the distribution of the snapshot&apos;s data on the
	disks.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/SnapshotDescribe/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotDescribe/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objects": [[<var>DiskID</var>, ...], ...],
    "objectsCount": <var>int</var>,
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "targetDiskSets": [[<var>DiskID</var>, ...], ...],
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>Volume</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>)</li><li class="attribute">objects:  Where each object is actually stored.<ul>Element type: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>

</li></ul>
</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">targetDiskSets:  Sets of disks that the volume&apos;s data should be stored on.<ul>Element type: <ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>

</li></ul>
</li><li class="attribute">templateName:  The template that the volume&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotGetInfo">Get snapshot info (<strong>SnapshotGetInfo</strong>)</h3>
<p>Return general information about the distribution of the snapshot&apos;s data on the
	disks.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/SnapshotGetInfo/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotGetInfo/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "bw": <var>Bandwidth</var>,
    "creationTimestamp": <var>long</var>,
    "disksCount": <var>int</var>,
    "flags": <var>int</var> <span class="opt">/* Internal */</span>,
    "id": <var>long</var> <span class="opt">/* Internal */</span>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeName</var>,
    "objectsCount": <var>int</var>,
    "objectsPerChain": [{
      "count": <var>int</var>,
      "disks": [<var>DiskID</var>, ...]
    }, ...],
    "objectsPerDisk": {
      "<var>DiskID</var>": <var>int</var>, ...
    },
    "objectsPerDiskSet": [{
      "count": <var>int</var>,
      "disks": [<var>DiskID</var>, ...]
    }, ...],
    "originalParentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "parentVolumeId": <var>long</var> <span class="opt">/* Internal */</span>,
    "placeAll": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": <var>Replication</var>,
    "size": <var>Size</var>,
    "templateName": Either(<var>&quot;&quot;</var>, <var>VolumeTemplateName</var>),
    "visibleVolumeId": <var>long</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>VolumeInfo</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">creationTimestamp:  (<strong><a href="#long">long</a></strong>)</li><li class="attribute">disksCount:  (<strong><a href="#int">int</a></strong>)</li><li class="attribute">flags:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeName">VolumeName</a></strong>)</li><li class="attribute">objectsCount:  (<strong><a href="#int">int</a></strong>): The number of objects that the volume/snapshot is comprised of.</li><li class="attribute">objectsPerChain: <ul>Element type: <strong>VolumeChainStat</strong><ul>
<li class="attribute">count:  (<strong><a href="#int">int</a></strong>): The number of objects on the disks.</li><li class="attribute">disks:  IDs of the disks.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li></ul>

</li></ul>
</li><li class="attribute">objectsPerDisk: A dict from DiskID to int
<ul>
<li>Key type: <strong><a href="#DiskID">DiskID</a></strong></li>
<li>Value type: <strong><a href="#int">int</a></strong></li>
</ul>
</li><li class="attribute">objectsPerDiskSet: <ul>Element type: <strong>VolumeChainStat</strong><ul>
<li class="attribute">count:  (<strong><a href="#int">int</a></strong>): The number of objects on the disks.</li><li class="attribute">disks:  IDs of the disks.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li></ul>

</li></ul>
</li><li class="attribute">originalParentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>)</li><li class="attribute">parentName:  The volume&apos;s parent snapshot.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">parentVolumeId:  (<span class="opt">Internal</span> <strong><a href="#long">long</a></strong>): The ID of the parent snapshot.</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<strong><a href="#Size">Size</a></strong>): The volume&apos;s size in bytes.</li><li class="attribute">templateName:  The template that the volume&apos;s settings are taken from.The value must be of one of the following types: &quot;&quot;, VolumeTemplateName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong></li>
</ul>
</li><li class="attribute">visibleVolumeId:  (<strong><a href="#long">long</a></strong>): The ID by which the volume/snapshot was created.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeSnapshot">Snapshot a volume (<strong>VolumeSnapshot</strong>)</h3>
<p>Create a snapshot of the given volume; the snapshot becomes the parent of
	the volume.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeSnapshot/{volumeName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "name": <var>VolumeName</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeSnapshot/{volumeName}</em></li>
<li>Arguments: 
<ul>
<li>volumeName - <strong>VolumeName</strong>: <em>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <strong>VolumeSnapshotDesc</strong><ul>
<li class="attribute">name:  (<span class="opt">Optional</span> <strong><a href="#VolumeName">VolumeName</a></strong>)</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotUpdate">Update a snapshot (<strong>SnapshotUpdate</strong>)</h3>
<p>Alter the configuration of an existing snapshot.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/SnapshotUpdate/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "bw": <var>Bandwidth</var> <span class="opt">/* Optional */</span>,
  "iops": <var>IOPS</var> <span class="opt">/* Optional */</span>,
  "placeAll": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeTail": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "rename": <var>VolumeName</var> <span class="opt">/* Optional */</span>,
  "replication": <var>Replication</var> <span class="opt">/* Optional */</span>,
  "shrinkOk": <var>bool</var> <span class="opt">/* Optional */</span>,
  "size": <var>Size</var> <span class="opt">/* Optional */</span>,
  "sizeAdd": <var>SizeAdd</var> <span class="opt">/* Optional */</span>,
  "template": <var>VolumeTemplateName</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotUpdate/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <strong>VolumeUpdateDesc</strong><ul>
<li class="attribute">bw:  (<span class="opt">Optional</span> <strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">iops:  (<span class="opt">Optional</span> <strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">placeAll:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">rename:  (<span class="opt">Optional</span> <strong><a href="#VolumeName">VolumeName</a></strong>): The new name to be set.</li><li class="attribute">replication:  (<span class="opt">Optional</span> <strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">shrinkOk:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>)</li><li class="attribute">size:  (<span class="opt">Optional</span> <strong><a href="#Size">Size</a></strong>): The new size in bytes.</li><li class="attribute">sizeAdd:  (<span class="opt">Optional</span> <strong><a href="#SizeAdd">SizeAdd</a></strong>): The number of bytes that the volume&apos;s size should be increased by.</li><li class="attribute">template:  (<span class="opt">Optional</span> <strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>): The new template that the volume&apos;s settings should be based on.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotRebase">Rebase a snapshot (<strong>SnapshotRebase</strong>)</h3>
<p>Change the parent of the snapshot by choosing from the ones higher in
	the hierarchy or by rebasing it to no parent.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/SnapshotRebase/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "parentName": <var>SnapshotName</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotRebase/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <strong>VolumeRebaseDesc</strong><ul>
<li class="attribute">parentName:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of one of the volume&apos;s parents on which to re-base. If left out, it will be re-based to base.</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="SnapshotDelete">Delete a snapshot (<strong>SnapshotDelete</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/SnapshotDelete/{snapshotName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/SnapshotDelete/{snapshotName}</em></li>
<li>Arguments: 
<ul>
<li>snapshotName - <strong>SnapshotName</strong>: <em>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Attachments">Attachments</h2>
<p></p>
<h3 id="AttachmentsList">List all attachments (<strong>AttachmentsList</strong>)</h3>
<p>List the volumes and snapshots currently attached to clients along with
	the read/write rights of each attachment.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/AttachmentsList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/AttachmentsList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "client": <var>ClientID</var>,
    "pos": <var>AttachmentPos</var>,
    "rights": <var>AttachmentRights</var>,
    "snapshot": <var>bool</var>,
    "volume": <var>VolumeName</var>
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>AttachmentDesc</strong><ul>
<li class="attribute">client:  (<strong><a href="#ClientID">ClientID</a></strong>): The ID of the client on which it is attached.</li><li class="attribute">pos:  (<strong><a href="#AttachmentPos">AttachmentPos</a></strong>): The attachment position on the client; used by the StorPool client to form the name of the internal /dev/spN device node.</li><li class="attribute">rights:  (<strong><a href="#AttachmentRights">AttachmentRights</a></strong>): Whether the volume is attached as read only or read/write; always ro for snapshots.</li><li class="attribute">snapshot:  (<strong><a href="#bool">bool</a></strong>): Whether it is a snapshot or a volume.</li><li class="attribute">volume:  (<strong><a href="#VolumeName">VolumeName</a></strong>)</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumesReassign">Reassign volumes and/or snapshots (<strong>VolumesReassign</strong>)</h3>
<p>Perform bulk attach/detach and attachment rights modification.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumesReassign HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

[Either({
  "detach": Either(<var>&quot;all&quot;</var>, [<var>ClientID</var>, ...]) <span class="opt">/* Optional */</span>,
  "force": <var>bool, default=false</var>,
  "ro": [<var>ClientID</var>, ...] <span class="opt">/* Optional */</span>,
  "rw": [<var>ClientID</var>, ...] <span class="opt">/* Optional */</span>,
  "volume": <var>VolumeName</var>
}, {
  "detach": Either(<var>&quot;all&quot;</var>, [<var>ClientID</var>, ...]) <span class="opt">/* Optional */</span>,
  "force": <var>bool, default=false</var>,
  "ro": [<var>ClientID</var>, ...] <span class="opt">/* Optional */</span>,
  "snapshot": <var>SnapshotName</var>
}), ...]</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumesReassign</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <ul>Element type: The value must be of one of the following types: VolumeReassignDesc, SnapshotReassignDesc.
<ul><em>Subtypes:</em>
<li><strong>VolumeReassignDesc</strong><ul>
<li class="attribute">detach:  (<span class="opt">Optional</span> <strong><a href="#Either(&quot;all&quot;, [ClientID])">Either(&quot;all&quot;, [ClientID])</a></strong>): The clients from which to detach the given volume.</li><li class="attribute">force:  (<strong><a href="#bool, default=false">bool, default=false</a></strong>): Whether to force detaching of open volumes.</li><li class="attribute">ro:  (<span class="opt">Optional</span> <strong><a href="#[ClientID]">[ClientID]</a></strong>): The clients on which to attach the volume as read only.</li><li class="attribute">rw:  (<span class="opt">Optional</span> <strong><a href="#[ClientID]">[ClientID]</a></strong>): The clients on which to attach the volume as read/write.</li><li class="attribute">volume:  (<strong><a href="#VolumeName">VolumeName</a></strong>): The name of the volume to be reassigned.</li></ul>
</li>
<li><strong>SnapshotReassignDesc</strong><ul>
<li class="attribute">detach:  (<span class="opt">Optional</span> <strong><a href="#Either(&quot;all&quot;, [ClientID])">Either(&quot;all&quot;, [ClientID])</a></strong>): The clients from which to detach the given snapshot.</li><li class="attribute">force:  (<strong><a href="#bool, default=false">bool, default=false</a></strong>): Whether to force detaching of open snapshots.</li><li class="attribute">ro:  (<span class="opt">Optional</span> <strong><a href="#[ClientID]">[ClientID]</a></strong>): The clients on which to attach the snapshot.</li><li class="attribute">snapshot:  (<strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the snapshot which should be reassigned.</li></ul>
</li>
</ul>

</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Placement-Groups">Placement Groups</h2>
<p>Placement groups provide a way to specify the disks on which a volume&apos;s data
should be stored.</p>
<h3 id="PlacementGroupsList">List all placement groups (<strong>PlacementGroupsList</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/PlacementGroupsList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/PlacementGroupsList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "<var>PlacementGroupName</var>": {
      "disks": [<var>DiskID</var>, ...],
      "id": <var>int</var> <span class="opt">/* Internal */</span>,
      "name": <var>PlacementGroupName</var>,
      "servers": [<var>ServerID</var>, ...]
    }, ...
  }
}
</code></pre></li>
<li>Response Data:
A dict from PlacementGroupName to PlacementGroup
<ul>
<li>Key type: <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong></li>
<li>Value type: <strong>PlacementGroup</strong><ul>
<li class="attribute">disks:  IDs of the participating disks.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">name:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>)</li><li class="attribute">servers:  IDs of the participating servers.<ul>Element type: <strong><a href="#ServerID">ServerID</a></strong>
</li></ul>
</li></ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="PlacementGroupDescribe">Describe a single placement group (<strong>PlacementGroupDescribe</strong>)</h3>
<p>Same as PlacementGroupsList but only return information about a given group.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/PlacementGroupDescribe/{placementGroupName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/PlacementGroupDescribe/{placementGroupName}</em></li>
<li>Arguments: 
<ul>
<li>placementGroupName - <strong>PlacementGroupName</strong>: <em>a string(128), matching ^[A-Za-z0-9_\-]+$, except {list}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "disks": [<var>DiskID</var>, ...],
    "id": <var>int</var> <span class="opt">/* Internal */</span>,
    "name": <var>PlacementGroupName</var>,
    "servers": [<var>ServerID</var>, ...]
  }
}
</code></pre></li>
<li>Response Data:
<strong>PlacementGroup</strong><ul>
<li class="attribute">disks:  IDs of the participating disks.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">id:  (<span class="opt">Internal</span> <strong><a href="#int">int</a></strong>)</li><li class="attribute">name:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>)</li><li class="attribute">servers:  IDs of the participating servers.<ul>Element type: <strong><a href="#ServerID">ServerID</a></strong>
</li></ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="PlacementGroupUpdate">Create and/or update a placement group (<strong>PlacementGroupUpdate</strong>)</h3>
<p>If a group by the specified name does not exist, it will be created.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/PlacementGroupUpdate/{placementGroupName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "addDisks": [<var>DiskID</var>, ...],
  "addServers": [<var>ServerID</var>, ...],
  "rename": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "rmDisks": [<var>DiskID</var>, ...],
  "rmServers": [<var>ServerID</var>, ...]
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/PlacementGroupUpdate/{placementGroupName}</em></li>
<li>Arguments: 
<ul>
<li>placementGroupName - <strong>PlacementGroupName</strong>: <em>a string(128), matching ^[A-Za-z0-9_\-]+$, except {list}</em></li>
</ul>
</li>
<li>JSON: <strong>PlacementGroupUpdateDesc</strong><ul>
<li class="attribute">addDisks:  IDs of the disks to add to this group.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">addServers:  IDs of the servers to add to this group. (This will add all the accessible disks of these servers)<ul>Element type: <strong><a href="#ServerID">ServerID</a></strong>
</li></ul>
</li><li class="attribute">rename:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The new name of the placement group.</li><li class="attribute">rmDisks:  IDs of the disks to be removed from this group.<ul>Element type: <strong><a href="#DiskID">DiskID</a></strong>
</li></ul>
</li><li class="attribute">rmServers:  IDs of the servers to be removed from this group.<ul>Element type: <strong><a href="#ServerID">ServerID</a></strong>
</li></ul>
</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="PlacementGroupDelete">Delete a placement group (<strong>PlacementGroupDelete</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/PlacementGroupDelete/{placementGroupName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/PlacementGroupDelete/{placementGroupName}</em></li>
<li>Arguments: 
<ul>
<li>placementGroupName - <strong>PlacementGroupName</strong>: <em>a string(128), matching ^[A-Za-z0-9_\-]+$, except {list}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Volume-Templates">Volume Templates</h2>
<p>Templates are a set of rules used for creating many similar volumes.</p>
<h3 id="VolumeTemplatesList">List all volume templates (<strong>VolumeTemplatesList</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeTemplatesList HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeTemplatesList</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": [{
    "bw": <var>Bandwidth</var>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeTemplateName</var>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "placeAll": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": Either(<var>&quot;-&quot;</var>, <var>Replication</var>),
    "size": Either(<var>&quot;-&quot;</var>, <var>Size</var>)
  }, ...]
}
</code></pre></li>
<li>Response Data:
<ul>Element type: <strong>VolumeTemplateDesc</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>)</li><li class="attribute">parentName:  The name of the snapshot on which volumes will be based.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  A default number of copies to be kept by StorPool.The value must be of one of the following types: &quot;-&quot;, Replication.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;-&quot;">&quot;-&quot;</a></strong></li>
<li><strong><a href="#Replication">Replication</a></strong></li>
</ul>
</li><li class="attribute">size:  A default size for the volumes (in bytes).The value must be of one of the following types: &quot;-&quot;, Size.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;-&quot;">&quot;-&quot;</a></strong></li>
<li><strong><a href="#Size">Size</a></strong></li>
</ul>
</li></ul>

</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeTemplateDescribe">Describe a single volume template (<strong>VolumeTemplateDescribe</strong>)</h3>
<p>Same as VolumeTemplatesList but only return information about a given template.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeTemplateDescribe/{templateName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeTemplateDescribe/{templateName}</em></li>
<li>Arguments: 
<ul>
<li>templateName - <strong>VolumeTemplateName</strong>: <em>a string(200), matching ^[A-Za-z0-9_\-]+$, except {list}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "bw": <var>Bandwidth</var>,
    "iops": <var>IOPS</var>,
    "name": <var>VolumeTemplateName</var>,
    "parentName": Either(<var>&quot;&quot;</var>, <var>SnapshotName</var>),
    "placeAll": <var>PlacementGroupName</var>,
    "placeTail": <var>PlacementGroupName</var>,
    "replication": Either(<var>&quot;-&quot;</var>, <var>Replication</var>),
    "size": Either(<var>&quot;-&quot;</var>, <var>Size</var>)
  }
}
</code></pre></li>
<li>Response Data:
<strong>VolumeTemplateDesc</strong><ul>
<li class="attribute">bw:  (<strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">iops:  (<strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>)</li><li class="attribute">parentName:  The name of the snapshot on which volumes will be based.The value must be of one of the following types: &quot;&quot;, SnapshotName.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;&quot;">&quot;&quot;</a></strong></li>
<li><strong><a href="#SnapshotName">SnapshotName</a></strong></li>
</ul>
</li><li class="attribute">placeAll:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  A default number of copies to be kept by StorPool.The value must be of one of the following types: &quot;-&quot;, Replication.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;-&quot;">&quot;-&quot;</a></strong></li>
<li><strong><a href="#Replication">Replication</a></strong></li>
</ul>
</li><li class="attribute">size:  A default size for the volumes (in bytes).The value must be of one of the following types: &quot;-&quot;, Size.
<ul><em>Subtypes:</em>
<li><strong><a href="#&quot;-&quot;">&quot;-&quot;</a></strong></li>
<li><strong><a href="#Size">Size</a></strong></li>
</ul>
</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeTemplateCreate">Create a volume template (<strong>VolumeTemplateCreate</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeTemplateCreate HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "bw": <var>Bandwidth</var> <span class="opt">/* Optional */</span>,
  "iops": <var>IOPS</var> <span class="opt">/* Optional */</span>,
  "name": <var>VolumeTemplateName</var>,
  "parent": <var>SnapshotName</var> <span class="opt">/* Optional */</span>,
  "placeAll": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeTail": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "replication": <var>Replication</var> <span class="opt">/* Optional */</span>,
  "size": <var>Size</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeTemplateCreate</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <strong>VolumeTemplateCreateDesc</strong><ul>
<li class="attribute">bw:  (<span class="opt">Optional</span> <strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">iops:  (<span class="opt">Optional</span> <strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">name:  (<strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>)</li><li class="attribute">parent:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the snapshot on which to base volumes created by this template.</li><li class="attribute">placeAll:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">replication:  (<span class="opt">Optional</span> <strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<span class="opt">Optional</span> <strong><a href="#Size">Size</a></strong>): A default size for the volumes (in bytes).</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeTemplateUpdate">Update a volume template (<strong>VolumeTemplateUpdate</strong>)</h3>
<p>Alter the configuration of an existing volume template.</p>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeTemplateUpdate/{templateName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

{
  "bw": <var>Bandwidth</var> <span class="opt">/* Optional */</span>,
  "iops": <var>IOPS</var> <span class="opt">/* Optional */</span>,
  "parent": <var>SnapshotName</var> <span class="opt">/* Optional */</span>,
  "placeAll": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "placeTail": <var>PlacementGroupName</var> <span class="opt">/* Optional */</span>,
  "propagate": <var>bool</var> <span class="opt">/* Optional */</span>,
  "rename": <var>VolumeTemplateName</var> <span class="opt">/* Optional */</span>,
  "replication": <var>Replication</var> <span class="opt">/* Optional */</span>,
  "size": <var>Size</var> <span class="opt">/* Optional */</span>
}</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeTemplateUpdate/{templateName}</em></li>
<li>Arguments: 
<ul>
<li>templateName - <strong>VolumeTemplateName</strong>: <em>a string(200), matching ^[A-Za-z0-9_\-]+$, except {list}</em></li>
</ul>
</li>
<li>JSON: <strong>VolumeTemplateUpdateDesc</strong><ul>
<li class="attribute">bw:  (<span class="opt">Optional</span> <strong><a href="#Bandwidth">Bandwidth</a></strong>): Bandwidth limit in KB.</li><li class="attribute">iops:  (<span class="opt">Optional</span> <strong><a href="#IOPS">IOPS</a></strong>): iops limit.</li><li class="attribute">parent:  (<span class="opt">Optional</span> <strong><a href="#SnapshotName">SnapshotName</a></strong>): The name of the snapshot on which to base volumes created by this template.</li><li class="attribute">placeAll:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for all but the last replica.</li><li class="attribute">placeTail:  (<span class="opt">Optional</span> <strong><a href="#PlacementGroupName">PlacementGroupName</a></strong>): The name of a placement group which describes the disks to be used for the last replica, the one used for reading.</li><li class="attribute">propagate:  (<span class="opt">Optional</span> <strong><a href="#bool">bool</a></strong>): Whether to propagate this change to all the volumes and snapshots using this template.</li><li class="attribute">rename:  (<span class="opt">Optional</span> <strong><a href="#VolumeTemplateName">VolumeTemplateName</a></strong>): The new name of the template.</li><li class="attribute">replication:  (<span class="opt">Optional</span> <strong><a href="#Replication">Replication</a></strong>): The number of copies/replicas kept.</li><li class="attribute">size:  (<span class="opt">Optional</span> <strong><a href="#Size">Size</a></strong>): A default size for the volumes (in bytes).</li></ul>
</li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeTemplateDelete">Delete a volume template (<strong>VolumeTemplateDelete</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeTemplateDelete/{templateName} HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeTemplateDelete/{templateName}</em></li>
<li>Arguments: 
<ul>
<li>templateName - <strong>VolumeTemplateName</strong>: <em>a string(200), matching ^[A-Za-z0-9_\-]+$, except {list}</em></li>
</ul>
</li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Volume-Relocator">Volume Relocator</h2>
<p>This is a service that moves data when needed, e.g. when
removing or adding disks.</p>
<h3 id="VolumeRelocatorOn">Turn the relocator on (<strong>VolumeRelocatorOn</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeRelocatorOn HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeRelocatorOn</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeRelocatorOff">Turn the relocator off (<strong>VolumeRelocatorOff</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeRelocatorOff HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeRelocatorOff</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeRelocatorStatus">Get the relocator&apos;s status (<strong>VolumeRelocatorStatus</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeRelocatorStatus HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeRelocatorStatus</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "status": <var>RelocatorStatus</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>VolumeRelocatorStatus</strong><ul>
<li class="attribute">status:  (<strong><a href="#RelocatorStatus">RelocatorStatus</a></strong>)</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="Balancer">Balancer</h2>
<p>This is a service that decides when it is a good time to move data.</p>
<h3 id="VolumeBalancerOn">Turn the balancer on (<strong>VolumeBalancerOn</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeBalancerOn HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeBalancerOn</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeBalancerOff">Turn the balancer off (<strong>VolumeBalancerOff</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>POST /ctrl/1.0/VolumeBalancerOff HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>POST</em></li>
<li>Path: <em>/ctrl/1.0/VolumeBalancerOff</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "generation": <var>long</var>,
    "ok": <var>true</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>ApiOk</strong><ul>
<li class="attribute">generation:  (<strong><a href="#long">long</a></strong>): The cluster generation based on the number of configuration changes since the cluster was created.</li><li class="attribute">ok:  (<strong><a href="#true">true</a></strong>): Always returns true. If something goes wrong, an ApiError is returned instead.</li></ul>
</li>
</ul>
</li>
</ol>
<h3 id="VolumeBalancerStatus">Get the balancer&apos;s status (<strong>VolumeBalancerStatus</strong>)</h3>
<ol><li>Request:
<ul><li>Example HTTP Request:
<pre><code>GET /ctrl/1.0/VolumeBalancerStatus HTTP/1.0
Host: <var>SP_API_HOST</var>:<var>SP_API_PORT</var>
Authorization: Storpool v1:<var>SP_AUTH_TOKEN</var>
Content-Length: <var>LENGTH</var>

</code></pre></li><li>Method: <em>GET</em></li>
<li>Path: <em>/ctrl/1.0/VolumeBalancerStatus</em></li>
<li>Arguments: <em>No arguments</em></li>
<li>JSON: <em>Either no JSON or {}</em></li>
</ul>
</li>
<li>Response:
<ul>
<li>Example HTTP Response:
<pre><code>HTTP/1.0 200 OK
Connection: close
Content-Type: application/json
Cache-control: private
Content-Length: <var>LENGTH</var>

{
  "generation": <var>generation</var>,
  "data": {
    "status": <var>BalancerStatus</var>
  }
}
</code></pre></li>
<li>Response Data:
<strong>VolumeBalancerStatus</strong><ul>
<li class="attribute">status:  (<strong><a href="#BalancerStatus">BalancerStatus</a></strong>)</li></ul>
</li>
</ul>
</li>
</ol>
<h2 id="types">Data Types</h2>
<table>
<tr id="&quot;&quot;"><td><strong>&quot;&quot;</strong>:</td><td>The constant value &quot;&quot;.</td></tr>
<tr id="&quot;-&quot;"><td><strong>&quot;-&quot;</strong>:</td><td>The constant value &quot;-&quot;.</td></tr>
<tr id="&quot;all&quot;"><td><strong>&quot;all&quot;</strong>:</td><td>The constant value &quot;all&quot;.</td></tr>
<tr id="AoeExportStatus"><td><strong>AoeExportStatus</strong>:</td><td>One of {&quot;OK&quot;, &quot;down&quot;}</td></tr>
<tr id="AoeTargetID"><td><strong>AoeTargetID</strong>:</td><td>integer, 1 &lt;= value &lt;= 4095</td></tr>
<tr id="AttachmentPos"><td><strong>AttachmentPos</strong>:</td><td>integer, 0 &lt;= value &lt;= 1023</td></tr>
<tr id="AttachmentRights"><td><strong>AttachmentRights</strong>:</td><td>One of {&quot;rw&quot;, &quot;ro&quot;}</td></tr>
<tr id="BalancerStatus"><td><strong>BalancerStatus</strong>:</td><td>One of {&quot;on&quot;, &quot;off&quot;, &quot;blocked&quot;}</td></tr>
<tr id="Bandwidth"><td><strong>Bandwidth</strong>:</td><td>a positive integer or &apos;-&apos; for unlimited</td></tr>
<tr id="ClientID"><td><strong>ClientID</strong>:</td><td>integer, 1 &lt;= value &lt;= 24575</td></tr>
<tr id="ClientStatus"><td><strong>ClientStatus</strong>:</td><td>One of {&quot;running&quot;, &quot;down&quot;}</td></tr>
<tr id="ClusterStatus"><td><strong>ClusterStatus</strong>:</td><td>One of {&quot;running&quot;, &quot;waiting&quot;, &quot;down&quot;}</td></tr>
<tr id="DiskDescritpion"><td><strong>DiskDescritpion</strong>:</td><td>string, regex ^[A-Za-z0-9_\- ]{,30}$</td></tr>
<tr id="DiskID"><td><strong>DiskID</strong>:</td><td>integer, 0 &lt;= value &lt;= 4095</td></tr>
<tr id="DiskSoftEjectStatus"><td><strong>DiskSoftEjectStatus</strong>:</td><td>One of {&quot;on&quot;, &quot;off&quot;, &quot;paused&quot;}</td></tr>
<tr id="IOPS"><td><strong>IOPS</strong>:</td><td>a positive integer or &apos;-&apos; for unlimited</td></tr>
<tr id="MAC Address"><td><strong>MAC Address</strong>:</td><td>string, regex ^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$</td></tr>
<tr id="MgmtID"><td><strong>MgmtID</strong>:</td><td>integer, 1 &lt;= value &lt;= 4095</td></tr>
<tr id="NetID"><td><strong>NetID</strong>:</td><td>integer, 0 &lt;= value &lt;= 3</td></tr>
<tr id="NodeID"><td><strong>NodeID</strong>:</td><td>integer, 0 &lt;= value &lt;= 63</td></tr>
<tr id="ObjectState"><td><strong>ObjectState</strong>:</td><td>ObjectState, enumeration from 0 to 9</td></tr>
<tr id="PeerID"><td><strong>PeerID</strong>:</td><td>integer, 0 &lt;= value &lt;= 65535</td></tr>
<tr id="PeerStatus"><td><strong>PeerStatus</strong>:</td><td>One of {&quot;up&quot;, &quot;down&quot;}</td></tr>
<tr id="PlacementGroupName"><td><strong>PlacementGroupName</strong>:</td><td>a string(128), matching ^[A-Za-z0-9_\-]+$, except {list}</td></tr>
<tr id="RelocatorStatus"><td><strong>RelocatorStatus</strong>:</td><td>One of {&quot;on&quot;, &quot;off&quot;, &quot;blocked&quot;}</td></tr>
<tr id="Replication"><td><strong>Replication</strong>:</td><td>integer, 1 &lt;= value &lt;= 3</td></tr>
<tr id="RequestOp"><td><strong>RequestOp</strong>:</td><td>One of {&quot;read&quot;, &quot;write&quot;, &quot;merge&quot;, &quot;system&quot;, &quot;entries flush&quot;, &quot;#bad_state&quot;, &quot;#bad_drOp&quot;}</td></tr>
<tr id="ServerID"><td><strong>ServerID</strong>:</td><td>integer, 1 &lt;= value &lt;= 32767</td></tr>
<tr id="ServerStatus"><td><strong>ServerStatus</strong>:</td><td>One of {&quot;running&quot;, &quot;waiting&quot;, &quot;booting&quot;, &quot;down&quot;}</td></tr>
<tr id="Size"><td><strong>Size</strong>:</td><td>a positive integer divisible by 512</td></tr>
<tr id="SizeAdd"><td><strong>SizeAdd</strong>:</td><td>a positive integer divisible by 512</td></tr>
<tr id="SnapshotName"><td><strong>SnapshotName</strong>:</td><td>a string(200), matching ^\*?[A-Za-z0-9_\-.:@]+$, except {list, status}</td></tr>
<tr id="VolumeCurentStatus"><td><strong>VolumeCurentStatus</strong>:</td><td>One of {&quot;up&quot;, &quot;up soon&quot;, &quot;data lost&quot;, &quot;down&quot;}</td></tr>
<tr id="VolumeName"><td><strong>VolumeName</strong>:</td><td>a string(200), matching ^\#?[A-Za-z0-9_\-.:]+$, except {list, status}</td></tr>
<tr id="VolumeTemplateName"><td><strong>VolumeTemplateName</strong>:</td><td>a string(200), matching ^[A-Za-z0-9_\-]+$, except {list}</td></tr>
<tr id="bool"><td><strong>bool</strong>:</td><td>true or false.</td></tr>
<tr id="bool, default=false"><td><strong>bool, default=false</strong>:</td><td>A value of type bool. Default value = False.</td></tr>
<tr id="client status"><td><strong>client status</strong>:</td><td>One of {&quot;ok&quot;, &quot;updating&quot;, &quot;down&quot;}</td></tr>
<tr id="int"><td><strong>int</strong>:</td><td>An integer value.</td></tr>
<tr id="long"><td><strong>long</strong>:</td><td>A long integer value.</td></tr>
<tr id="null"><td><strong>null</strong>:</td><td>The constant value null.</td></tr>
<tr id="string"><td><strong>string</strong>:</td><td>A string value.</td></tr>
<tr id="true"><td><strong>true</strong>:</td><td>The constant value true.</td></tr>
</table>

	
	</body>
</html>

