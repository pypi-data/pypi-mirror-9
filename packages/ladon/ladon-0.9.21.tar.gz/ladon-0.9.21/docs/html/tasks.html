<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Ladon Tasks &mdash; Ladon 0.9.19 documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.2.0/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.2.0/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.9.19',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.2.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Ladon 0.9.19 documentation" href="index.html" />
    <link rel="next" title="Extending Ladon with new interface protocols" href="extending.html" />
    <link rel="prev" title="LadonType for complex service types" href="ladontype.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html"><img src="_static/Ladon_24.jpg">
          Ladon</a>
        <span class="navbar-text navbar-version pull-left"><b>0.9</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ladonize.html">Ladonize</a></li>
<li class="toctree-l1"><a class="reference internal" href="ladontype.html">LadonType for complex service types</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Ladon Tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="extending.html">Extending Ladon with new interface protocols</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Ladon Tasks</a><ul>
<li><a class="reference internal" href="#description">Description</a></li>
<li><a class="reference internal" href="#example">Example</a></li>
<li><a class="reference internal" href="#what-is-the-effect-for-the-end-user">What is the effect for the end-user</a></li>
<li><a class="reference internal" href="#updating-a-task-s-progress">Updating a task&#8217;s progress</a></li>
<li><a class="reference internal" href="#cave-eats-version-0-9-8">Cave-eats (version 0.9.8)</a></li>
<li><a class="reference internal" href="#solution-version-1-0-0">Solution (version 1.0.0)</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="ladontype.html" title="Previous Chapter: LadonType for complex service types"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; LadonType for co...</span>
    </a>
  </li>
  <li>
    <a href="extending.html" title="Next Chapter: Extending Ladon with new interface protocols"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Extending Ladon ... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="_sources/tasks.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="ladon-tasks">
<h1>Ladon Tasks<a class="headerlink" href="#ladon-tasks" title="Permalink to this headline">¶</a></h1>
<div class="section" id="description">
<h2>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p>Ladon tasks are ladonzed methods that are executed in the background - also called task-type methods. The Ladon framework takes
care of almost everything so you as a service developer can concentrate on the code. There is essentially no difference in making
a &#8220;normal&#8221; ladonized method and a task-type ladonized method. The only thing you as a developer have to think of is protecting
access to non-local objects. So if you are keeping state between several method requests in a global object you will need to
use some sort of locking mechanism.</p>
</div>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s say for instance you are implementing a web service interface for a virtualization center, then one of your methods might
look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">InstanceService</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

        <span class="nd">@ladonize</span><span class="p">(</span><span class="n">PORTABLE_STRING</span><span class="p">,</span> <span class="n">PORTABLE_STRING</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="n">InstanceInformation</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">cloneInstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">instance_id</span><span class="p">,</span><span class="n">new_instance_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
                <span class="n">response</span> <span class="o">=</span> <span class="n">InstanceInformation</span><span class="p">()</span>
                <span class="o">...</span>
                <span class="o">...</span>
                <span class="k">return</span> <span class="n">response</span>
</pre></div>
</div>
<p>In this example we imagine that the method <strong>cloneInstance</strong> will create a new instance with the name <strong>new_instance_name</strong> as an
exact copy of the existing instance identified by <strong>instance_id</strong>. The result of the clone operation is returned in the <em>LadonType</em>
<strong>InstanceInformation</strong>. It is not hard to imagine that such an operation will take time having tasks like:</p>
<blockquote>
<div><ul class="simple">
<li>Configuring and creating a new virtual destination instance</li>
<li>Copying all disk images from the source instance</li>
<li>Maybe starting it up as an option</li>
</ul>
</div></blockquote>
<p>So let&#8217;s say that this operation takes minutes. If you expose the method like above the requesting connection will block
for just as long time waiting for the response to come back. Also the back-end has no way of reporting back to the end-user
how far into the operation it has progressed.</p>
<p>To effectively solve all of the above problems expose the method as a Ladon task instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">InstanceService</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

        <span class="nd">@ladonize</span><span class="p">(</span><span class="n">PORTABLE_STRING</span><span class="p">,</span> <span class="n">PORTABLE_STRING</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="n">InstanceInformation</span><span class="p">,</span> <span class="n">tasktype</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">cloneInstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">instance_id</span><span class="p">,</span><span class="n">new_instance_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
                <span class="n">response</span> <span class="o">=</span> <span class="n">InstanceInformation</span><span class="p">()</span>
                <span class="o">...</span>
                <span class="n">kw</span><span class="p">[</span><span class="s">&#39;update_progress&#39;</span><span class="p">](</span><span class="mf">0.3</span><span class="p">)</span>
                <span class="o">...</span>
                <span class="k">return</span> <span class="n">response</span>
</pre></div>
</div>
<p>The only extra code you will need to add in the task-type implementation is progress updating.</p>
</div>
<div class="section" id="what-is-the-effect-for-the-end-user">
<h2>What is the effect for the end-user<a class="headerlink" href="#what-is-the-effect-for-the-end-user" title="Permalink to this headline">¶</a></h2>
<p>So how does task-types really affect your service? Well in pratice what we have done is created a server-side asynchronious method
which starts the method code, but instead of returning the a <strong>InstanceInformation</strong> <em>LadonType</em> response as was defined it returns
a <strong>task_id</strong> immediately in a LadonType called <strong>TaskInfoResponse</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TaskInfoResponse</span><span class="p">(</span><span class="n">LadonType</span><span class="p">):</span>
        <span class="n">task_id</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                <span class="s">&#39;doc&#39;</span><span class="p">:</span> <span class="s">u&#39;unique integer identifying the task to that has been created&#39;</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>So this will start the task. To continuously monitor the progress from the user-end just call the task&#8217;s corresponding
&lt;method-name&gt;_progress() method which returns a LadonType called <strong>TaskProgressResponse</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TaskProgressResponse</span><span class="p">(</span><span class="n">LadonType</span><span class="p">):</span>
        <span class="n">task_id</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                <span class="s">&#39;doc&#39;</span><span class="p">:</span> <span class="s">u&#39;unique integer identifying the task to that has been probed&#39;</span>
        <span class="p">}</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                <span class="s">&#39;doc&#39;</span><span class="p">:</span> <span class="s">u&#39;Floating point value between 0 and 1 denoting the progress in percent&#39;</span>
        <span class="p">}</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                <span class="s">&#39;doc&#39;</span><span class="p">:</span> <span class="s">u&#39;Floating point value that informs how long time in seconds the task as run&#39;</span>
        <span class="p">}</span>
        <span class="n">starttime</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                <span class="s">&#39;doc&#39;</span><span class="p">:</span> <span class="s">u&#39;The start time in seconds since the epoch as a floating point number&#39;</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>When the task has finished running the result can be retreived using the task&#8217;s &lt;method-name&gt;_result() method. It returns the type
you originally defined your task-method to return using the ladonize decorator&#8217;s rtype keyword.</p>
<p>To summerize let&#8217;s see what the effect of the above example would be for the end-user.</p>
<p>As already explained the method you originally defined and exposed has been split into 3 exposed methods. So the method from the
example <strong>cloneInstance</strong> will expand to the following methods at the user-end:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>cloneInstance(self, instance_id, new_instance_name)</dt>
<dd><ul class="first last simple">
<li>returning a <strong>TaskInfoResponse</strong></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>cloneInstance_progress(self, task_id)</dt>
<dd><ul class="first last simple">
<li>returning a <strong>TaskProgressResponse</strong></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>cloneInstance_result(self, taskid)</dt>
<dd><ul class="first last simple">
<li>returning the return type defined in the ladonize decorator: <strong>InstanceInformation</strong></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="updating-a-task-s-progress">
<h2>Updating a task&#8217;s progress<a class="headerlink" href="#updating-a-task-s-progress" title="Permalink to this headline">¶</a></h2>
<p>Progress values in Ladon are defined as float values between 0 and 1 denoting the progress in percent.</p>
<p>Once a task has been started it must update it&#8217;s own progress continuously. Needless to say the more frequently you as a service
developer update the progress the better the resolution and experience the end-user will get.</p>
<p>Ladon will initially set a new task&#8217;s progress to 0.0 and also set it to 1.0 once the task has ended. So even if you somehow can&#8217;t
update the progress the task will work as it should.</p>
<p>The function for updating a task&#8217;s progress is passed to the method via the keyword argument <strong>update_progress</strong>. It takes a float
between 0 and 1 as argument. Values less than 0 and larger than 1 will be converted to 0 and 1 respectively.</p>
<p>Here is a full Ladon task example using progress update:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ladon.compat</span> <span class="kn">import</span> <span class="n">PORTABLE_STRING</span>
<span class="kn">from</span> <span class="nn">ladon.ladonizer</span> <span class="kn">import</span> <span class="n">ladonize</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">TaskService</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

        <span class="nd">@ladonize</span><span class="p">(</span><span class="n">PORTABLE_STRING</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">tasktype</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">taskExample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">session_id</span><span class="p">,</span><span class="n">counter</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>
                <span class="n">set_progress</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s">&#39;update_progress&#39;</span><span class="p">]</span>
                <span class="n">repeat</span> <span class="o">=</span> <span class="mf">60.0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">repeat</span><span class="p">)):</span>
                        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>
                        <span class="n">set_progress</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="n">repeat</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">counter</span>
</pre></div>
</div>
</div>
<div class="section" id="cave-eats-version-0-9-8">
<h2>Cave-eats (version 0.9.8)<a class="headerlink" href="#cave-eats-version-0-9-8" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>Uses the threading module meaning that <strong>GIL</strong> is in play</li>
<li>Task state is kept in global python variables and therefore do not work cross-host nor cross-process</li>
</ul>
</div></blockquote>
<p>In many use-cases these cave-eats are not a problem. Ie. if your task spawns a new synchronious process
like a system-call you will not be having problems with <em>GIL</em> and the current implementation will work as
long as your application stays within the same process.</p>
<p>The good thing about the current solution is that it works out-of-the-box without introducing thirdparty
state-keeping services. It should also be noted that if you are using ie. mod-wsgi on apache2 it is
possible to control process groups for specific Ladon services, so you can configure your apache server
to use only one process for your services containing task type Ladon methods, and multiple procesesses for
your other services that do not need to keep state like Ladon tasks.</p>
</div>
<div class="section" id="solution-version-1-0-0">
<h2>Solution (version 1.0.0)<a class="headerlink" href="#solution-version-1-0-0" title="Permalink to this headline">¶</a></h2>
<p>The solution for the cave-eats mentioned will be the option to configure socket-based state caching like
memcached or redis. If using the thirdparty state caching option Ladon will shift over to using the
multiprocessing module for task execution. This solution should solve both cave-eats and will be when
Ladon turns into 1.0.0.</p>
<p>The current implementation will probably stay in Ladon because it is very easy to use and requires no
extra configuration other than the keyword in your ladonize decorator</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright Jakob Simon-Gaarde.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>