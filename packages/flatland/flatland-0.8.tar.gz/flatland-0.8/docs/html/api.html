<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>&lt;no title&gt; &mdash; flatland 0.0.hg-tip documentation</title>
    
    <link rel="stylesheet" href="_static/flatland.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.hg-tip',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="flatland 0.0.hg-tip documentation" href="index.html" />
    <link rel="next" title="The Flatland Project" href="project.html" />
    <link rel="prev" title="Widgets using Templates and Schema Properties" href="patterns/widgets.html" /> 
  </head>
  <body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <dl class="class">
<dt id="flatland.schema.scalars.Scalar">
<em class="property">class </em><tt class="descname">Scalar</tt><big>(</big><em>value=Unspecified</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#flatland.schema.scalars.Scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="schema/schema.html#flatland.schema.base.Element" title="flatland.schema.base.Element"><tt class="xref py py-class docutils literal"><span class="pre">flatland.schema.base.Element</span></tt></a></p>
<p>The base implementation of simple values such as a string or number.</p>
<p>Scalar subclasses are responsible for translating the most common data
types in and out of Python-native form: strings, numbers, dates, times,
Boolean values, etc.  Any data which can be represented by a single
<tt class="docutils literal"><span class="pre">(name,</span> <span class="pre">value)</span></tt> pair is a likely Scalar.</p>
<p>Scalar subclasses have two responsibilities: provide a method to adapt a
value to native Python form, and provide a method to serialize the native
form to a string.</p>
<p>This class is abstract.</p>
<dl class="method">
<dt id="flatland.schema.scalars.Scalar.set">
<tt class="descname">set</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#flatland.schema.scalars.Scalar.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Process <em>obj</em> and assign the native and text values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if adaptation of <em>obj</em> was successful.</td>
</tr>
</tbody>
</table>
<p>Attempts to adapt the given object and assigns this element&#8217;s
<tt class="xref py py-attr docutils literal"><span class="pre">value</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">u</span></tt>
attributes in tandem.</p>
<p>If adaptation succeeds, <tt class="docutils literal"><span class="pre">.value</span></tt> will contain the
<tt class="xref py py-meth docutils literal"><span class="pre">adapted</span></tt> native Python value and <tt class="docutils literal"><span class="pre">.u</span></tt> will contain a
text <tt class="xref py py-meth docutils literal"><span class="pre">serialized</span></tt> version of it.  A native value
of <tt class="docutils literal"><span class="pre">None</span></tt> will be represented as <tt class="docutils literal"><span class="pre">u''</span></tt> in <tt class="docutils literal"><span class="pre">.u</span></tt>.</p>
<p>If adaptation fails, <tt class="docutils literal"><span class="pre">.value</span></tt> will be <tt class="docutils literal"><span class="pre">None</span></tt> and <tt class="docutils literal"><span class="pre">.u</span></tt> will
contain <tt class="docutils literal"><span class="pre">str(obj)</span></tt> (or unicode), or <tt class="docutils literal"><span class="pre">u''</span></tt> for none.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.scalars.Scalar.adapt">
<tt class="descname">adapt</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#flatland.schema.scalars.Scalar.adapt" title="Permalink to this definition">¶</a></dt>
<dd><p>Given any object <em>obj</em>, try to coerce it into native format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the native format or raises AdaptationError on failure.</td>
</tr>
</tbody>
</table>
<p>This abstract method is called by <tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.scalars.Scalar.serialize">
<tt class="descname">serialize</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#flatland.schema.scalars.Scalar.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Given any object <em>obj</em>, coerce it into a text representation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>Must</strong> return a Unicode text object, always.</td>
</tr>
</tbody>
</table>
<p>No special effort is made to coerce values not of native or a
compatible type.</p>
<p>This semi-abstract method is called by <tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt>.  The base
implementation returns <tt class="docutils literal"><span class="pre">str(obj)</span></tt> (or unicode).</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.scalars.Scalar.set_default">
<tt class="descname">set_default</tt><big>(</big><big>)</big><a class="headerlink" href="#flatland.schema.scalars.Scalar.set_default" title="Permalink to this definition">¶</a></dt>
<dd><p>set() the element to the schema default.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flatland.schema.scalars.Number">
<em class="property">class </em><tt class="descname">Number</tt><big>(</big><em>value=Unspecified</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#flatland.schema.scalars.Number" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#flatland.schema.scalars.Scalar" title="flatland.schema.scalars.Scalar"><tt class="xref py py-class docutils literal"><span class="pre">flatland.schema.scalars.Scalar</span></tt></a></p>
<p>Base for numeric fields.</p>
<p>Subclasses provide <tt class="xref py py-attr docutils literal"><span class="pre">type_</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">format</span></tt> attributes for
<tt class="xref py py-meth docutils literal"><span class="pre">adapt()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">serialize()</span></tt>.</p>
<dl class="attribute">
<dt id="flatland.schema.scalars.Number.type_">
<tt class="descname">type_</tt><em class="property"> = None</em><a class="headerlink" href="#flatland.schema.scalars.Number.type_" title="Permalink to this definition">¶</a></dt>
<dd><p>The Python type for values, such as <tt class="docutils literal"><span class="pre">int</span></tt> or <tt class="docutils literal"><span class="pre">float</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flatland.schema.scalars.Number.signed">
<tt class="descname">signed</tt><em class="property"> = True</em><a class="headerlink" href="#flatland.schema.scalars.Number.signed" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, allow negative numbers.  Default <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flatland.schema.scalars.Number.format">
<tt class="descname">format</tt><em class="property"> = u'%s'</em><a class="headerlink" href="#flatland.schema.scalars.Number.format" title="Permalink to this definition">¶</a></dt>
<dd><p>The <tt class="docutils literal"><span class="pre">text</span></tt> serialization format.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.scalars.Number.adapt">
<tt class="descname">adapt</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#flatland.schema.scalars.Number.adapt" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic numeric coercion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an instance of <tt class="xref py py-attr docutils literal"><span class="pre">type_</span></tt> or <tt class="docutils literal"><span class="pre">None</span></tt></td>
</tr>
</tbody>
</table>
<p>Attempt to convert <em>value</em> using the class&#8217;s <tt class="xref py py-attr docutils literal"><span class="pre">type_</span></tt> callable.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.scalars.Number.serialize">
<tt class="descname">serialize</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#flatland.schema.scalars.Number.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic numeric serialization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Unicode text formatted with <tt class="xref py py-attr docutils literal"><span class="pre">format</span></tt> or the
<tt class="docutils literal"><span class="pre">str()</span></tt> (or unicode) of <em>value</em> if <em>value</em> is not of
<tt class="xref py py-attr docutils literal"><span class="pre">type_</span></tt></td>
</tr>
</tbody>
</table>
<p>Converts <em>value</em> to a string using Python&#8217;s string formatting function
and the <tt class="xref py py-attr docutils literal"><span class="pre">format</span></tt> as the template.  The <em>value</em> is provided to
the format as a single, positional format argument.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flatland.schema.scalars.Temporal">
<em class="property">class </em><tt class="descname">Temporal</tt><big>(</big><em>value=Unspecified</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#flatland.schema.scalars.Temporal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#flatland.schema.scalars.Scalar" title="flatland.schema.scalars.Scalar"><tt class="xref py py-class docutils literal"><span class="pre">flatland.schema.scalars.Scalar</span></tt></a></p>
<p>Base for datetime-based date and time fields.</p>
<dl class="attribute">
<dt id="Temporal.type_">
<tt class="descname">type_</tt><a class="headerlink" href="#Temporal.type_" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract. The native type for element values, will be called with
positional arguments per <a class="reference internal" href="#Temporal.used" title="Temporal.used"><tt class="xref py py-attr docutils literal"><span class="pre">used</span></tt></a> below.</p>
</dd></dl>

<dl class="attribute">
<dt id="Temporal.regex">
<tt class="descname">regex</tt><a class="headerlink" href="#Temporal.regex" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract. A regular expression to parse datetime values from a
string.  Must supply named groupings.</p>
</dd></dl>

<dl class="attribute">
<dt id="Temporal.used">
<tt class="descname">used</tt><a class="headerlink" href="#Temporal.used" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract. A sequence of regex match group names.  These matches
will be converted to ints and supplied to the <a class="reference internal" href="#Temporal.type_" title="Temporal.type_"><tt class="xref py py-attr docutils literal"><span class="pre">type_</span></tt></a>
constructor in the order specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="Temporal.format">
<tt class="descname">format</tt><a class="headerlink" href="#Temporal.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract.  A Python string format for serializing the native
value.  The format will be supplied a dict containing all
attributes of the native type.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.scalars.Temporal.adapt">
<tt class="descname">adapt</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#flatland.schema.scalars.Temporal.adapt" title="Permalink to this definition">¶</a></dt>
<dd><p>Coerces value to a native type.</p>
<p>If <em>value</em> is an instance of <a class="reference internal" href="#Temporal.type_" title="Temporal.type_"><tt class="xref py py-attr docutils literal"><span class="pre">type_</span></tt></a>, returns it unchanged.  If
a string, attempts to parse it and construct a <tt class="xref py py-attr docutils literal"><span class="pre">type</span></tt> as
described in the attribute documentation.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.scalars.Temporal.serialize">
<tt class="descname">serialize</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#flatland.schema.scalars.Temporal.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Serializes value to string.</p>
<p>If <em>value</em> is an instance of <tt class="xref py py-attr docutils literal"><span class="pre">type</span></tt>, formats it as described in
the attribute documentation.  Otherwise returns <tt class="docutils literal"><span class="pre">str(value)</span></tt> (or
unicode).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flatland.schema.containers.Container">
<em class="property">class </em><tt class="descname">Container</tt><big>(</big><em>value=Unspecified</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Container" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="schema/schema.html#flatland.schema.base.Element" title="flatland.schema.base.Element"><tt class="xref py py-class docutils literal"><span class="pre">flatland.schema.base.Element</span></tt></a></p>
<p>Holds other schema items.</p>
<p>Base class for elements that can contain other elements, such as
<tt class="xref py py-class docutils literal"><span class="pre">List</span></tt> and <tt class="xref py py-class docutils literal"><span class="pre">Dict</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>descent_validators</strong> &#8211; optional, a sequence of validators that
will be run before contained elements are validated.</li>
<li><strong>validators</strong> &#8211; optional, a sequence of validators that will be
run after contained elements are validated.</li>
<li><strong>**kw</strong> &#8211; other arguments common to
<a class="reference internal" href="schema/schema.html#flatland.schema.base.Element" title="flatland.schema.base.Element"><tt class="xref py py-class docutils literal"><span class="pre">Element</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="flatland.schema.containers.Container.descent_validators">
<tt class="descname">descent_validators</tt><em class="property"> = ()</em><a class="headerlink" href="#flatland.schema.containers.Container.descent_validators" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">doc descent_validators</p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="flatland.schema.containers.Container.descent_validated_by">
<em class="property">classmethod </em><tt class="descname">descent_validated_by</tt><big>(</big><em>*validators</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Container.descent_validated_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a class with descent validators set to <em>*validators</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>*validators</strong> &#8211; one or more validator functions, replacing any
descent validators present on the class.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a new class</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="flatland.schema.containers.Container.including_descent_validators">
<em class="property">classmethod </em><tt class="descname">including_descent_validators</tt><big>(</big><em>*validators</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Container.including_descent_validators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a class with additional descent <em>*validators</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*validators</strong> &#8211; one or more validator functions</li>
<li><strong>position</strong> &#8211; defaults to -1.  By default, additional validators
are placed after existing descent validators.  Use 0 for before, or
any other list index to splice in <em>validators</em> at that point.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a new class</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flatland.schema.containers.Sequence">
<em class="property">class </em><tt class="descname">Sequence</tt><big>(</big><em>value=Unspecified</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#flatland.schema.containers.Container" title="flatland.schema.containers.Container"><tt class="xref py py-class docutils literal"><span class="pre">flatland.schema.containers.Container</span></tt></a>, <a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a></p>
<p>Abstract base of sequence-like Containers.</p>
<p>Instances of <tt class="xref py py-class docutils literal"><span class="pre">Sequence</span></tt> hold other elements and operate like Python
lists.  Each sequence member will be an instance of <tt class="xref py py-attr docutils literal"><span class="pre">member_schema</span></tt>.</p>
<p>Python list methods and operators may be passed instances of
<tt class="xref py py-attr docutils literal"><span class="pre">member_schema</span></tt> or plain Python values.  Using plain values is a
shorthand for creating an <tt class="xref py py-attr docutils literal"><span class="pre">member_schema</span></tt> instance and
<a class="reference internal" href="schema/schema.html#flatland.schema.base.Element.set" title="flatland.schema.base.Element.set"><tt class="xref py py-meth docutils literal"><span class="pre">set()ting</span></tt></a> it with the value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">flatland</span> <span class="kn">import</span> <span class="n">Array</span><span class="p">,</span> <span class="n">Integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Numbers</span> <span class="o">=</span> <span class="n">Array</span><span class="o">.</span><span class="n">of</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ones</span> <span class="o">=</span> <span class="n">Numbers</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ones</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ones</span>
<span class="go">[&lt;Integer None; value=1&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">another_one</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">another_one</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ones</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">another_one</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ones</span>
<span class="go">[&lt;Integer None; value=1&gt;, &lt;Integer None; value=1&gt;]</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="flatland.schema.containers.Sequence.member_schema">
<tt class="descname">member_schema</tt><em class="property"> = None</em><a class="headerlink" href="#flatland.schema.containers.Sequence.member_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="schema/schema.html#flatland.schema.base.Element" title="flatland.schema.base.Element"><tt class="xref py py-class docutils literal"><span class="pre">Element</span></tt></a> class for sequence members.</p>
</dd></dl>

<dl class="attribute">
<dt id="flatland.schema.containers.Sequence.prune_empty">
<tt class="descname">prune_empty</tt><em class="property"> = True</em><a class="headerlink" href="#flatland.schema.containers.Sequence.prune_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, skip missing index numbers in <tt class="xref py py-meth docutils literal"><span class="pre">set_flat()</span></tt>. Default True.</p>
<p>See <a href="#id1"><span class="problematic" id="id2">`Sequences`_</span></a> for more information.</p>
</dd></dl>

<dl class="classmethod">
<dt id="flatland.schema.containers.Sequence.of">
<em class="property">classmethod </em><tt class="descname">of</tt><big>(</big><em>*schema</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Sequence.of" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare the class to hold a sequence of <em>*schema</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Params *schema:</th><td class="field-body">one or more <a class="reference internal" href="schema/schema.html#flatland.schema.base.Element" title="flatland.schema.base.Element"><tt class="xref py py-obj docutils literal"><span class="pre">Element</span></tt></a> classes</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><em>cls</em></td>
</tr>
</tbody>
</table>
<p>Configures the <tt class="xref py py-attr docutils literal"><span class="pre">member_schema</span></tt> of <em>cls</em> to hold instances of
<em>*schema</em>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">flatland</span> <span class="kn">import</span> <span class="n">Array</span><span class="p">,</span> <span class="n">String</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Names</span> <span class="o">=</span> <span class="n">Array</span><span class="o">.</span><span class="n">of</span><span class="p">(</span><span class="n">String</span><span class="o">.</span><span class="n">named</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Names</span><span class="o">.</span><span class="n">member_schema</span>
<span class="go">&lt;class &#39;flatland.schema.scalars.String&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">el</span> <span class="o">=</span> <span class="n">Names</span><span class="p">([</span><span class="s">&#39;Bob&#39;</span><span class="p">,</span> <span class="s">&#39;Biff&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">el</span>
<span class="go">[&lt;String u&#39;name&#39;; value=u&#39;Bob&#39;&gt;, &lt;String u&#39;name&#39;; value=u&#39;Biff&#39;&gt;]</span>
</pre></div>
</div>
<p>If more than one <a class="reference internal" href="schema/schema.html#flatland.schema.base.Element" title="flatland.schema.base.Element"><tt class="xref py py-obj docutils literal"><span class="pre">Element</span></tt></a> is specified in
<em>*schema</em>, an anonymous <tt class="xref py py-class docutils literal"><span class="pre">Dict</span></tt> is created to hold them.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">flatland</span> <span class="kn">import</span> <span class="n">Integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Points</span> <span class="o">=</span> <span class="n">Array</span><span class="o">.</span><span class="n">of</span><span class="p">(</span><span class="n">Integer</span><span class="o">.</span><span class="n">named</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">),</span> <span class="n">Integer</span><span class="o">.</span><span class="n">named</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Points</span><span class="o">.</span><span class="n">member_schema</span>
<span class="go">&lt;class &#39;flatland.schema.containers.Dict&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">el</span> <span class="o">=</span> <span class="n">Points</span><span class="p">([</span><span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">el</span>
<span class="go">[{u&#39;y&#39;: &lt;Integer u&#39;y&#39;; value=2&gt;, u&#39;x&#39;: &lt;Integer u&#39;x&#39;; value=1&gt;}]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Sequence.set">
<tt class="descname">set</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Sequence.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign the native and Unicode value.</p>
<p>Attempts to adapt the given <em>iterable</em> and assigns this element&#8217;s
<tt class="xref py py-attr docutils literal"><span class="pre">value</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">u</span></tt> attributes in tandem.  Returns True if the
adaptation was successful.  See
<a class="reference internal" href="schema/schema.html#flatland.schema.base.Element.set" title="flatland.schema.base.Element.set"><tt class="xref py py-meth docutils literal"><span class="pre">Element.set()</span></tt></a>.</p>
<p>Set must be supplied a Python sequence or iterable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">flatland</span> <span class="kn">import</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">List</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Numbers</span> <span class="o">=</span> <span class="n">List</span><span class="o">.</span><span class="n">of</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nums</span> <span class="o">=</span> <span class="n">Numbers</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nums</span><span class="o">.</span><span class="n">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nums</span><span class="o">.</span><span class="n">value</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Sequence.set_default">
<tt class="descname">set_default</tt><big>(</big><big>)</big><a class="headerlink" href="#flatland.schema.containers.Sequence.set_default" title="Permalink to this definition">¶</a></dt>
<dd><p>set() the element to the schema default.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Sequence.append">
<tt class="descname">append</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Sequence.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append <em>value</em> to end.</p>
<p>If <em>value</em> is not an instance of <tt class="xref py py-attr docutils literal"><span class="pre">member_schema</span></tt>, it will be
wrapped in a new element of that type before appending.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Sequence.extend">
<tt class="descname">extend</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Sequence.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Append <em>iterable</em> values to the end.</p>
<p>If values of <em>iterable</em> are not instances of <tt class="xref py py-attr docutils literal"><span class="pre">member_schema</span></tt>,
they will be wrapped in a new element of that type before extending.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Sequence.insert">
<tt class="descname">insert</tt><big>(</big><em>index</em>, <em>value</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Sequence.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert <em>value</em> at <em>index</em>.</p>
<p>If <em>value</em> is not an instance of <tt class="xref py py-attr docutils literal"><span class="pre">member_schema</span></tt>, it will be
wrapped in a new element of that type before inserting.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Sequence.remove">
<tt class="descname">remove</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Sequence.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove member with value <em>value</em>.</p>
<p>If <em>value</em> is not an instance of <tt class="xref py py-attr docutils literal"><span class="pre">member_schema</span></tt>, it will be
wrapped in a new element of that type before searching for a matching
element to remove.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Sequence.index">
<tt class="descname">index</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Sequence.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return first index of <em>value</em>.</p>
<p>If <em>value</em> is not an instance of <tt class="xref py py-attr docutils literal"><span class="pre">member_schema</span></tt>, it will be
wrapped in a new element of that type before searching for a matching
element in the sequence.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Sequence.count">
<tt class="descname">count</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Sequence.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of occurrences of <em>value</em>.</p>
<p>If <em>value</em> is not an instance of <tt class="xref py py-attr docutils literal"><span class="pre">member_schema</span></tt>, it will be
wrapped in a new element of that type before searching for matching
elements in the sequence.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flatland.schema.containers.Mapping">
<em class="property">class </em><tt class="descname">Mapping</tt><big>(</big><em>value=Unspecified</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#flatland.schema.containers.Container" title="flatland.schema.containers.Container"><tt class="xref py py-class docutils literal"><span class="pre">flatland.schema.containers.Container</span></tt></a>, <a class="reference external" href="http://docs.python.org/library/stdtypes.html#dict" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a></p>
<p>Base of mapping-like Containers.</p>
<dl class="attribute">
<dt id="flatland.schema.containers.Mapping.field_schema">
<tt class="descname">field_schema</tt><em class="property"> = ()</em><a class="headerlink" href="#flatland.schema.containers.Mapping.field_schema" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">doc field_schema</p>
</div>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Mapping.may_contain">
<tt class="descname">may_contain</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Mapping.may_contain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the element schema allows a field named <strong>key</strong>.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Mapping.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big> &rarr; None.  Remove all items from D.<a class="headerlink" href="#flatland.schema.containers.Mapping.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Mapping.popitem">
<tt class="descname">popitem</tt><big>(</big><big>)</big> &rarr; (k, v), remove and return some (key, value) pair as a<a class="headerlink" href="#flatland.schema.containers.Mapping.popitem" title="Permalink to this definition">¶</a></dt>
<dd><p>2-tuple; but raise KeyError if D is empty.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Mapping.pop">
<tt class="descname">pop</tt><big>(</big><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><big>)</big> &rarr; v, remove specified key and return the corresponding value.<a class="headerlink" href="#flatland.schema.containers.Mapping.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>If key is not found, d is returned if given, otherwise KeyError is raised</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Mapping.update">
<tt class="descname">update</tt><big>(</big><em>*dictish</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Mapping.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update with keys from dict-like <em>*dictish</em> and <em>**kwargs</em></p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Mapping.setdefault">
<tt class="descname">setdefault</tt><big>(</big><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><big>)</big> &rarr; D.get(k,d), also set D[k]=d if k not in D<a class="headerlink" href="#flatland.schema.containers.Mapping.setdefault" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Mapping.get">
<tt class="descname">get</tt><big>(</big><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><big>)</big> &rarr; D[k] if k in D, else d.  d defaults to None.<a class="headerlink" href="#flatland.schema.containers.Mapping.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Mapping.set">
<tt class="descname">set</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#flatland.schema.containers.Mapping.set" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">doc set()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.containers.Mapping.set_default">
<tt class="descname">set_default</tt><big>(</big><big>)</big><a class="headerlink" href="#flatland.schema.containers.Mapping.set_default" title="Permalink to this definition">¶</a></dt>
<dd><p>set() the element to the schema default.</p>
</dd></dl>

<dl class="attribute">
<dt id="flatland.schema.containers.Mapping.u">
<tt class="descname">u</tt><a class="headerlink" href="#flatland.schema.containers.Mapping.u" title="Permalink to this definition">¶</a></dt>
<dd><p>A string repr of the element.</p>
</dd></dl>

<dl class="attribute">
<dt id="flatland.schema.containers.Mapping.value">
<tt class="descname">value</tt><a class="headerlink" href="#flatland.schema.containers.Mapping.value" title="Permalink to this definition">¶</a></dt>
<dd><p>The element as a regular Python dictionary.</p>
</dd></dl>

<dl class="attribute">
<dt id="flatland.schema.containers.Mapping.is_empty">
<tt class="descname">is_empty</tt><a class="headerlink" href="#flatland.schema.containers.Mapping.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Mappings are never empty.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flatland.schema.compound.Compound">
<em class="property">class </em><tt class="descname">Compound</tt><big>(</big><em>value=Unspecified</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#flatland.schema.compound.Compound" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#flatland.schema.containers.Mapping" title="flatland.schema.containers.Mapping"><tt class="xref py py-class docutils literal"><span class="pre">flatland.schema.containers.Mapping</span></tt></a>, <a class="reference internal" href="#flatland.schema.scalars.Scalar" title="flatland.schema.scalars.Scalar"><tt class="xref py py-class docutils literal"><span class="pre">flatland.schema.scalars.Scalar</span></tt></a></p>
<p>A mapping container that acts like a scalar value.</p>
<p>Compound fields are dictionary-like fields that can assemble a
<tt class="xref py py-attr docutils literal"><span class="pre">u</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">value</span></tt> from their children, and can
decompose a structured value passed to a <tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt> into values
for its children.</p>
<p>A simple example is a logical calendar date field composed of 3
separate Integer component fields, year, month and day.  The
Compound can wrap the 3 parts up into a single logical field that
handles <a class="reference external" href="http://docs.python.org/library/datetime.html#datetime.date" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">datetime.date</span></tt></a> values.  Set a <tt class="docutils literal"><span class="pre">date</span></tt> on the
logical field and its component fields will be set with year,
month and day; alter the int value of the year component field and
the logical field updates the <tt class="docutils literal"><span class="pre">date</span></tt> to match.</p>
<p><tt class="xref py py-class docutils literal"><span class="pre">Compound</span></tt> is an abstract class.  Subclasses must implement
<tt class="xref py py-meth docutils literal"><span class="pre">compose()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">explode()</span></tt>.</p>
<p>Composites run validation after their children.</p>
<dl class="method">
<dt id="flatland.schema.compound.Compound.compose">
<tt class="descname">compose</tt><big>(</big><big>)</big><a class="headerlink" href="#flatland.schema.compound.Compound.compose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a text, native tuple built from children&#8217;s state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a 2-tuple of text representation, native value.
These correspond to the
<tt class="xref py py-meth docutils literal"><span class="pre">serialize_element()</span></tt> and
<tt class="xref py py-meth docutils literal"><span class="pre">adapt_element()</span></tt> methods of
<a class="reference internal" href="#flatland.schema.scalars.Scalar" title="flatland.schema.scalars.Scalar"><tt class="xref py py-obj docutils literal"><span class="pre">Scalar</span></tt></a> objects.</td>
</tr>
</tbody>
</table>
<p>For example, a compound date field may return a &#8216;-&#8216; delimited
string of year, month and day digits and a
<a class="reference external" href="http://docs.python.org/library/datetime.html#datetime.date" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">datetime.date</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.compound.Compound.explode">
<tt class="descname">explode</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#flatland.schema.compound.Compound.explode" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a compound value, assign values to children.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>value</strong> &#8211; a value to be adapted and exploded</td>
</tr>
</tbody>
</table>
<p>For example, a compound date field may read attributes from a
<a class="reference external" href="http://docs.python.org/library/datetime.html#datetime.date" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">datetime.date</span></tt></a> value and <tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt> them on child
fields.</p>
<p>The decision to perform type checking on <em>value</em> is completely
up to you and you may find you want different rules for
different compound types.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.compound.Compound.serialize">
<tt class="descname">serialize</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#flatland.schema.compound.Compound.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented for Compound types.</p>
</dd></dl>

<dl class="method">
<dt id="flatland.schema.compound.Compound.set">
<tt class="descname">set</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#flatland.schema.compound.Compound.set" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition-todo admonition" id="index-3">
<p class="first admonition-title">Todo</p>
<p class="last">doc set()</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flatland.schema.compound.Compound.is_empty">
<tt class="descname">is_empty</tt><a class="headerlink" href="#flatland.schema.compound.Compound.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>True if all subfields are empty.</p>
</dd></dl>

</dd></dl>



          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/flatland.png" alt="Logo"/>
            </a></p>
<h3>Topics</h3>
<ul>
  <li><ul>
      <li>Previous: <a href="patterns/widgets.html" title="previous chapter">Widgets using Templates and Schema Properties</a></li>
      <li>Next: <a href="project.html" title="next chapter">The Flatland Project</a></li>
  </ul></li>
</ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2008-2013, the flatland authors and contributors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>