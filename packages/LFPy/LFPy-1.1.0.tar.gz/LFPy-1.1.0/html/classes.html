<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Module LFPy &mdash; LFPy 1.1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="LFPy 1.1.0 documentation" href="index.html" />
    <link rel="prev" title="Contact" href="contact.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-29024998-1']);
  _gaq.push(['_gat._anonymizeIp']);
  _gaq.push(['_trackPageview']);
</script>

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="contact.html" title="Contact"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">LFPy 1.1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-LFPy">
<span id="module-lfpy"></span><h1>Module <a class="reference internal" href="#module-LFPy" title="LFPy"><code class="xref py py-mod docutils literal"><span class="pre">LFPy</span></code></a><a class="headerlink" href="#module-LFPy" title="Permalink to this headline">¶</a></h1>
<p>Initialization of LFPy, a module for simulating extracellular potentials.</p>
<p>Group of Computational Neuroscience (compneuro.umb.no),
Department of Mathematical Sciences and Technology,
Norwegian University of Life Sciences.</p>
<p>Copyright (C) 2012 Computational Neuroscience Group, UMB.</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Classes:</th><td class="field-body"><ul class="first simple">
<li>Cell - The pythonic neuron object itself laying on top of NEURON</li>
<li>Synapse - Convenience class for inserting synapses onto Cell objects</li>
<li>StimIntraElectrode - Convenience class for inserting electrodes onto Cell objects</li>
<li>RecExtElectrode - Class for performing simulations of extracellular potentials</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Modules:</th><td class="field-body"><ul class="first last simple">
<li>lfpcalc - functions used by RecExtElectrode class</li>
<li>tools - some convenient functions</li>
<li>inputgenerators - functions for synaptic input time generation</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="section" id="class-cell">
<h2>class <a class="reference internal" href="#LFPy.Cell" title="LFPy.Cell"><code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></a><a class="headerlink" href="#class-cell" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LFPy.Cell">
<em class="property">class </em><code class="descclassname">LFPy.</code><code class="descname">Cell</code><span class="sig-paren">(</span><em>morphology</em>, <em>v_init=-65.0</em>, <em>passive=True</em>, <em>Ra=150</em>, <em>rm=30000</em>, <em>cm=1.0</em>, <em>e_pas=-65.0</em>, <em>extracellular=True</em>, <em>timeres_NEURON=0.125</em>, <em>timeres_python=0.125</em>, <em>tstartms=0</em>, <em>tstopms=100</em>, <em>nsegs_method='lambda100'</em>, <em>lambda_f=100</em>, <em>d_lambda=0.1</em>, <em>max_nsegs_length=None</em>, <em>delete_sections=True</em>, <em>custom_code=None</em>, <em>custom_fun=None</em>, <em>custom_fun_args=None</em>, <em>pt3d=False</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>The main cell class used in LFPy.</p>
<p>Arguments:</p>
<div class="highlight-python"><div class="highlight"><pre>morphology : [str]: path/to/morphology/file

v_init: [-65.]: initial potential
passive: [True]/False: passive mechs are initialized if True
Ra: [150.]: axial resistance
rm: [30000]: membrane resistivity
cm: [1.0]: membrane capacitance
e_pas: [-65.]: passive mechanism reversal potential
extracellular: [True]/False: switch for NEURON&#39;s extracellular mechanism

timeres_NEURON: [0.1]: internal dt for NEURON simulation
timeres_python: [0.1]: overall dt for python simulation

tstartms: [0.]:  initialization time for simulation &lt;= 0 ms
tstopms: [100.]: stop time for simulation &gt; 0 ms

nsegs_method: [&#39;lambda100&#39;]/&#39;lambda_f&#39;/&#39;fixed_length&#39;: nseg rule
max_nsegs_length: [None]: max segment length for method &#39;fixed_length&#39;
lambda_f: [100]: AC frequency for method &#39;lambda_f&#39;
d_lambda: [0.1]: parameter for d_lambda rule

delete_sections: [True]: delete pre-existing section-references

custom_code: [None]: list of model-specific code files ([.py/.hoc])
custom_fun: [None]: list of model-specific functions with args
custom_fun_args: [None]: list of args passed to custom_fun functions
pt3d: True/[False]: use pt3d-info of the cell geometries switch
verbose: True/[False]: verbose output switch
</pre></div>
</div>
<p>Usage of cell class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">LFPy</span>
<span class="n">cellParameters</span> <span class="o">=</span> <span class="p">{</span>                          
    <span class="s">&#39;morphology&#39;</span> <span class="p">:</span> <span class="s">&#39;path/to/morphology&#39;</span><span class="p">,</span>
    <span class="s">&#39;rm&#39;</span> <span class="p">:</span> <span class="mi">30000</span><span class="p">,</span>
    <span class="s">&#39;cm&#39;</span> <span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="s">&#39;Ra&#39;</span> <span class="p">:</span> <span class="mi">150</span><span class="p">,</span>
    <span class="s">&#39;timeres_NEURON&#39;</span> <span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="s">&#39;timeres_python&#39;</span> <span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="s">&#39;tstartms&#39;</span> <span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span>
    <span class="s">&#39;tstopms&#39;</span> <span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">LFPy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="o">**</span><span class="n">cellParameters</span><span class="p">)</span>
<span class="n">cell</span><span class="o">.</span><span class="n">simulate</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="LFPy.Cell.cellpickler">
<code class="descname">cellpickler</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.cellpickler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.cellpickler" title="Permalink to this definition">¶</a></dt>
<dd><p>Save data in cell to filename, using cPickle. It will however destroy
any neuron.h objects upon saving, as c-objects cannot be pickled</p>
<p>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cell</span><span class="o">.</span><span class="n">cellpickler</span><span class="p">(</span><span class="s">&#39;cell.cpickle&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To load this cell again in another session:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">cPickle</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">file</span><span class="p">(</span><span class="s">&#39;cell.cpickle&#39;</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">cPickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>alternatively:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">LFPy</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">LFPy</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;cell.cpickle&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.chiral_morphology">
<code class="descname">chiral_morphology</code><span class="sig-paren">(</span><em>axis='x'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.chiral_morphology"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.chiral_morphology" title="Permalink to this definition">¶</a></dt>
<dd><p>Mirror the morphology around given axis, (default x-axis),
useful to introduce more heterogeneouties in morphology shapes</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>axis : str
    &#39;x&#39; or &#39;y&#39; or &#39;z&#39;
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.get_closest_idx">
<code class="descname">get_closest_idx</code><span class="sig-paren">(</span><em>x=0</em>, <em>y=0</em>, <em>z=0</em>, <em>section='allsec'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.get_closest_idx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.get_closest_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the index number of a segment in specified section which 
midpoint is closest to the coordinates defined by the user
kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>x: float, coordinate
y: float, coordinate
z: float, coordinate
section: str, string matching a section-name
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.get_idx">
<code class="descname">get_idx</code><span class="sig-paren">(</span><em>section='allsec'</em>, <em>z_min=-10000</em>, <em>z_max=10000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.get_idx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.get_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns neuron idx of segments from sections with names that match
the pattern defined in input section on interval [z_min, z_max].</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>section: str, any entry in cell.allsecnames or just &#39;allsec&#39;.
z_min: float, depth filter
z_max: float depth filter
</pre></div>
</div>
<p>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">idx</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_idx</span><span class="p">(</span><span class="n">section</span><span class="o">=</span><span class="s">&#39;allsec&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">idx</span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_idx</span><span class="p">(</span><span class="n">section</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;soma&#39;</span><span class="p">,</span> <span class="s">&#39;dend&#39;</span><span class="p">,</span> <span class="s">&#39;apic&#39;</span><span class="p">])</span>
<span class="k">print</span> <span class="n">idx</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.get_idx_children">
<code class="descname">get_idx_children</code><span class="sig-paren">(</span><em>parent='soma[0]'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.get_idx_children"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.get_idx_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the idx of parent&#8217;s children sections, i.e. compartments ids
of sections connected to parent-argument</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>parent: str
    name-pattern matching a sectionname
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.get_idx_name">
<code class="descname">get_idx_name</code><span class="sig-paren">(</span><em>idx=array([0])</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.get_idx_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.get_idx_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return NEURON convention name of segments with index idx.
The returned argument is a list of tuples with corresponding
segment idx, section name, and position along the section, like;
[(0, &#8216;neuron.h.soma[0]&#8217;, 0.5),]</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>idx : np.ndarray, dtype int
    segment indices, must be between 0 and cell.totnsegs        
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.get_idx_parent_children">
<code class="descname">get_idx_parent_children</code><span class="sig-paren">(</span><em>parent='soma[0]'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.get_idx_parent_children"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.get_idx_parent_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all idx of segments of parent and children sections, i.e. segment
idx of sections connected to parent-argument, and also of the parent
segments</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>parent: str
    name-pattern matching a sectionname
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.get_idx_polygons">
<code class="descname">get_idx_polygons</code><span class="sig-paren">(</span><em>projection=('x'</em>, <em>'z')</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.get_idx_polygons"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.get_idx_polygons" title="Permalink to this definition">¶</a></dt>
<dd><p>for each segment idx in celll create a polygon in the plane
determined by the projection kwarg (default (&#8216;x&#8217;, &#8216;z&#8217;)),
that can be visualized using plt.fill() or
mpl.collections.PolyCollection</p>
<p>Returned argument is a list of (np.ndarray, np.ndarray) tuples
giving the trajectory of each section</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>projection : (&#39;x&#39;, &#39;z&#39;) tuple of two strings determining projection 
</pre></div>
</div>
<p>The most efficient way of using this would be something like</p>
<div class="highlight-python"><div class="highlight"><pre>from matplotlib.collections import PolyCollection
import matplotlib.pyplot as plt

cell = LFPy.Cell(morphology=&#39;PATH/TO/MORPHOLOGY&#39;)

zips = []
for x, z in cell.get_idx_polygons(projection=(&#39;x&#39;, &#39;z&#39;):
    zips.append(zip(x, z))

polycol = PolyCollection(zips,
                         edgecolors=&#39;none&#39;,
                         facecolors=&#39;gray&#39;)

fig = plt.figure()
ax = fig.add_subplot(111)

ax.add_collection(polycol)
ax.axis(ax.axis(&#39;equal&#39;))

plt.show()
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.get_intersegment_distance">
<code class="descname">get_intersegment_distance</code><span class="sig-paren">(</span><em>idx0=0</em>, <em>idx1=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.get_intersegment_distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.get_intersegment_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Euclidean distance between midpoints of two segments 
with indices idx0 and idx1. Will return a float in unit of micrometers.</p>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.get_intersegment_vector">
<code class="descname">get_intersegment_vector</code><span class="sig-paren">(</span><em>idx0=0</em>, <em>idx1=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.get_intersegment_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.get_intersegment_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the distance between midpoints of two segments with index
idx0 and idx1. The argument returned is a vector [x, y, z], where
x = self.xmid[idx1] - self.xmid[idx0] etc.</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>idx0 : int
idx1 : int
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.get_pt3d_polygons">
<code class="descname">get_pt3d_polygons</code><span class="sig-paren">(</span><em>projection=('x'</em>, <em>'z')</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.get_pt3d_polygons"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.get_pt3d_polygons" title="Permalink to this definition">¶</a></dt>
<dd><p>for each section create a polygon in the plane determined by keyword
argument projection=(&#8216;x&#8217;, &#8216;z&#8217;), that can be
visualized using e.g., plt.fill()</p>
<p>Returned argument is a list of (x, z) tuples giving the trajectory
of each section that can be plotted using PolyCollection</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">PolyCollection</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">LFPy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="n">morphology</span><span class="o">=</span><span class="s">&#39;PATH/TO/MORPHOLOGY&#39;</span><span class="p">)</span>

<span class="n">zips</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_idx_polygons</span><span class="p">():</span>
    <span class="n">zips</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>

<span class="n">polycol</span> <span class="o">=</span> <span class="n">PolyCollection</span><span class="p">(</span><span class="n">zips</span><span class="p">,</span>
                         <span class="n">edgecolors</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">,</span>
                         <span class="n">facecolors</span><span class="o">=</span><span class="s">&#39;gray&#39;</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">polycol</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&#39;equal&#39;</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.get_rand_idx_area_norm">
<code class="descname">get_rand_idx_area_norm</code><span class="sig-paren">(</span><em>section='allsec'</em>, <em>nidx=1</em>, <em>z_min=-10000</em>, <em>z_max=10000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.get_rand_idx_area_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.get_rand_idx_area_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nidx segment indices in section with random probability
normalized to the membrane area of segment on 
interval [z_min, z_max]</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>section: str, string matching a section-name
nidx: int, number of random indices
z_min: float, depth filter
z_max: float depth filter            
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.get_rand_prob_area_norm">
<code class="descname">get_rand_prob_area_norm</code><span class="sig-paren">(</span><em>section='allsec'</em>, <em>z_min=-10000</em>, <em>z_max=10000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.get_rand_prob_area_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.get_rand_prob_area_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the probability (0-1) for synaptic coupling on segments
in section sum(prob)=1 over all segments in section.
Prob. determined by area.</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>section: str, string matching a section-name
z_min: float, depth filter
z_max: float depth filter            
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.get_rand_prob_area_norm_from_idx">
<code class="descname">get_rand_prob_area_norm_from_idx</code><span class="sig-paren">(</span><em>idx=array([0])</em>, <em>z_min=-10000</em>, <em>z_max=10000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.get_rand_prob_area_norm_from_idx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.get_rand_prob_area_norm_from_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normalized probability (0-1) for synaptic coupling on
segments in idx-array.
Normalised probability determined by area of segments.</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>idx : np.ndarray, dtype=int.
    array of segment indices
z_min: float, depth filter
z_max: float depth filter            
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.insert_v_ext">
<code class="descname">insert_v_ext</code><span class="sig-paren">(</span><em>v_ext</em>, <em>t_ext</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.insert_v_ext"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.insert_v_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>playback of some extracellular potential v_ext on each cell.totnseg
compartments. Assumes that the &#8220;extracellular&#8221;-mechanism is inserted
on each compartment.</p>
<p>Can be used to study ephaptic effects and similar</p>
<p>The inputs will be copied and attached to the cell object as
cell.v_ext, cell.t_ext, and converted
to (list of) neuron.h.Vector types, to allow playback into each
compartment e_extracellular reference.</p>
<p>Can not be deleted prior to running cell.simulate()</p>
<p>Args:</p>
<div class="highlight-python"><div class="highlight"><pre>v_ext : cell.totnsegs x t_ext.size np.array, unit mV
t_ext : np.array, time vector of v_ext
</pre></div>
</div>
<p>Simple usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">LFPy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="c">#create cell</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">LFPy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="n">morphology</span><span class="o">=</span><span class="s">&#39;morphologies/example_morphology.hoc&#39;</span><span class="p">)</span>

<span class="c">#time vector and extracellular field for every segment:</span>
<span class="n">t_ext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">tstopms</span> <span class="o">/</span> <span class="n">cell</span><span class="o">.</span><span class="n">timeres_python</span><span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>                     <span class="n">cell</span><span class="o">.</span><span class="n">timeres_python</span>
<span class="n">v_ext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">totnsegs</span><span class="p">,</span> <span class="n">t_ext</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span>

<span class="c">#insert potentials and record response:</span>
<span class="n">cell</span><span class="o">.</span><span class="n">insert_v_ext</span><span class="p">(</span><span class="n">v_ext</span><span class="p">,</span> <span class="n">t_ext</span><span class="p">)</span>
<span class="n">cell</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">rec_imem</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">rec_vmem</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">311</span><span class="p">)</span>
<span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">312</span><span class="p">)</span>
<span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">313</span><span class="p">)</span>
<span class="n">eim</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">v_ext</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s">&#39;spectral&#39;</span><span class="p">)</span>
<span class="n">cb1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">eim</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>
<span class="n">cb1</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s">&#39;v_ext&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="n">ax1</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&#39;tight&#39;</span><span class="p">))</span>
<span class="n">iim</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">imem</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">&#39;spectral&#39;</span><span class="p">)</span>
<span class="n">cb2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">iim</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">)</span>
<span class="n">cb2</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s">&#39;imem&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="n">ax2</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&#39;tight&#39;</span><span class="p">))</span>
<span class="n">vim</span> <span class="o">=</span> <span class="n">ax3</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">vmem</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">&#39;spectral&#39;</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="n">ax3</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&#39;tight&#39;</span><span class="p">))</span>
<span class="n">cb3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">vim</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax3</span><span class="p">)</span>
<span class="n">cb3</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s">&#39;vmem&#39;</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&#39;tstep&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.set_point_process">
<code class="descname">set_point_process</code><span class="sig-paren">(</span><em>idx</em>, <em>pptype</em>, <em>record_current=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.set_point_process"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.set_point_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert pptype-electrode type pointprocess on segment numbered
idx on cell object, with keyword arguments according to types 
SEClamp, VClamp, IClamp, SinIClamp, ChirpIClamp.</p>
<p>Arguments:</p>
<div class="highlight-python"><div class="highlight"><pre>idx : int
pptype : str
record_current : bool
kwargs : arguments passed on from class StimIntElectrode
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.set_pos">
<code class="descname">set_pos</code><span class="sig-paren">(</span><em>xpos=0</em>, <em>ypos=0</em>, <em>zpos=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.set_pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.set_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the cell geometry so that midpoint of soma section is
in (xpos, ypos, zpos). If no soma pos, use the first segment</p>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.set_rotation">
<code class="descname">set_rotation</code><span class="sig-paren">(</span><em>x=None</em>, <em>y=None</em>, <em>z=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.set_rotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.set_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate geometry of cell object around the x-, y-, z-axis in that order.
Input should be angles in radians.</p>
<p>using rotation matrices, takes dict with rot. angles,
where x, y, z are the rotation angles around respective axes.
All rotation angles are optional.</p>
<p>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cell</span> <span class="o">=</span> <span class="n">LFPy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="n">rotation</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;x&#39;</span> <span class="p">:</span> <span class="mf">1.233</span><span class="p">,</span> <span class="s">&#39;y&#39;</span> <span class="p">:</span> <span class="mf">0.236</span><span class="p">,</span> <span class="s">&#39;z&#39;</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">}</span>
<span class="n">cell</span><span class="o">.</span><span class="n">set_rotation</span><span class="p">(</span><span class="o">**</span><span class="n">rotation</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.set_synapse">
<code class="descname">set_synapse</code><span class="sig-paren">(</span><em>idx</em>, <em>syntype</em>, <em>record_current=False</em>, <em>record_potential=False</em>, <em>weight=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.set_synapse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.set_synapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert syntype (e.g. ExpSyn) synapse on segment with index idx,</p>
<p>Arguments:</p>
<div class="highlight-python"><div class="highlight"><pre>idx : int
syntype : str
record_current : bool
record_potential : bool
weight : float            
kwargs : arguments passed on from class Synapse
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.simulate">
<code class="descname">simulate</code><span class="sig-paren">(</span><em>electrode=None</em>, <em>rec_imem=False</em>, <em>rec_vmem=False</em>, <em>rec_ipas=False</em>, <em>rec_icap=False</em>, <em>rec_isyn=False</em>, <em>rec_vmemsyn=False</em>, <em>rec_istim=False</em>, <em>rec_variables=[]</em>, <em>variable_dt=False</em>, <em>atol=0.001</em>, <em>to_memory=True</em>, <em>to_file=False</em>, <em>file_name=None</em>, <em>dotprodcoeffs=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.simulate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main function running the simulation of the NEURON model.
Start NEURON simulation and record variables specified by arguments.</p>
<p>Arguments:</p>
<div class="highlight-python"><div class="highlight"><pre>electrode:  Either an LFPy.RecExtElectrode object or a list of such.
            If supplied, LFPs will be calculated at every time step
            and accessible as electrode.LFP. If a list of objects
            is given, accessible as electrode[0].LFP etc.
rec_imem:   If true, segment membrane currents will be recorded
            If no electrode argument is given, it is necessary to
            set rec_imem=True in order to calculate LFP later on.
            Units of (nA).
rec_vmem:   record segment membrane voltages (mV)
rec_ipas:   record passive segment membrane currents (nA)
rec_icap:   record capacitive segment membrane currents (nA)
rec_isyn:   record synaptic currents of from Synapse class (nA)
rec_vmemsyn:    record membrane voltage of segments with Synapse(mV)
rec_istim:  record currents of StimIntraElectrode (nA)
rec_variables: list of variables to record, i.e arg=[&#39;cai&#39;, ]
variable_dt: boolean, using variable timestep in NEURON
atol:       absolute tolerance used with NEURON variable timestep 
to_memory:  only valid with electrode, store lfp in -&gt; electrode.LFP 
to_file:    only valid with electrode, save LFPs in hdf5 file format 
file_name:  name of hdf5 file, &#39;.h5&#39; is appended if it doesnt exist
dotprodcoeffs :  list of N x Nseg np.ndarray. These arrays will at
            every timestep be multiplied by the membrane currents.
            Presumably useful for memory efficient csd or lfp calcs
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="LFPy.Cell.strip_hoc_objects">
<code class="descname">strip_hoc_objects</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/cell.html#Cell.strip_hoc_objects"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Cell.strip_hoc_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroy any NEURON hoc objects in the cell object</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-templatecell">
<h2>class <a class="reference internal" href="#LFPy.TemplateCell" title="LFPy.TemplateCell"><code class="xref py py-class docutils literal"><span class="pre">TemplateCell</span></code></a><a class="headerlink" href="#class-templatecell" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LFPy.TemplateCell">
<em class="property">class </em><code class="descclassname">LFPy.</code><code class="descname">TemplateCell</code><span class="sig-paren">(</span><em>templatefile='LFPyCellTemplate.hoc'</em>, <em>templatename='LFPyCellTemplate'</em>, <em>templateargs=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/templatecell.html#TemplateCell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.TemplateCell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">LFPy.cell.Cell</span></code></p>
<p>This class allow using cell templates with some limitations</p>
<p>Arguments:</p>
<div class="highlight-python"><div class="highlight"><pre>morphology : [str]: path to morphology file;

templatefile :  [str]: Cell template definition(s)
templatename :  [str]: Cell template-name used for this cell object
templateargs :  [str]: Arguments provided to template-definition

v_init: [-65.]: initial potential
passive: [True]/False: passive mechs are initialized if True
Ra: [150.]: axial resistance
rm: [30000]: membrane resistivity
cm: [1.0]: membrane capacitance
e_pas: [-65.]: passive mechanism reversal potential
extracellular: [True]/False: switch for NEURON&#39;s extracellular mechanism

timeres_NEURON: [0.1]: internal dt for NEURON simulation
timeres_python: [0.1]: overall dt for python simulation

tstartms: [0.]:  initialization time for simulation &lt;= 0 ms
tstopms: [100.]: stop time for simulation &gt; 0 ms

nsegs_method: [&#39;lambda100&#39;]/&#39;lambda_f&#39;/&#39;fixed_length&#39;: nseg rule
max_nsegs_length: [None]: max segment length for method &#39;fixed_length&#39;
lambda_f: [100]: AC frequency for method &#39;lambda_f&#39;

delete_sections: [True]: delete pre-existing section-references

custom_code: [None]: list of model-specific code files ([.py/.hoc])
custom_fun: [None]: list of model-specific functions with args
custom_fun_args: [None]: list of args passed to custom_fun functions
pt3d: True/[False]: use pt3d-info of the cell geometries switch
verbose: True/[False]: verbose output switch
</pre></div>
</div>
<p>Usage of TemplateCell class:</p>
<div class="highlight-python"><div class="highlight"><pre>import LFPy
cellParameters = {                      
    &#39;morphology&#39; : &#39;path/to/morphology&#39;,
    &#39;templatefile&#39; :  &#39;path/to/template-file (.hoc)
    &#39;templatename&#39; :  &#39;templatename&#39;
    &#39;templateargs&#39; :  None

    &#39;rm&#39; : 30000,
    &#39;cm&#39; : 1.0,
    &#39;Ra&#39; : 150,
    &#39;timeres_NEURON&#39; : 0.1,
    &#39;timeres_python&#39; : 0.1,
    &#39;tstartms&#39; : -50,
    &#39;tstopms&#39; : 50,
}
cell = LFPy.TemplateCell(**cellParameters)
cell.simulate()
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="class-pointprocess">
<h2>class <a class="reference internal" href="#LFPy.PointProcess" title="LFPy.PointProcess"><code class="xref py py-class docutils literal"><span class="pre">PointProcess</span></code></a><a class="headerlink" href="#class-pointprocess" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LFPy.PointProcess">
<em class="property">class </em><code class="descclassname">LFPy.</code><code class="descname">PointProcess</code><span class="sig-paren">(</span><em>cell</em>, <em>idx</em>, <em>color='k'</em>, <em>marker='o'</em>, <em>record_current=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/pointprocess.html#PointProcess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.PointProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Superclass on top of Synapse, StimIntElectrode, 
just to import and set some shared variables.</p>
<p>Arguments:</p>
<div class="highlight-python"><div class="highlight"><pre>cell    : LFPy.Cell object
idx     : index of segment
color   : color in plot (optional) 
marker  : marker in plot (optional) 
record_current : Must be set True for recording of pointprocess currents
kwargs  : pointprocess specific variables passed on to cell/neuron
</pre></div>
</div>
<dl class="method">
<dt id="LFPy.PointProcess.update_pos">
<code class="descname">update_pos</code><span class="sig-paren">(</span><em>cell</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/pointprocess.html#PointProcess.update_pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.PointProcess.update_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract coordinates of point-process</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-synapse">
<h2>class <a class="reference internal" href="#LFPy.Synapse" title="LFPy.Synapse"><code class="xref py py-class docutils literal"><span class="pre">Synapse</span></code></a><a class="headerlink" href="#class-synapse" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LFPy.Synapse">
<em class="property">class </em><code class="descclassname">LFPy.</code><code class="descname">Synapse</code><span class="sig-paren">(</span><em>cell</em>, <em>idx</em>, <em>syntype</em>, <em>color='r'</em>, <em>marker='o'</em>, <em>record_current=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/pointprocess.html#Synapse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Synapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">LFPy.pointprocess.PointProcess</span></code></p>
<p>The synapse class, pointprocesses that spawn membrane currents.
See <a class="reference external" href="http://www.neuron.yale.edu/neuron/static/docs/help/neuron/neuron/mech.html#pointprocesses">http://www.neuron.yale.edu/neuron/static/docs/help/neuron/neuron/mech.html#pointprocesses</a>
for details, or corresponding mod-files.</p>
<p>This class is meant to be used with synaptic mechanisms, giving rise to
currents that will be part of the membrane currents.</p>
<p>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">LFPy</span>
<span class="kn">import</span> <span class="nn">pylab</span> <span class="kn">as</span> <span class="nn">pl</span>

<span class="n">pl</span><span class="o">.</span><span class="n">interactive</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">cellParameters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;morphology&#39;</span> <span class="p">:</span>  <span class="s">&#39;morphologies/L5_Mainen96_LFPy.hoc&#39;</span><span class="p">,</span>
    <span class="s">&#39;tstopms&#39;</span> <span class="p">:</span>     <span class="mi">50</span><span class="p">,</span> 
<span class="p">}</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">LFPy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="o">**</span><span class="n">cellParameters</span><span class="p">)</span>

<span class="n">synapseParameters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;idx&#39;</span> <span class="p">:</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_closest_idx</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">800</span><span class="p">),</span>
    <span class="s">&#39;e&#39;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>                                <span class="c"># reversal potential</span>
    <span class="s">&#39;syntype&#39;</span> <span class="p">:</span> <span class="s">&#39;ExpSyn&#39;</span><span class="p">,</span>                   <span class="c"># synapse type</span>
    <span class="s">&#39;tau&#39;</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span>                              <span class="c"># syn. time constant</span>
    <span class="s">&#39;weight&#39;</span> <span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>                        <span class="c"># syn. weight</span>
    <span class="s">&#39;record_current&#39;</span> <span class="p">:</span> <span class="bp">True</span>                 <span class="c"># syn. current record</span>
<span class="p">}</span>
<span class="n">synapse</span> <span class="o">=</span> <span class="n">LFPy</span><span class="o">.</span><span class="n">Synapse</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="o">**</span><span class="n">synapseParameters</span><span class="p">)</span>
<span class="n">synapse</span><span class="o">.</span><span class="n">set_spike_times</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">]))</span>
<span class="n">cell</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">rec_isyn</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">pl</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
<span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">tvec</span><span class="p">,</span> <span class="n">synapse</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>
<span class="n">pl</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Synapse current (nA)&#39;</span><span class="p">)</span>
<span class="n">pl</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
<span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">tvec</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">somav</span><span class="p">)</span>
<span class="n">pl</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Somatic potential (mV)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="LFPy.Synapse.collect_current">
<code class="descname">collect_current</code><span class="sig-paren">(</span><em>cell</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/pointprocess.html#Synapse.collect_current"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Synapse.collect_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect synapse current</p>
</dd></dl>

<dl class="method">
<dt id="LFPy.Synapse.collect_potential">
<code class="descname">collect_potential</code><span class="sig-paren">(</span><em>cell</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/pointprocess.html#Synapse.collect_potential"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Synapse.collect_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect membrane potential of segment with synapse</p>
</dd></dl>

<dl class="method">
<dt id="LFPy.Synapse.set_spike_times">
<code class="descname">set_spike_times</code><span class="sig-paren">(</span><em>sptimes=array([]</em>, <em>dtype=float64)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/pointprocess.html#Synapse.set_spike_times"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.Synapse.set_spike_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the spike times</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-stimintelectrode">
<h2>class <a class="reference internal" href="#LFPy.StimIntElectrode" title="LFPy.StimIntElectrode"><code class="xref py py-class docutils literal"><span class="pre">StimIntElectrode</span></code></a><a class="headerlink" href="#class-stimintelectrode" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LFPy.StimIntElectrode">
<em class="property">class </em><code class="descclassname">LFPy.</code><code class="descname">StimIntElectrode</code><span class="sig-paren">(</span><em>cell</em>, <em>idx</em>, <em>pptype='SEClamp'</em>, <em>color='p'</em>, <em>marker='*'</em>, <em>record_current=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/pointprocess.html#StimIntElectrode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.StimIntElectrode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">LFPy.pointprocess.PointProcess</span></code></p>
<p>Class for NEURON point processes, ie VClamp, SEClamp and ICLamp,
SinIClamp, ChirpIClamp with arguments.
Electrode currents go here.
Membrane currents will no longer sum to zero if these mechanisms are used.</p>
<p>Refer to NEURON documentation &#64; neuron.yale.edu for kwargs</p>
<p>Usage example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#/usr/bin/python</span>

<span class="kn">import</span> <span class="nn">LFPy</span>
<span class="kn">import</span> <span class="nn">pylab</span> <span class="kn">as</span> <span class="nn">pl</span>

<span class="n">pl</span><span class="o">.</span><span class="n">interactive</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c">#define a list of different electrode implementations from NEURON</span>
<span class="n">pointprocesses</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="s">&#39;idx&#39;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s">&#39;record_current&#39;</span> <span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
        <span class="s">&#39;pptype&#39;</span> <span class="p">:</span> <span class="s">&#39;IClamp&#39;</span><span class="p">,</span>
        <span class="s">&#39;amp&#39;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s">&#39;dur&#39;</span> <span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
        <span class="s">&#39;delay&#39;</span> <span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#39;idx&#39;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s">&#39;record_current&#39;</span> <span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
        <span class="s">&#39;pptype&#39;</span> <span class="p">:</span> <span class="s">&#39;VClamp&#39;</span><span class="p">,</span>
        <span class="s">&#39;amp[0]&#39;</span> <span class="p">:</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span>
        <span class="s">&#39;dur[0]&#39;</span> <span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;amp[1]&#39;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s">&#39;dur[1]&#39;</span> <span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
        <span class="s">&#39;amp[2]&#39;</span> <span class="p">:</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span>
        <span class="s">&#39;dur[2]&#39;</span> <span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#39;idx&#39;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s">&#39;record_current&#39;</span> <span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
        <span class="s">&#39;pptype&#39;</span> <span class="p">:</span> <span class="s">&#39;SEClamp&#39;</span><span class="p">,</span>
        <span class="s">&#39;dur1&#39;</span> <span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;amp1&#39;</span> <span class="p">:</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span>
        <span class="s">&#39;dur2&#39;</span> <span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
        <span class="s">&#39;amp2&#39;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s">&#39;dur3&#39;</span> <span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;amp3&#39;</span> <span class="p">:</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">]</span>

<span class="c">#create a cell instance for each electrode</span>
<span class="k">for</span> <span class="n">pointprocess</span> <span class="ow">in</span> <span class="n">pointprocesses</span><span class="p">:</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">LFPy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="n">morphology</span><span class="o">=</span><span class="s">&#39;morphologies/L5_Mainen96_LFPy.hoc&#39;</span><span class="p">)</span>
    <span class="n">stimulus</span> <span class="o">=</span> <span class="n">LFPy</span><span class="o">.</span><span class="n">StimIntElectrode</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="o">**</span><span class="n">pointprocess</span><span class="p">)</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">rec_istim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
    <span class="n">pl</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
    <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">tvec</span><span class="p">,</span> <span class="n">stimulus</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">pointprocess</span><span class="p">[</span><span class="s">&#39;pptype&#39;</span><span class="p">])</span>
    <span class="n">pl</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">&#39;best&#39;</span><span class="p">)</span>
    <span class="n">pl</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Stimulus currents (nA)&#39;</span><span class="p">)</span>
    
    <span class="n">pl</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
    <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">tvec</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">somav</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">pointprocess</span><span class="p">[</span><span class="s">&#39;pptype&#39;</span><span class="p">])</span>
    <span class="n">pl</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">&#39;best&#39;</span><span class="p">)</span>
    <span class="n">pl</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Somatic potential (mV)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="LFPy.StimIntElectrode.collect_current">
<code class="descname">collect_current</code><span class="sig-paren">(</span><em>cell</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/pointprocess.html#StimIntElectrode.collect_current"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.StimIntElectrode.collect_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch electrode current from recorder list</p>
</dd></dl>

<dl class="method">
<dt id="LFPy.StimIntElectrode.collect_potential">
<code class="descname">collect_potential</code><span class="sig-paren">(</span><em>cell</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/pointprocess.html#StimIntElectrode.collect_potential"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.StimIntElectrode.collect_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect membrane potential of segment with PointProcess</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-recextelectrodesetup">
<h2>class <a class="reference internal" href="#LFPy.RecExtElectrodeSetup" title="LFPy.RecExtElectrodeSetup"><code class="xref py py-class docutils literal"><span class="pre">RecExtElectrodeSetup</span></code></a><a class="headerlink" href="#class-recextelectrodesetup" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LFPy.RecExtElectrodeSetup">
<em class="property">class </em><code class="descclassname">LFPy.</code><code class="descname">RecExtElectrodeSetup</code><span class="sig-paren">(</span><em>cell=None</em>, <em>sigma=0.3</em>, <em>x=array([0])</em>, <em>y=array([0])</em>, <em>z=array([0])</em>, <em>N=None</em>, <em>r=None</em>, <em>n=None</em>, <em>r_z=None</em>, <em>perCellLFP=False</em>, <em>method='linesource'</em>, <em>color='g'</em>, <em>marker='o'</em>, <em>from_file=False</em>, <em>cellfile=None</em>, <em>verbose=False</em>, <em>seedvalue=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/recextelectrode.html#RecExtElectrodeSetup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.RecExtElectrodeSetup" title="Permalink to this definition">¶</a></dt>
<dd><p>RecExtElectrode superclass. 
If (optional) cell argument is given then the it is imported,
otherwise the cell argument has to be passed later on to calc_lfp.
The argument cell can be an LFPy.cell.Cell or LFPy.templatecell.TemplateCell
object
Keyword arguments determine properties of later LFP-calculations</p>
<p>Arguments:</p>
<div class="highlight-python"><div class="highlight"><pre>cell : object,
    LFPy.cell.Cell or LFPy.templatecell.TemplateCell
sigma : float,
    extracellular conductivity
x, y, z : np.ndarray,
    coordinates or arrays of coordinates. Must be same length
N : np.ndarray,
    Normal vector [x, y, z] of contact surface, default None
r : float,
    radius of contact surface, default None
n : int,
    if N is not None and r &gt; 0, the number of points to use for each
          contact point in order to calculate average
method : str,
    [&#39;linesource&#39;]/&#39;pointsource&#39;/&#39;som_as_point&#39; switch
color : str,
    color of electrode contact points in plots
marker : str,
    marker of electrode contact points in plots
from_file : Bool,
    if True, load cell object from file
cellfile : str,
    path to cell pickle
verbose : Bool,
    Flag for verbose output
seedvalue : int,
    rand seed when finding random position on contact with r &gt;0
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="class-recextelectrode">
<h2>class <a class="reference internal" href="#LFPy.RecExtElectrode" title="LFPy.RecExtElectrode"><code class="xref py py-class docutils literal"><span class="pre">RecExtElectrode</span></code></a><a class="headerlink" href="#class-recextelectrode" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LFPy.RecExtElectrode">
<em class="property">class </em><code class="descclassname">LFPy.</code><code class="descname">RecExtElectrode</code><span class="sig-paren">(</span><em>cell=None</em>, <em>sigma=0.3</em>, <em>x=array([0])</em>, <em>y=array([0])</em>, <em>z=array([0])</em>, <em>N=None</em>, <em>r=None</em>, <em>n=0</em>, <em>r_z=None</em>, <em>perCellLFP=False</em>, <em>method='linesource'</em>, <em>color='g'</em>, <em>marker='o'</em>, <em>from_file=False</em>, <em>cellfile=None</em>, <em>verbose=False</em>, <em>seedvalue=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/recextelectrode.html#RecExtElectrode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.RecExtElectrode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">LFPy.recextelectrode.RecExtElectrodeSetup</span></code></p>
<p>RecExtElectrode class with inheritance from LFPy.RecExtElectrodeSetup 
able to actually calculate local field potentials from LFPy.Cell objects.</p>
<p>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre>import numpy as np
import import matplotlib.pyplot as plt
import LFPy

N = np.empty((16, 3))
for i in xrange(N.shape[0]): N[i,] = [1, 0, 0] #normal vec. of contacts
electrodeParameters = {         #parameters for RecExtElectrode class
    &#39;sigma&#39; : 0.3,              #Extracellular potential
    &#39;x&#39; : np.zeros(16)+25,      #Coordinates of electrode contacts
    &#39;y&#39; : np.zeros(16),
    &#39;z&#39; : np.linspace(-500,1000,16),
    &#39;n&#39; : 20,
    &#39;r&#39; : 10,
    &#39;N&#39; : N,
}

cellParameters = {                          
    &#39;morphology&#39; : &#39;L5_Mainen96_LFPy.hoc&#39;,  # morphology file
    &#39;rm&#39; : 30000,                           # membrane resistivity
    &#39;cm&#39; : 1.0,                             # membrane capacitance
    &#39;Ra&#39; : 150,                             # axial resistivity
    &#39;timeres_NEURON&#39; : 2**-4,                # dt for NEURON sim.
    &#39;timeres_python&#39; : 2**-4,                 # dt for python output
    &#39;tstartms&#39; : -50,                         # start t of simulation
    &#39;tstopms&#39; : 50,                        # end t of simulation
}

cell = LFPy.Cell(**cellParameters)

synapseParameters = {
    &#39;idx&#39; : cell.get_closest_idx(x=0, y=0, z=800), # compartment
    &#39;e&#39; : 0,                                # reversal potential
    &#39;syntype&#39; : &#39;ExpSyn&#39;,                   # synapse type
    &#39;tau&#39; : 2,                              # syn. time constant
    &#39;weight&#39; : 0.01,                       # syn. weight
    &#39;record_current&#39; : True                 # syn. current record
}

synapse = LFPy.PointProcessSynapse(cell, **synapseParameters)
synapse.set_spike_times(cell, np.array([10, 15, 20, 25]))

cell.simulate()

electrode = LFPy.RecExtElectrode(cell, **electrodeParameters)
electrode.calc_lfp()
plt.matshow(electrode.LFP)
</pre></div>
</div>
<dl class="method">
<dt id="LFPy.RecExtElectrode.calc_lfp">
<code class="descname">calc_lfp</code><span class="sig-paren">(</span><em>t_indices=None</em>, <em>cell=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/recextelectrode.html#RecExtElectrode.calc_lfp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.RecExtElectrode.calc_lfp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate LFP on electrode geometry from all cell instances.
Will chose distributed calculated if electrode contain &#8216;n&#8217;, &#8216;N&#8217;, and &#8216;r&#8217;</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-LFPy.lfpcalc">
<span id="submodule-lfpcalc"></span><h2>submodule <code class="xref py py-mod docutils literal"><span class="pre">lfpcalc</span></code><a class="headerlink" href="#module-LFPy.lfpcalc" title="Permalink to this headline">¶</a></h2>
<p>Copyright (C) 2012 Computational Neuroscience Group, UMB.</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<dl class="function">
<dt id="LFPy.lfpcalc.calc_lfp_choose">
<code class="descclassname">LFPy.lfpcalc.</code><code class="descname">calc_lfp_choose</code><span class="sig-paren">(</span><em>cell</em>, <em>x=0</em>, <em>y=0</em>, <em>z=0</em>, <em>sigma=0.3</em>, <em>r_limit=None</em>, <em>timestep=None</em>, <em>t_indices=None</em>, <em>method='linesource'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/lfpcalc.html#calc_lfp_choose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.lfpcalc.calc_lfp_choose" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine which method to use, line-source for soma default</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>cell: LFPy.Cell or LFPy.TemplateCell instance
x : double, extracellular position, x-axis
y : double, extracellular position, y-axis
z : double, extracellular position, z-axis
sigma : double, extracellular conductivity
r_limit : [None]/float/np.ndarray: minimum distance to source current
timestep : [None]/int, calculate LFP at this timestep
t_indices : [None]/np.ndarray, calculate LFP at specific timesteps
method=[&#39;linesource&#39;]/&#39;pointsource&#39;/&#39;som_as_point&#39;
    switch for choosing underlying methods
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="LFPy.lfpcalc.calc_lfp_linesource">
<code class="descclassname">LFPy.lfpcalc.</code><code class="descname">calc_lfp_linesource</code><span class="sig-paren">(</span><em>cell</em>, <em>x=0</em>, <em>y=0</em>, <em>z=0</em>, <em>sigma=0.3</em>, <em>r_limit=None</em>, <em>timestep=None</em>, <em>t_indices=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/lfpcalc.html#calc_lfp_linesource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.lfpcalc.calc_lfp_linesource" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate electric field potential using the line-source method, all
compartments treated as line sources, even soma.</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>cell: LFPy.Cell or LFPy.TemplateCell instance
x : double, extracellular position, x-axis
y : double, extracellular position, y-axis
z : double, extracellular position, z-axis
sigma : double, extracellular conductivity
r_limit : [None]/float/np.ndarray: minimum distance to source current
timestep : [None]/int, calculate LFP at this timestep
t_indices : [None]/np.ndarray, calculate LFP at specific timesteps
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="LFPy.lfpcalc.calc_lfp_pointsource">
<code class="descclassname">LFPy.lfpcalc.</code><code class="descname">calc_lfp_pointsource</code><span class="sig-paren">(</span><em>cell</em>, <em>x=0</em>, <em>y=0</em>, <em>z=0</em>, <em>sigma=0.3</em>, <em>r_limit=None</em>, <em>timestep=None</em>, <em>t_indices=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/lfpcalc.html#calc_lfp_pointsource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.lfpcalc.calc_lfp_pointsource" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate local field potentials using the point-source equation on all
compartments</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>cell: LFPy.Cell or LFPy.TemplateCell instance
x : double, extracellular position, x-axis
y : double, extracellular position, y-axis
z : double, extracellular position, z-axis
sigma : double, extracellular conductivity
r_limit : [None]/float/np.ndarray: minimum distance to source current
timestep : [None]/int, calculate LFP at this timestep
t_indices : [None]/np.ndarray, calculate LFP at specific timesteps
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="LFPy.lfpcalc.calc_lfp_som_as_point">
<code class="descclassname">LFPy.lfpcalc.</code><code class="descname">calc_lfp_som_as_point</code><span class="sig-paren">(</span><em>cell</em>, <em>x=0</em>, <em>y=0</em>, <em>z=0</em>, <em>sigma=0.3</em>, <em>r_limit=None</em>, <em>timestep=None</em>, <em>t_indices=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/lfpcalc.html#calc_lfp_som_as_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.lfpcalc.calc_lfp_som_as_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate electric field potential using the line-source method,
soma is treated as point/sphere source</p>
<p>kwargs:</p>
<div class="highlight-python"><div class="highlight"><pre>cell: LFPy.Cell or LFPy.TemplateCell instance
x : double, extracellular position, x-axis
y : double, extracellular position, y-axis
z : double, extracellular position, z-axis
sigma : double, extracellular conductivity
r_limit : [None]/float/np.ndarray: minimum distance to source current
timestep : [None]/int, calculate LFP at this timestep
t_indices : [None]/np.ndarray, calculate LFP at specific timesteps
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-LFPy.tools">
<span id="submodule-tools"></span><h2>submodule <code class="xref py py-mod docutils literal"><span class="pre">tools</span></code><a class="headerlink" href="#module-LFPy.tools" title="Permalink to this headline">¶</a></h2>
<p>Copyright (C) 2012 Computational Neuroscience Group, UMB.</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<dl class="function">
<dt id="LFPy.tools.load">
<code class="descclassname">LFPy.tools.</code><code class="descname">load</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/tools.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.tools.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic loading of cPickled objects from file</p>
</dd></dl>

<dl class="function">
<dt id="LFPy.tools.noise_brown">
<code class="descclassname">LFPy.tools.</code><code class="descname">noise_brown</code><span class="sig-paren">(</span><em>ncols</em>, <em>nrows=1</em>, <em>weight=1</em>, <em>filter=None</em>, <em>filterargs=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/tools.html#noise_brown"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.tools.noise_brown" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1/f^2 noise of shape(nrows, ncols obtained by taking 
the cumulative sum of gaussian white noise, with rms weight.</p>
<p>If filter is not None, this function will apply the filter coefficients obtained
by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="o">**</span><span class="n">filterargs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signal</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-LFPy.inputgenerators">
<span id="submodule-inputgenerators"></span><h2>submodule <code class="xref py py-mod docutils literal"><span class="pre">inputgenerators</span></code><a class="headerlink" href="#module-LFPy.inputgenerators" title="Permalink to this headline">¶</a></h2>
<p>Copyright (C) 2012 Computational Neuroscience Group, UMB.</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<dl class="function">
<dt id="LFPy.inputgenerators.get_normal_input_times">
<code class="descclassname">LFPy.inputgenerators.</code><code class="descname">get_normal_input_times</code><span class="sig-paren">(</span><em>n</em>, <em>mu</em>, <em>sigma</em>, <em>tstart</em>, <em>tstop</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/inputgenerators.html#get_normal_input_times"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.inputgenerators.get_normal_input_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates n normal-distributed prosesses with mean mu and 
deviation sigma</p>
</dd></dl>

<dl class="function">
<dt id="LFPy.inputgenerators.get_normal_spike_times">
<code class="descclassname">LFPy.inputgenerators.</code><code class="descname">get_normal_spike_times</code><span class="sig-paren">(</span><em>nsyn</em>, <em>mu</em>, <em>sigma</em>, <em>tstart</em>, <em>tstop</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/inputgenerators.html#get_normal_spike_times"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.inputgenerators.get_normal_spike_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate nsyn normal-distributed processes with mean mu and 
deviation sigma</p>
</dd></dl>

<dl class="function">
<dt id="LFPy.inputgenerators.get_rand_spike_times">
<code class="descclassname">LFPy.inputgenerators.</code><code class="descname">get_rand_spike_times</code><span class="sig-paren">(</span><em>synpos</em>, <em>nspikes</em>, <em>tstart</em>, <em>tstop</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/inputgenerators.html#get_rand_spike_times"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.inputgenerators.get_rand_spike_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Return synpos times nspikes random spike times on the 
interval [tstart, tstop]</p>
</dd></dl>

<dl class="function">
<dt id="LFPy.inputgenerators.stationary_gamma">
<code class="descclassname">LFPy.inputgenerators.</code><code class="descname">stationary_gamma</code><span class="sig-paren">(</span><em>tstart</em>, <em>tstop</em>, <em>k=2</em>, <em>theta=10</em>, <em>tmin=-1000.0</em>, <em>tmax=1000000.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/inputgenerators.html#stationary_gamma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.inputgenerators.stationary_gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate spiketimes with interspike interval statistics according
to gamma-distribution with &#8216;shape&#8217; k and &#8216;scale&#8217; theta between tstart and
tstop. Spiketimes from tmin up to tmax is calculated,
times between 0 and tstop are returned</p>
</dd></dl>

<dl class="function">
<dt id="LFPy.inputgenerators.stationary_poisson">
<code class="descclassname">LFPy.inputgenerators.</code><code class="descname">stationary_poisson</code><span class="sig-paren">(</span><em>nsyn</em>, <em>lambd</em>, <em>tstart</em>, <em>tstop</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/inputgenerators.html#stationary_poisson"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.inputgenerators.stationary_poisson" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate nsyn stationary possion processes with rate lambda 
between tstart and tstop</p>
</dd></dl>

<dl class="function">
<dt id="LFPy.inputgenerators.test_spiketimes">
<code class="descclassname">LFPy.inputgenerators.</code><code class="descname">test_spiketimes</code><span class="sig-paren">(</span><em>spiketime</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/LFPy/inputgenerators.html#test_spiketimes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LFPy.inputgenerators.test_spiketimes" title="Permalink to this definition">¶</a></dt>
<dd><p>Test and sort spike times</p>
</dd></dl>

</div>
<div class="section" id="module-LFPy.run_simulation">
<span id="submodule-run-simulation"></span><h2>submodule <code class="xref py py-mod docutils literal"><span class="pre">run_simulation</span></code><a class="headerlink" href="#module-LFPy.run_simulation" title="Permalink to this headline">¶</a></h2>
<p>Copyright (C) 2012 Computational Neuroscience Group, UMB.</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Module <code class="docutils literal"><span class="pre">LFPy</span></code></a><ul>
<li><a class="reference internal" href="#class-cell">class <code class="docutils literal"><span class="pre">Cell</span></code></a></li>
<li><a class="reference internal" href="#class-templatecell">class <code class="docutils literal"><span class="pre">TemplateCell</span></code></a></li>
<li><a class="reference internal" href="#class-pointprocess">class <code class="docutils literal"><span class="pre">PointProcess</span></code></a></li>
<li><a class="reference internal" href="#class-synapse">class <code class="docutils literal"><span class="pre">Synapse</span></code></a></li>
<li><a class="reference internal" href="#class-stimintelectrode">class <code class="docutils literal"><span class="pre">StimIntElectrode</span></code></a></li>
<li><a class="reference internal" href="#class-recextelectrodesetup">class <code class="docutils literal"><span class="pre">RecExtElectrodeSetup</span></code></a></li>
<li><a class="reference internal" href="#class-recextelectrode">class <code class="docutils literal"><span class="pre">RecExtElectrode</span></code></a></li>
<li><a class="reference internal" href="#module-LFPy.lfpcalc">submodule <code class="docutils literal"><span class="pre">lfpcalc</span></code></a></li>
<li><a class="reference internal" href="#module-LFPy.tools">submodule <code class="docutils literal"><span class="pre">tools</span></code></a></li>
<li><a class="reference internal" href="#module-LFPy.inputgenerators">submodule <code class="docutils literal"><span class="pre">inputgenerators</span></code></a></li>
<li><a class="reference internal" href="#module-LFPy.run_simulation">submodule <code class="docutils literal"><span class="pre">run_simulation</span></code></a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="contact.html"
                        title="previous chapter">Contact</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/classes.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="contact.html" title="Contact"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">LFPy 1.1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Computational Neuroscience Group, NMBU.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
<!--<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.-->
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>