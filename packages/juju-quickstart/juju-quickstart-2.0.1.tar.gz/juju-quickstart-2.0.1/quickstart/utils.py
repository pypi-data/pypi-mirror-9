# This file is part of the Juju Quickstart Plugin, which lets users set up a
# Juju environment in very few steps (https://launchpad.net/juju-quickstart).
# Copyright (C) 2013-2014 Canonical Ltd.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License version 3, as published by
# the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,
# SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Juju Quickstart general purpose utility functions and classes."""

from __future__ import (
    print_function,
    unicode_literals,
)

import datetime
import errno
import functools
import logging
import os
import pipes
import subprocess

import quickstart


def add_apt_repository(repository):
    """Add the given APT repository to the current list of APT sources.

    Also take care of installing the add-apt-repository script and of updating
    the list of APT packages after the repository installation.

    Raise an OSError if any error occur in the process.
    """
    print('adding the {} PPA repository'.format(repository))
    print('sudo privileges will be required for PPA installation')
    # The package including add-apt-repository is python-software-properties
    # in precise and software-properties-common after precise.
    add_repository_package = 'software-properties-common'
    if get_ubuntu_codename() == 'precise':
        add_repository_package = 'python-software-properties'
    commands = (
        ('/usr/bin/apt-get', 'update'),
        ('/usr/bin/apt-get', 'install', '-y', add_repository_package),
        ('/usr/bin/add-apt-repository', '-y', repository),
        ('/usr/bin/apt-get', 'update'),
    )
    for command in commands:
        retcode, _, error = call('sudo', *command)
        if retcode:
            raise OSError(error.encode('utf-8'))


def call(command, *args):
    """Call a subprocess passing the given arguments.

    Take the subcommand and its parameters as args.

    Return a tuple containing the subprocess return code, output and error.
    """
    pipe = subprocess.PIPE
    cmd = (command,) + args
    cmdline = ' '.join(map(pipes.quote, cmd))
    logging.debug('running the following: {}'.format(cmdline))
    try:
        process = subprocess.Popen(cmd, stdout=pipe, stderr=pipe)
    except OSError as err:
        # A return code 127 is returned by the shell when the command is not
        # found in the PATH.
        return 127, '', '{}: {}'.format(command, err)
    output, error = process.communicate()
    retcode = process.poll()
    logging.debug('retcode: {} | output: {!r} | error: {!r}'.format(
        retcode, output, error))
    return retcode, output.decode('utf-8'), error.decode('utf-8')


def get_quickstart_banner():
    """Return a quickstart banner suitable for being included in files.

    The banner is returned as a string, e.g.:

        # This file has been generated by juju quickstart v0.42.0
        # at 2013-12-31 23:59:00 UTC.
    """
    now = datetime.datetime.utcnow()
    formatted_date = now.isoformat(sep=b' ').split('.')[0]
    version = quickstart.get_version()
    return (
        '# This file has been generated by juju quickstart v{}\n'
        '# at {} UTC.\n\n'.format(version, formatted_date))


def get_ubuntu_codename():
    """Return the codename of the current Ubuntu release (e.g. "trusty").

    Raise an OSError if an error occurs retrieving the codename.
    """
    retcode, output, error = call('lsb_release', '-cs')
    if retcode:
        raise OSError(error.encode('utf-8'))
    return output.strip()


def mkdir(path):
    """Create a leaf directory and all intermediate ones.

    Also expand ~ and ~user constructions.
    If path exists and it's a directory, return without errors.
    """
    path = os.path.expanduser(path)
    try:
        os.makedirs(path)
    except OSError as err:
        # Re-raise the error if the target path exists but it is not a dir.
        if (err.errno != errno.EEXIST) or (not os.path.isdir(path)):
            raise


def get_juju_version(juju_command):
    """Return the current juju-core version.

    Return a (major:int, minor:int, patch:int) tuple, including major, minor
    and patch version numbers.

    Handle the special case of no patch level by defaulting to 0.

    Raise a ValueError if the "juju version" call exits with an error
    or the returned version is not well formed.
    """
    retcode, output, error = call(juju_command, 'version')
    if retcode:
        raise ValueError(error.encode('utf-8'))
    version_string = output.split('-')[0]
    try:
        parts = version_string.split('.', 2)
        if len(parts) == 2:
            parts.append(0)
        major, minor, patch = map(int, parts)
        return major, minor, patch
    except ValueError:
        msg = 'invalid version string: {}'.format(version_string)
        raise ValueError(msg.encode('utf-8'))


def run_once(function):
    """Return a decorated version of the given function which runs only once.

    Subsequent runs are just ignored and return None.
    """
    @functools.wraps(function)
    def decorated(*args, **kwargs):
        if not decorated.called:
            decorated.called = True
            return function(*args, **kwargs)
    decorated.called = False
    return decorated
