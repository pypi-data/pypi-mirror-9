.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.46.4.
.TH NUITKA "1" "January 2015" "nuitka 0.5.7.1" "User Commands"
.SH NAME
nuitka \- the Python compiler
.SH SYNOPSIS
.B nuitka
[\fI\,--module\/\fR] [\fI\,--execute\/\fR] [\fI\,options\/\fR] \fI\,main_module.py\/\fR
.SH OPTIONS
.TP
\fB\-\-version\fR
show program's version number and exit
.TP
\fB\-h\fR, \fB\-\-help\fR
show this help message and exit
.TP
\fB\-\-module\fR
Create an extension module executable instead of a
program. Defaults to off.
.TP
\fB\-\-standalone\fR, \fB\-\-portable\fR
Enable standalone mode in build. This allows you to
transfer the created binary to other machines without
it relying on an existing Python installation. It
implies these options: "\-\-recurse\-all \fB\-\-recursestdlib\fR". Defaults to off.
.TP
\fB\-\-nofreeze\-stdlib\fR
In standalone mode by default all modules of standard
library will be frozen as bytecode. As a result
compilation time will increase very much.
.TP
\fB\-\-python\-version\fR=\fI\,PYTHON_VERSION\/\fR
Major version of Python to be used, one of '2.6',
\&'2.7', '3.2', '3.3', or '3.4'. Defaults to what you
run Nuitka with.
.TP
\fB\-\-python\-debug\fR, \fB\-\-python\-dbg\fR
Use debug version or not. Default uses what you are
using to run Nuitka, most likely a non\-debug version.
.TP
\fB\-\-python\-flag\fR=\fI\,PYTHON_FLAGS\/\fR
Python flags to use. Default uses what you are using
to run Nuitka, this enforces a specific mode. These
are options that also exist to standard Python
executable. Currently supported: "\-S" (alias nosite),
"static_hashes" (not use Randomization), "no_warnings"
(do not give Python runtime warnings). Default empty.
.TP
\fB\-\-warn\-implicit\-exceptions\fR
Given warnings for implicit exceptions detected at
compile time.
.SS Control the recursion into imported modules:
.BR
.TP
\fB\-\-recurse\-stdlib\fR
Also descend into imported modules from standard
library. Defaults to off.
.TP
\fB\-\-recurse\-none\fR
When \fB\-\-recurse\-none\fR is used, do not descend into any
imported modules at all, overrides all other recursion
options. Defaults to off.
.TP
\fB\-\-recurse\-all\fR, \fB\-\-recurse\-on\fR
When \fB\-\-recurse\-all\fR is used, attempt to descend into
all imported modules. Defaults to off.
.TP
\fB\-\-recurse\-to\fR=\fI\,MODULE\/\fR/PACKAGE
Recurse to that module, or if a package, to the whole
package. Can be given multiple times. Default empty.
.TP
\fB\-\-recurse\-not\-to\fR=\fI\,MODULE\/\fR/PACKAGE
Do not recurse to that module, or if a package, to the
whole package in any case, overrides all other
options. Can be given multiple times. Default empty.
.TP
\fB\-\-recurse\-plugins\fR=\fI\,MODULE\/\fR/PACKAGE, \fB\-\-recurse\-directory\fR=\fI\,MODULE\/\fR/PACKAGE
Recurse into that directory, no matter if it's used by
the given main program in a visible form. Overrides
all other options. Can be given multiple times.
Default empty.
.SS Immediate execution after compilation:
.BR
.TP
\fB\-\-run\fR, \fB\-\-execute\fR
Execute immediately the created binary (or import the
compiled module). Defaults to off.
.TP
\fB\-\-execute\-with\-pythonpath\fR, \fB\-\-keep\-pythonpath\fR
When immediately executing the created binary
(\fB\-\-execute\fR), don't reset PYTHONPATH. When all modules
are successfully included, you ought to not need
PYTHONPATH anymore.
.SS Dump options for internal tree:
.BR
.TP
\fB\-\-dump\-xml\fR, \fB\-\-xml\fR
Dump the final result of optimization as XML, then
exit.
.TP
\fB\-\-display\-tree\fR
Display the final result of optimization in a GUI,
then exit.
.SS Code generation choices:
.BR
.TP
\fB\-\-improved\fR, \fB\-\-enhanced\fR
Allow minor deviations from CPython behavior, e.g.
better tracebacks, which are not really incompatible,
but different.
.SS Output directory choices:
.BR
.TP
\fB\-\-output\-dir\fR=\fI\,DIRECTORY\/\fR
Specify where intermediate and final output files
should be put. DIRECTORY will be populated with C++
files, object files, etc. Defaults to current
directory.
.TP
\fB\-\-remove\-output\fR
Removes the build directory after producing the module
or exe file. Defaults to off.
.SS Debug features:
.BR
.TP
\fB\-\-debug\fR
Executing all self checks possible to find errors in
Nuitka, do not use for production. Defaults to off.
.TP
\fB\-\-unstripped\fR, \fB\-\-no\-strip\fR, \fB\-\-unstriped\fR
Keep debug info in the resulting object file for
better debugger interaction. Defaults to off.
.TP
\fB\-\-trace\-execution\fR
Traced execution output, output the line of code
before executing it. Defaults to off.
.TP
\fB\-\-c\fR++\-only
Compile the would\-be regenerated source file. Allows
compiling edited C++ files with the C++ compiler for
quick debugging changes to the generated source.
Defaults to off.
.TP
\fB\-\-experimental\fR
Use features declared as 'experimental'. May have no
effect if no experimental features are present in the
code. Defaults to off.
.SS Backend C++ compiler choice:
.BR
.TP
\fB\-\-clang\fR
Enforce the use of clang (needs clang 3.2 or higher).
Defaults to off.
.TP
\fB\-\-mingw\fR
Enforce the use of MinGW on Windows. Defaults to off.
.TP
\fB\-\-msvc\fR=\fI\,MSVC\/\fR
Enforce the use of specific MSVC version on Windows.
Allowed values are e.g. 9.0, 9.0exp, specify an
illegal value for a list of installed compilers.
Defaults to the most recent version.
.TP
\fB\-j\fR N, \fB\-\-jobs\fR=\fI\,N\/\fR
Specify the allowed number of parallel C++ compiler
jobs. Defaults to the system CPU count.
.TP
\fB\-\-lto\fR
Use link time optimizations if available and usable
(g++ 4.6 and higher). Defaults to off.
.SS Tracing features:
.BR
.TP
\fB\-\-show\-scons\fR
Operate Scons in non\-quiet mode, showing the executed
commands. Defaults to off.
.TP
\fB\-\-show\-progress\fR
Provide progress information and statistics. Defaults
to off.
.TP
\fB\-\-show\-modules\fR
Provide a final summary on included modules. Defaults
to off.
.TP
\fB\-\-verbose\fR
Output details of actions taken, esp. in
optimizations. Can become a lot. Defaults to off.
.SS Windows specific output control::
.BR
.TP
\fB\-\-windows\-disable\-console\fR
When compiling for Windows, disable the console
window. Defaults to off.
.TP
\fB\-\-windows\-icon\fR=\fI\,ICON_PATH\/\fR, \fB\-\-icon\fR=\fI\,ICON_PATH\/\fR
Add executable icon (Windows only).
.SH EXAMPLES

Compile a python file "some_module.py" to a module "some_module.so":
.IP
\f(CW$ nuitka some_module.py\fR
.PP
Compile a python program "some_program.py" to an executable "some_program.exe":
.IP
\f(CW$ nuitka \-\-exe some_program.py\fR
.PP
Compile a python program "some_program.py" and the package "some_package" it
uses to an executable "some_program.exe":
.IP
\f(CW$ nuitka \-\-exe \-\-recurse\-to=some_package some_program.py\fR
.PP
Compile a python program "some_program.py" and all the modules it uses to an executable "some_program.exe". Then execute it immediately when ready:
.IP
\f(CW$ nuitka  \-\-exe \-\-execute \-\-recurse\-all some_program.py\fR
.PP
Compile a python program "some_program.py" and the modules it uses (even standard library) to an executable "some_program.exe":
.IP
\f(CW$ nuitka \-\-recurse\-all \-\-recurse\-stdlib some_program.py \-\-exe\fR
.PP
Compile a python program "some_program.py" and the modules it uses to an executable "some_program.exe". Keep the debug information, so valrind, gdb, etc. work
nice.

Note: This will *not* degrade performance:
.IP
\f(CW$ nuitka \-\-unstriped \-\-recurse\-all some_program.py \-\-exe\fR
.PP
Compile a python program "some_program.py" and the modules it uses to an executable "some_program.exe". Perform all kinds of checks about correctness of the generated
C++ and run\-time checks.

Note: This will degrade performance and should only be used to debug Nuitka:
.IP
\f(CW$ nuitka \-\-debug \-\-recurse\-all some_program.py \-\-exe\fR
.PP
Compile a python program "some_program.py" and the modules it uses to an executable "some_program.exe". Perform all kinds of checks about correctness of the generated
C++ and run\-time checks. Also use the debug Python library, which does its own checks.

Note: This will degrade performance and should only be used to debug Nuitka:
.IP
\f(CW$ nuitka \-\-debug \-\-python-debug \-\-recurse\-all some_program.py \-\-exe\fR
.PP
Compile a python program "some_program.py" and the plugins modules it loads at run time to an executable "some_program.exe":
.IP
\f(CW$ nuitka \-\-recurse\-all \-\-recurse\-directory=plugins_dir some_program.py \-\-exe\fR
.PP
