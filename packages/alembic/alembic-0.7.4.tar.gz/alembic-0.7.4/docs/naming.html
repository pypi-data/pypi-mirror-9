<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The Importance of Naming Constraints &mdash; Alembic 0.7.4 documentation</title>
    
    <link rel="stylesheet" href="_static/nature_override.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/changelog.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx_paramlinks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.7.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Alembic 0.7.4 documentation" href="index.html" />
    <link rel="next" title="Running “Batch” Migrations for SQLite and Other Databases" href="batch.html" />
    <link rel="prev" title="Generating SQL Scripts (a.k.a. “Offline Mode”)" href="offline.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="batch.html" title="Running “Batch” Migrations for SQLite and Other Databases"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="offline.html" title="Generating SQL Scripts (a.k.a. “Offline Mode”)"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Alembic 0.7.4 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-importance-of-naming-constraints">
<span id="tutorial-constraint-names"></span><h1>The Importance of Naming Constraints<a class="headerlink" href="#the-importance-of-naming-constraints" title="Permalink to this headline">¶</a></h1>
<p>An important topic worth mentioning is that of constraint naming conventions.
As we&#8217;ve proceeded here, we&#8217;ve talked about adding tables and columns, and
we&#8217;ve also hinted at lots of other operations listed in <a class="reference internal" href="ops.html#ops"><em>Operation Reference</em></a> such as those
which support adding or dropping constraints like foreign keys and unique
constraints.   The way these constraints are referred to in migration scripts
is by name, however these names by default are in most cases generated by
the relational database in use, when the constraint is created.  For example,
if you emitted two CREATE TABLE statements like this on Postgresql:</p>
<div class="highlight-python"><div class="highlight"><pre>test=&gt; CREATE TABLE user_account (id INTEGER PRIMARY KEY);
CREATE TABLE
test=&gt; CREATE TABLE user_order (
test(&gt;   id INTEGER PRIMARY KEY,
test(&gt;   user_account_id INTEGER REFERENCES user_account(id));
CREATE TABLE
</pre></div>
</div>
<p>Suppose we wanted to DROP the REFERENCES that we just applied to the
<tt class="docutils literal"><span class="pre">user_order.user_account_id</span></tt> column, how do we do that?  At the prompt,
we&#8217;d use <tt class="docutils literal"><span class="pre">ALTER</span> <span class="pre">TABLE</span> <span class="pre">&lt;tablename&gt;</span> <span class="pre">DROP</span> <span class="pre">CONSTRAINT</span> <span class="pre">&lt;constraint_name&gt;</span></tt>, or if
using Alembic we&#8217;d be using <a class="reference internal" href="ops.html#alembic.operations.Operations.drop_constraint" title="alembic.operations.Operations.drop_constraint"><tt class="xref py py-meth docutils literal"><span class="pre">Operations.drop_constraint()</span></tt></a>.  But both
of those functions need a name - what&#8217;s the name of this constraint?</p>
<p>It does have a name, which in this case we can figure out by looking at the
Postgresql catalog tables:</p>
<div class="highlight-python"><div class="highlight"><pre>test=&gt; SELECT r.conname FROM
test-&gt;  pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
test-&gt;  JOIN pg_catalog.pg_constraint r  ON c.oid = r.conrelid
test-&gt;  WHERE c.relname=&#39;user_order&#39; AND r.contype = &#39;f&#39;
test-&gt; ;
             conname
---------------------------------
 user_order_user_account_id_fkey
(1 row)
</pre></div>
</div>
<p>The name above is not something that Alembic or SQLAlchemy created;
<tt class="docutils literal"><span class="pre">user_order_user_account_id_fkey</span></tt> is a naming scheme used internally by
Postgresql to name constraints that are otherwise not named.</p>
<p>This scheme doesn&#8217;t seem so complicated, and we might want to just use our
knowledge of it so that we know what name to use for our
<a class="reference internal" href="ops.html#alembic.operations.Operations.drop_constraint" title="alembic.operations.Operations.drop_constraint"><tt class="xref py py-meth docutils literal"><span class="pre">Operations.drop_constraint()</span></tt></a> call.  But is that a good idea?   What
if for example we needed our code to run on Oracle as well.  OK, certainly
Oracle uses this same scheme, right?  Or if not, something similar.  Let&#8217;s
check:</p>
<div class="highlight-python"><div class="highlight"><pre>Oracle Database 10g Express Edition Release 10.2.0.1.0 - Production

SQL&gt; CREATE TABLE user_account (id INTEGER PRIMARY KEY);

Table created.

SQL&gt; CREATE TABLE user_order (
  2     id INTEGER PRIMARY KEY,
  3     user_account_id INTEGER REFERENCES user_account(id));

Table created.

SQL&gt; SELECT constraint_name FROM all_constraints WHERE
  2     table_name=&#39;USER_ORDER&#39; AND constraint_type in (&#39;R&#39;);

CONSTRAINT_NAME
-----------------------------------------------------
SYS_C0029334
</pre></div>
</div>
<p>Oh, we can see that is.....much worse.  Oracle&#8217;s names are entirely unpredictable
alphanumeric codes, and this will make being able to write migrations
quite tedious, as we&#8217;d need to look up all these names.</p>
<p>The solution to having to look up names is to make your own names.   This is
an easy, though tedious thing to do manually.  For example, to create our model
in SQLAlchemy ensuring we use names for foreign key constraints would look like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span>

<span class="n">meta</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>

<span class="n">user_account</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s">&#39;user_account&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
              <span class="p">)</span>

<span class="n">user_order</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s">&#39;user_order&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s">&#39;user_order_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span>
                    <span class="n">ForeignKey</span><span class="p">(</span><span class="s">&#39;user_account.id&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;fk_user_order_id&#39;</span><span class="p">))</span>
              <span class="p">)</span>
</pre></div>
</div>
<p>Simple enough, though this has some disadvantages.  The first is that it&#8217;s tedious;
we need to remember to use a name for every <a class="reference external" href="http://www.sqlalchemy.org/docs/core/constraints.html#sqlalchemy.schema.ForeignKey" title="(in SQLAlchemy v0.9)"><tt class="xref py py-class docutils literal"><span class="pre">ForeignKey</span></tt></a> object,
not to mention every <a class="reference external" href="http://www.sqlalchemy.org/docs/core/constraints.html#sqlalchemy.schema.UniqueConstraint" title="(in SQLAlchemy v0.9)"><tt class="xref py py-class docutils literal"><span class="pre">UniqueConstraint</span></tt></a>, <a class="reference external" href="http://www.sqlalchemy.org/docs/core/constraints.html#sqlalchemy.schema.CheckConstraint" title="(in SQLAlchemy v0.9)"><tt class="xref py py-class docutils literal"><span class="pre">CheckConstraint</span></tt></a>,
<a class="reference external" href="http://www.sqlalchemy.org/docs/core/constraints.html#sqlalchemy.schema.Index" title="(in SQLAlchemy v0.9)"><tt class="xref py py-class docutils literal"><span class="pre">Index</span></tt></a>, and maybe even <a class="reference external" href="http://www.sqlalchemy.org/docs/core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint" title="(in SQLAlchemy v0.9)"><tt class="xref py py-class docutils literal"><span class="pre">PrimaryKeyConstraint</span></tt></a>
as well if we wish to be able to alter those too, and beyond all that, all the
names have to be globally unique.   Even with all that effort, if we have a naming scheme in mind,
it&#8217;s easy to get it wrong when doing it manually each time.</p>
<p>What&#8217;s worse is that manually naming constraints (and indexes) gets even more
tedious in that we can no longer use convenience features such as the <tt class="docutils literal"><span class="pre">.unique=True</span></tt>
or <tt class="docutils literal"><span class="pre">.index=True</span></tt> flag on <a class="reference external" href="http://www.sqlalchemy.org/docs/core/metadata.html#sqlalchemy.schema.Column" title="(in SQLAlchemy v0.9)"><tt class="xref py py-class docutils literal"><span class="pre">Column</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user_account</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s">&#39;user_account&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
              <span class="p">)</span>
</pre></div>
</div>
<p>Above, the <tt class="docutils literal"><span class="pre">unique=True</span></tt> flag creates a <a class="reference external" href="http://www.sqlalchemy.org/docs/core/constraints.html#sqlalchemy.schema.UniqueConstraint" title="(in SQLAlchemy v0.9)"><tt class="xref py py-class docutils literal"><span class="pre">UniqueConstraint</span></tt></a>, but again,
it&#8217;s not named.   If we want to name it, manually we have to forego the usage
of <tt class="docutils literal"><span class="pre">unique=True</span></tt> and type out the whole constraint:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user_account</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s">&#39;user_account&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
                  <span class="n">UniqueConstraint</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;uq_user_account_name&#39;</span><span class="p">)</span>
              <span class="p">)</span>
</pre></div>
</div>
<p>There&#8217;s a solution to all this naming work, which is to use an <strong>automated
naming convention</strong>.  For some years, SQLAlchemy has encourgaged the use of
DDL Events in order to create naming schemes.  The <a class="reference external" href="http://www.sqlalchemy.org/docs/core/events.html#sqlalchemy.events.DDLEvents.after_parent_attach" title="(in SQLAlchemy v0.9)"><tt class="xref py py-meth docutils literal"><span class="pre">after_parent_attach()</span></tt></a>
event in particular is the best place to intercept when <a class="reference external" href="http://www.sqlalchemy.org/docs/core/constraints.html#sqlalchemy.schema.Constraint" title="(in SQLAlchemy v0.9)"><tt class="xref py py-class docutils literal"><span class="pre">Constraint</span></tt></a>
and <a class="reference external" href="http://www.sqlalchemy.org/docs/core/constraints.html#sqlalchemy.schema.Index" title="(in SQLAlchemy v0.9)"><tt class="xref py py-class docutils literal"><span class="pre">Index</span></tt></a> objects are being associated with a parent
<a class="reference external" href="http://www.sqlalchemy.org/docs/core/metadata.html#sqlalchemy.schema.Table" title="(in SQLAlchemy v0.9)"><tt class="xref py py-class docutils literal"><span class="pre">Table</span></tt></a> object, and to assign a <tt class="docutils literal"><span class="pre">.name</span></tt> to the constraint while making
use of the name of the table and associated columns.</p>
<p>But there is also a better way to go, which is to make use of a feature
new in SQLAlchemy 0.9.2 which makes use of the events behind the scenes known as
<tt class="xref py py-paramref docutils literal"><span class="pre">naming_convention</span></tt>.   Here, we can
create a new <a class="reference external" href="http://www.sqlalchemy.org/docs/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v0.9)"><tt class="xref py py-class docutils literal"><span class="pre">MetaData</span></tt></a> object while passing a dictionary referring
to a naming scheme:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">convention</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">&quot;ix&quot;</span><span class="p">:</span> <span class="s">&#39;ix_</span><span class="si">%(column_0_label)s</span><span class="s">&#39;</span><span class="p">,</span>
  <span class="s">&quot;uq&quot;</span><span class="p">:</span> <span class="s">&quot;uq_</span><span class="si">%(table_name)s</span><span class="s">_</span><span class="si">%(column_0_name)s</span><span class="s">&quot;</span><span class="p">,</span>
  <span class="s">&quot;ck&quot;</span><span class="p">:</span> <span class="s">&quot;ck_</span><span class="si">%(table_name)s</span><span class="s">_</span><span class="si">%(constraint_name)s</span><span class="s">&quot;</span><span class="p">,</span>
  <span class="s">&quot;fk&quot;</span><span class="p">:</span> <span class="s">&quot;fk_</span><span class="si">%(table_name)s</span><span class="s">_</span><span class="si">%(column_0_name)s</span><span class="s">_</span><span class="si">%(referred_table_name)s</span><span class="s">&quot;</span><span class="p">,</span>
  <span class="s">&quot;pk&quot;</span><span class="p">:</span> <span class="s">&quot;pk_</span><span class="si">%(table_name)s</span><span class="s">&quot;</span>
<span class="p">}</span>

<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">naming_convention</span><span class="o">=</span><span class="n">convention</span><span class="p">)</span>
</pre></div>
</div>
<p>If we define our models using a <a class="reference external" href="http://www.sqlalchemy.org/docs/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v0.9)"><tt class="xref py py-class docutils literal"><span class="pre">MetaData</span></tt></a> as above, the given
naming convention dictionary will be used to provide names for all constraints
and indexes.</p>
<div class="section" id="integration-of-naming-conventions-into-operations-autogenerate">
<span id="autogen-naming-conventions"></span><h2>Integration of Naming Conventions into Operations, Autogenerate<a class="headerlink" href="#integration-of-naming-conventions-into-operations-autogenerate" title="Permalink to this headline">¶</a></h2>
<p>As of Alembic 0.6.4, the naming convention feature is integrated into the
<a class="reference internal" href="ops.html#alembic.operations.Operations" title="alembic.operations.Operations"><tt class="xref py py-class docutils literal"><span class="pre">Operations</span></tt></a> object, so that the convention takes effect for any
constraint that is otherwise unnamed.  The naming convention is passed to
<a class="reference internal" href="ops.html#alembic.operations.Operations" title="alembic.operations.Operations"><tt class="xref py py-class docutils literal"><span class="pre">Operations</span></tt></a> using the <tt class="xref py py-paramref docutils literal"><span class="pre">MigrationsContext.configure.target_metadata</span></tt>
parameter in <tt class="docutils literal"><span class="pre">env.py</span></tt>, which is normally configured when autogenerate is
used:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># in your application&#39;s model:</span>

<span class="n">meta</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">naming_convention</span><span class="o">=</span><span class="p">{</span>
        <span class="s">&quot;ix&quot;</span><span class="p">:</span> <span class="s">&#39;ix_</span><span class="si">%(column_0_label)s</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="s">&quot;uq&quot;</span><span class="p">:</span> <span class="s">&quot;uq_</span><span class="si">%(table_name)s</span><span class="s">_</span><span class="si">%(column_0_name)s</span><span class="s">&quot;</span><span class="p">,</span>
        <span class="s">&quot;ck&quot;</span><span class="p">:</span> <span class="s">&quot;ck_</span><span class="si">%(table_name)s</span><span class="s">_</span><span class="si">%(constraint_name)s</span><span class="s">&quot;</span><span class="p">,</span>
        <span class="s">&quot;fk&quot;</span><span class="p">:</span> <span class="s">&quot;fk_</span><span class="si">%(table_name)s</span><span class="s">_</span><span class="si">%(column_0_name)s</span><span class="s">_</span><span class="si">%(referred_table_name)s</span><span class="s">&quot;</span><span class="p">,</span>
        <span class="s">&quot;pk&quot;</span><span class="p">:</span> <span class="s">&quot;pk_</span><span class="si">%(table_name)s</span><span class="s">&quot;</span>
      <span class="p">})</span>

<span class="c"># .. in your Alembic env.py:</span>

<span class="c"># add your model&#39;s MetaData object here</span>
<span class="c"># for &#39;autogenerate&#39; support</span>
<span class="kn">from</span> <span class="nn">myapp</span> <span class="kn">import</span> <span class="n">mymodel</span>
<span class="n">target_metadata</span> <span class="o">=</span> <span class="n">mymodel</span><span class="o">.</span><span class="n">Base</span><span class="o">.</span><span class="n">metadata</span>

<span class="c"># ...</span>

<span class="k">def</span> <span class="nf">run_migrations_online</span><span class="p">():</span>

    <span class="c"># ...</span>

    <span class="n">context</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
                <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span>
                <span class="n">target_metadata</span><span class="o">=</span><span class="n">target_metadata</span>
                <span class="p">)</span>
</pre></div>
</div>
<p>Above, when we render a directive like the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">op</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="s">&#39;sometable&#39;</span><span class="p">,</span> <span class="n">Column</span><span class="p">(</span><span class="s">&#39;q&#39;</span><span class="p">,</span> <span class="n">Boolean</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;q_bool&#39;</span><span class="p">)))</span>
</pre></div>
</div>
<p>The Boolean type will render a CHECK constraint with the name
<tt class="docutils literal"><span class="pre">&quot;ck_sometable_q_bool&quot;</span></tt>, assuming the backend in use does not support
native boolean types.</p>
<p>We can also use op directives with constraints and not give them a name
at all, if the naming convention doesn&#8217;t require one.  The value of
<tt class="docutils literal"><span class="pre">None</span></tt> will be converted into a name that follows the appopriate naming
conventions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">upgrade</span><span class="p">():</span>
    <span class="n">op</span><span class="o">.</span><span class="n">create_unique_constraint</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s">&#39;some_table&#39;</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When autogenerate renders constraints in a migration script, it renders them
typically with their completed name.  If using at least Alembic 0.6.4 as well
as SQLAlchemy 0.9.4, these will be rendered with a special directive
<a class="reference internal" href="ops.html#alembic.operations.Operations.f" title="alembic.operations.Operations.f"><tt class="xref py py-meth docutils literal"><span class="pre">Operations.f()</span></tt></a> which denotes that the string has already been
tokenized:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">upgrade</span><span class="p">():</span>
    <span class="n">op</span><span class="o">.</span><span class="n">create_unique_constraint</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="s">&#39;uq_const_x&#39;</span><span class="p">),</span> <span class="s">&#39;some_table&#39;</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For more detail on the naming convention feature, see <a class="reference external" href="http://www.sqlalchemy.org/docs/core/constraints.html#constraint-naming-conventions" title="(in SQLAlchemy v0.9)"><em>Configuring Constraint Naming Conventions</em></a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The Importance of Naming Constraints</a><ul>
<li><a class="reference internal" href="#integration-of-naming-conventions-into-operations-autogenerate">Integration of Naming Conventions into Operations, Autogenerate</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="offline.html"
                        title="previous chapter">Generating SQL Scripts (a.k.a. &#8220;Offline Mode&#8221;)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="batch.html"
                        title="next chapter">Running &#8220;Batch&#8221; Migrations for SQLite and Other Databases</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/naming.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="batch.html" title="Running “Batch” Migrations for SQLite and Other Databases"
             >next</a> |</li>
        <li class="right" >
          <a href="offline.html" title="Generating SQL Scripts (a.k.a. “Offline Mode”)"
             >previous</a> |</li>
        <li><a href="index.html">Alembic 0.7.4 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010-2015, Mike Bayer.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>