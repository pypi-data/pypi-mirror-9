# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.3
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pywrapcp', [dirname(__file__)])
        except ImportError:
            import _pywrapcp
            return _pywrapcp
        if fp is not None:
            try:
                _mod = imp.load_module('_pywrapcp', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pywrapcp = swig_import_helper()
    del swig_import_helper
else:
    import _pywrapcp
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _pywrapcp.SwigPyIterator_value(self)
    def incr(self, n=1): return _pywrapcp.SwigPyIterator_incr(self, n)
    def decr(self, n=1): return _pywrapcp.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _pywrapcp.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _pywrapcp.SwigPyIterator_equal(self, *args)
    def copy(self): return _pywrapcp.SwigPyIterator_copy(self)
    def next(self): return _pywrapcp.SwigPyIterator_next(self)
    def __next__(self): return _pywrapcp.SwigPyIterator___next__(self)
    def previous(self): return _pywrapcp.SwigPyIterator_previous(self)
    def advance(self, *args): return _pywrapcp.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _pywrapcp.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _pywrapcp.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _pywrapcp.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _pywrapcp.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _pywrapcp.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _pywrapcp.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _pywrapcp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class PyDecisionBuilder(object):
  def NextWrapper(self, solver):
    try:
      return self.Next(solver)
    except Exception:
      return solver.FailDecision()

  def DebugString(self):
    return "PyDecisionBuilder"

import gflags as flags
FLAGS = flags.FLAGS
flags.DEFINE_boolean('cp_trace_propagation', False,
                      'trace all propagation events.')
flags.DEFINE_boolean('cp_trace_search', False,
                      'trace all search events.')
flags.DEFINE_boolean('cp_print_model', False,
                      'prints the model before solving it.')
flags.DEFINE_boolean('cp_model_stats', False,
                      'displays model statistics before solving it.')
flags.DEFINE_string('cp_export_file', '',
                     'exports model to file using CPModelProto.')
flags.DEFINE_boolean('cp_no_solve', False,
                      'force failures at the beginning of a search.')
flags.DEFINE_string('cp_profile_file', '',
                     'exports profiling overview to file.')

class SolverParameters(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SolverParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SolverParameters, name)
    __repr__ = _swig_repr
    NO_COMPRESSION = _pywrapcp.SolverParameters_NO_COMPRESSION
    COMPRESS_WITH_ZLIB = _pywrapcp.SolverParameters_COMPRESS_WITH_ZLIB
    NO_PROFILING = _pywrapcp.SolverParameters_NO_PROFILING
    NORMAL_PROFILING = _pywrapcp.SolverParameters_NORMAL_PROFILING
    NO_TRACE = _pywrapcp.SolverParameters_NO_TRACE
    NORMAL_TRACE = _pywrapcp.SolverParameters_NORMAL_TRACE
    def __init__(self): 
        this = _pywrapcp.new_SolverParameters()
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["compress_trail"] = _pywrapcp.SolverParameters_compress_trail_set
    __swig_getmethods__["compress_trail"] = _pywrapcp.SolverParameters_compress_trail_get
    if _newclass:compress_trail = _swig_property(_pywrapcp.SolverParameters_compress_trail_get, _pywrapcp.SolverParameters_compress_trail_set)
    __swig_setmethods__["trail_block_size"] = _pywrapcp.SolverParameters_trail_block_size_set
    __swig_getmethods__["trail_block_size"] = _pywrapcp.SolverParameters_trail_block_size_get
    if _newclass:trail_block_size = _swig_property(_pywrapcp.SolverParameters_trail_block_size_get, _pywrapcp.SolverParameters_trail_block_size_set)
    __swig_setmethods__["array_split_size"] = _pywrapcp.SolverParameters_array_split_size_set
    __swig_getmethods__["array_split_size"] = _pywrapcp.SolverParameters_array_split_size_get
    if _newclass:array_split_size = _swig_property(_pywrapcp.SolverParameters_array_split_size_get, _pywrapcp.SolverParameters_array_split_size_set)
    __swig_setmethods__["store_names"] = _pywrapcp.SolverParameters_store_names_set
    __swig_getmethods__["store_names"] = _pywrapcp.SolverParameters_store_names_get
    if _newclass:store_names = _swig_property(_pywrapcp.SolverParameters_store_names_get, _pywrapcp.SolverParameters_store_names_set)
    __swig_setmethods__["profile_level"] = _pywrapcp.SolverParameters_profile_level_set
    __swig_getmethods__["profile_level"] = _pywrapcp.SolverParameters_profile_level_get
    if _newclass:profile_level = _swig_property(_pywrapcp.SolverParameters_profile_level_get, _pywrapcp.SolverParameters_profile_level_set)
    __swig_setmethods__["trace_level"] = _pywrapcp.SolverParameters_trace_level_set
    __swig_getmethods__["trace_level"] = _pywrapcp.SolverParameters_trace_level_get
    if _newclass:trace_level = _swig_property(_pywrapcp.SolverParameters_trace_level_get, _pywrapcp.SolverParameters_trace_level_set)
    __swig_setmethods__["name_all_variables"] = _pywrapcp.SolverParameters_name_all_variables_set
    __swig_getmethods__["name_all_variables"] = _pywrapcp.SolverParameters_name_all_variables_get
    if _newclass:name_all_variables = _swig_property(_pywrapcp.SolverParameters_name_all_variables_get, _pywrapcp.SolverParameters_name_all_variables_set)
    __swig_destroy__ = _pywrapcp.delete_SolverParameters
    __del__ = lambda self : None;
SolverParameters_swigregister = _pywrapcp.SolverParameters_swigregister
SolverParameters_swigregister(SolverParameters)

class DefaultPhaseParameters(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefaultPhaseParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DefaultPhaseParameters, name)
    __repr__ = _swig_repr
    CHOOSE_MAX_SUM_IMPACT = _pywrapcp.DefaultPhaseParameters_CHOOSE_MAX_SUM_IMPACT
    CHOOSE_MAX_AVERAGE_IMPACT = _pywrapcp.DefaultPhaseParameters_CHOOSE_MAX_AVERAGE_IMPACT
    CHOOSE_MAX_VALUE_IMPACT = _pywrapcp.DefaultPhaseParameters_CHOOSE_MAX_VALUE_IMPACT
    SELECT_MIN_IMPACT = _pywrapcp.DefaultPhaseParameters_SELECT_MIN_IMPACT
    SELECT_MAX_IMPACT = _pywrapcp.DefaultPhaseParameters_SELECT_MAX_IMPACT
    NONE = _pywrapcp.DefaultPhaseParameters_NONE
    NORMAL = _pywrapcp.DefaultPhaseParameters_NORMAL
    VERBOSE = _pywrapcp.DefaultPhaseParameters_VERBOSE
    def __init__(self): 
        this = _pywrapcp.new_DefaultPhaseParameters()
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["var_selection_schema"] = _pywrapcp.DefaultPhaseParameters_var_selection_schema_set
    __swig_getmethods__["var_selection_schema"] = _pywrapcp.DefaultPhaseParameters_var_selection_schema_get
    if _newclass:var_selection_schema = _swig_property(_pywrapcp.DefaultPhaseParameters_var_selection_schema_get, _pywrapcp.DefaultPhaseParameters_var_selection_schema_set)
    __swig_setmethods__["value_selection_schema"] = _pywrapcp.DefaultPhaseParameters_value_selection_schema_set
    __swig_getmethods__["value_selection_schema"] = _pywrapcp.DefaultPhaseParameters_value_selection_schema_get
    if _newclass:value_selection_schema = _swig_property(_pywrapcp.DefaultPhaseParameters_value_selection_schema_get, _pywrapcp.DefaultPhaseParameters_value_selection_schema_set)
    __swig_setmethods__["initialization_splits"] = _pywrapcp.DefaultPhaseParameters_initialization_splits_set
    __swig_getmethods__["initialization_splits"] = _pywrapcp.DefaultPhaseParameters_initialization_splits_get
    if _newclass:initialization_splits = _swig_property(_pywrapcp.DefaultPhaseParameters_initialization_splits_get, _pywrapcp.DefaultPhaseParameters_initialization_splits_set)
    __swig_setmethods__["run_all_heuristics"] = _pywrapcp.DefaultPhaseParameters_run_all_heuristics_set
    __swig_getmethods__["run_all_heuristics"] = _pywrapcp.DefaultPhaseParameters_run_all_heuristics_get
    if _newclass:run_all_heuristics = _swig_property(_pywrapcp.DefaultPhaseParameters_run_all_heuristics_get, _pywrapcp.DefaultPhaseParameters_run_all_heuristics_set)
    __swig_setmethods__["heuristic_period"] = _pywrapcp.DefaultPhaseParameters_heuristic_period_set
    __swig_getmethods__["heuristic_period"] = _pywrapcp.DefaultPhaseParameters_heuristic_period_get
    if _newclass:heuristic_period = _swig_property(_pywrapcp.DefaultPhaseParameters_heuristic_period_get, _pywrapcp.DefaultPhaseParameters_heuristic_period_set)
    __swig_setmethods__["heuristic_num_failures_limit"] = _pywrapcp.DefaultPhaseParameters_heuristic_num_failures_limit_set
    __swig_getmethods__["heuristic_num_failures_limit"] = _pywrapcp.DefaultPhaseParameters_heuristic_num_failures_limit_get
    if _newclass:heuristic_num_failures_limit = _swig_property(_pywrapcp.DefaultPhaseParameters_heuristic_num_failures_limit_get, _pywrapcp.DefaultPhaseParameters_heuristic_num_failures_limit_set)
    __swig_setmethods__["persistent_impact"] = _pywrapcp.DefaultPhaseParameters_persistent_impact_set
    __swig_getmethods__["persistent_impact"] = _pywrapcp.DefaultPhaseParameters_persistent_impact_get
    if _newclass:persistent_impact = _swig_property(_pywrapcp.DefaultPhaseParameters_persistent_impact_get, _pywrapcp.DefaultPhaseParameters_persistent_impact_set)
    __swig_setmethods__["random_seed"] = _pywrapcp.DefaultPhaseParameters_random_seed_set
    __swig_getmethods__["random_seed"] = _pywrapcp.DefaultPhaseParameters_random_seed_get
    if _newclass:random_seed = _swig_property(_pywrapcp.DefaultPhaseParameters_random_seed_get, _pywrapcp.DefaultPhaseParameters_random_seed_set)
    __swig_setmethods__["restart_log_size"] = _pywrapcp.DefaultPhaseParameters_restart_log_size_set
    __swig_getmethods__["restart_log_size"] = _pywrapcp.DefaultPhaseParameters_restart_log_size_get
    if _newclass:restart_log_size = _swig_property(_pywrapcp.DefaultPhaseParameters_restart_log_size_get, _pywrapcp.DefaultPhaseParameters_restart_log_size_set)
    __swig_setmethods__["display_level"] = _pywrapcp.DefaultPhaseParameters_display_level_set
    __swig_getmethods__["display_level"] = _pywrapcp.DefaultPhaseParameters_display_level_get
    if _newclass:display_level = _swig_property(_pywrapcp.DefaultPhaseParameters_display_level_get, _pywrapcp.DefaultPhaseParameters_display_level_set)
    __swig_setmethods__["use_no_goods"] = _pywrapcp.DefaultPhaseParameters_use_no_goods_set
    __swig_getmethods__["use_no_goods"] = _pywrapcp.DefaultPhaseParameters_use_no_goods_get
    if _newclass:use_no_goods = _swig_property(_pywrapcp.DefaultPhaseParameters_use_no_goods_get, _pywrapcp.DefaultPhaseParameters_use_no_goods_set)
    __swig_setmethods__["decision_builder"] = _pywrapcp.DefaultPhaseParameters_decision_builder_set
    __swig_getmethods__["decision_builder"] = _pywrapcp.DefaultPhaseParameters_decision_builder_get
    if _newclass:decision_builder = _swig_property(_pywrapcp.DefaultPhaseParameters_decision_builder_get, _pywrapcp.DefaultPhaseParameters_decision_builder_set)
    __swig_destroy__ = _pywrapcp.delete_DefaultPhaseParameters
    __del__ = lambda self : None;
DefaultPhaseParameters_swigregister = _pywrapcp.DefaultPhaseParameters_swigregister
DefaultPhaseParameters_swigregister(DefaultPhaseParameters)

class Solver(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Solver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Solver, name)
    __repr__ = _swig_repr
    INT_VAR_DEFAULT = _pywrapcp.Solver_INT_VAR_DEFAULT
    INT_VAR_SIMPLE = _pywrapcp.Solver_INT_VAR_SIMPLE
    CHOOSE_FIRST_UNBOUND = _pywrapcp.Solver_CHOOSE_FIRST_UNBOUND
    CHOOSE_RANDOM = _pywrapcp.Solver_CHOOSE_RANDOM
    CHOOSE_MIN_SIZE_LOWEST_MIN = _pywrapcp.Solver_CHOOSE_MIN_SIZE_LOWEST_MIN
    CHOOSE_MIN_SIZE_HIGHEST_MIN = _pywrapcp.Solver_CHOOSE_MIN_SIZE_HIGHEST_MIN
    CHOOSE_MIN_SIZE_LOWEST_MAX = _pywrapcp.Solver_CHOOSE_MIN_SIZE_LOWEST_MAX
    CHOOSE_MIN_SIZE_HIGHEST_MAX = _pywrapcp.Solver_CHOOSE_MIN_SIZE_HIGHEST_MAX
    CHOOSE_LOWEST_MIN = _pywrapcp.Solver_CHOOSE_LOWEST_MIN
    CHOOSE_HIGHEST_MAX = _pywrapcp.Solver_CHOOSE_HIGHEST_MAX
    CHOOSE_MIN_SIZE = _pywrapcp.Solver_CHOOSE_MIN_SIZE
    CHOOSE_MAX_SIZE = _pywrapcp.Solver_CHOOSE_MAX_SIZE
    CHOOSE_MAX_REGRET_ON_MIN = _pywrapcp.Solver_CHOOSE_MAX_REGRET_ON_MIN
    CHOOSE_PATH = _pywrapcp.Solver_CHOOSE_PATH
    INT_VALUE_DEFAULT = _pywrapcp.Solver_INT_VALUE_DEFAULT
    INT_VALUE_SIMPLE = _pywrapcp.Solver_INT_VALUE_SIMPLE
    ASSIGN_MIN_VALUE = _pywrapcp.Solver_ASSIGN_MIN_VALUE
    ASSIGN_MAX_VALUE = _pywrapcp.Solver_ASSIGN_MAX_VALUE
    ASSIGN_RANDOM_VALUE = _pywrapcp.Solver_ASSIGN_RANDOM_VALUE
    ASSIGN_CENTER_VALUE = _pywrapcp.Solver_ASSIGN_CENTER_VALUE
    SPLIT_LOWER_HALF = _pywrapcp.Solver_SPLIT_LOWER_HALF
    SPLIT_UPPER_HALF = _pywrapcp.Solver_SPLIT_UPPER_HALF
    SEQUENCE_DEFAULT = _pywrapcp.Solver_SEQUENCE_DEFAULT
    SEQUENCE_SIMPLE = _pywrapcp.Solver_SEQUENCE_SIMPLE
    CHOOSE_MIN_SLACK_RANK_FORWARD = _pywrapcp.Solver_CHOOSE_MIN_SLACK_RANK_FORWARD
    CHOOSE_RANDOM_RANK_FORWARD = _pywrapcp.Solver_CHOOSE_RANDOM_RANK_FORWARD
    INTERVAL_DEFAULT = _pywrapcp.Solver_INTERVAL_DEFAULT
    INTERVAL_SIMPLE = _pywrapcp.Solver_INTERVAL_SIMPLE
    INTERVAL_SET_TIMES_FORWARD = _pywrapcp.Solver_INTERVAL_SET_TIMES_FORWARD
    INTERVAL_SET_TIMES_BACKWARD = _pywrapcp.Solver_INTERVAL_SET_TIMES_BACKWARD
    TWOOPT = _pywrapcp.Solver_TWOOPT
    OROPT = _pywrapcp.Solver_OROPT
    RELOCATE = _pywrapcp.Solver_RELOCATE
    EXCHANGE = _pywrapcp.Solver_EXCHANGE
    CROSS = _pywrapcp.Solver_CROSS
    MAKEACTIVE = _pywrapcp.Solver_MAKEACTIVE
    MAKEINACTIVE = _pywrapcp.Solver_MAKEINACTIVE
    MAKECHAININACTIVE = _pywrapcp.Solver_MAKECHAININACTIVE
    SWAPACTIVE = _pywrapcp.Solver_SWAPACTIVE
    EXTENDEDSWAPACTIVE = _pywrapcp.Solver_EXTENDEDSWAPACTIVE
    PATHLNS = _pywrapcp.Solver_PATHLNS
    FULLPATHLNS = _pywrapcp.Solver_FULLPATHLNS
    UNACTIVELNS = _pywrapcp.Solver_UNACTIVELNS
    INCREMENT = _pywrapcp.Solver_INCREMENT
    DECREMENT = _pywrapcp.Solver_DECREMENT
    SIMPLELNS = _pywrapcp.Solver_SIMPLELNS
    GE = _pywrapcp.Solver_GE
    LE = _pywrapcp.Solver_LE
    EQ = _pywrapcp.Solver_EQ
    SUM = _pywrapcp.Solver_SUM
    PROD = _pywrapcp.Solver_PROD
    MAX = _pywrapcp.Solver_MAX
    MIN = _pywrapcp.Solver_MIN
    def __init__(self, *args): 
        this = _pywrapcp.new_Solver(*args)
        try: self.this.append(this)
        except: self.this = this
        Solver.SetFlags(FLAGS.cp_trace_propagation,
                        FLAGS.cp_trace_search,
                        FLAGS.cp_print_model,
                        FLAGS.cp_model_stats,
                        FLAGS.cp_export_file,
                        FLAGS.cp_no_solve,
                        FLAGS.cp_profile_file)



    __swig_destroy__ = _pywrapcp.delete_Solver
    __del__ = lambda self : None;
    def Add(self, *args): return _pywrapcp.Solver_Add(self, *args)
    def Solve(self, *args): return _pywrapcp.Solver_Solve(self, *args)
    def NewSearch(self, *args): return _pywrapcp.Solver_NewSearch(self, *args)
    def NextSolution(self): return _pywrapcp.Solver_NextSolution(self)
    def RestartSearch(self): return _pywrapcp.Solver_RestartSearch(self)
    def EndSearch(self): return _pywrapcp.Solver_EndSearch(self)
    def SolveAndCommit(self, *args): return _pywrapcp.Solver_SolveAndCommit(self, *args)
    def CheckAssignment(self, *args): return _pywrapcp.Solver_CheckAssignment(self, *args)
    def CheckConstraint(self, *args): return _pywrapcp.Solver_CheckConstraint(self, *args)
    def Fail(self): return _pywrapcp.Solver_Fail(self)
    __swig_getmethods__["MemoryUsage"] = lambda x: _pywrapcp.Solver_MemoryUsage
    if _newclass:MemoryUsage = staticmethod(_pywrapcp.Solver_MemoryUsage)
    def WallTime(self): return _pywrapcp.Solver_WallTime(self)
    def Branches(self): return _pywrapcp.Solver_Branches(self)
    def Solutions(self): return _pywrapcp.Solver_Solutions(self)
    def Failures(self): return _pywrapcp.Solver_Failures(self)
    def AcceptedNeighbors(self): return _pywrapcp.Solver_AcceptedNeighbors(self)
    def Stamp(self): return _pywrapcp.Solver_Stamp(self)
    def FailStamp(self): return _pywrapcp.Solver_FailStamp(self)
    def IntVar(self, *args): return _pywrapcp.Solver_IntVar(self, *args)
    def BoolVar(self, *args): return _pywrapcp.Solver_BoolVar(self, *args)
    def IntConst(self, *args): return _pywrapcp.Solver_IntConst(self, *args)
    def Sum(self, *args): return _pywrapcp.Solver_Sum(self, *args)
    def ScalProd(self, *args): return _pywrapcp.Solver_ScalProd(self, *args)
    def MonotonicElement(self, *args): return _pywrapcp.Solver_MonotonicElement(self, *args)
    def Element(self, *args): return _pywrapcp.Solver_Element(self, *args)
    def IndexExpression(self, *args): return _pywrapcp.Solver_IndexExpression(self, *args)
    def Min(self, *args): return _pywrapcp.Solver_Min(self, *args)
    def Max(self, *args): return _pywrapcp.Solver_Max(self, *args)
    def ConvexPiecewiseExpr(self, *args): return _pywrapcp.Solver_ConvexPiecewiseExpr(self, *args)
    def SemiContinuousExpr(self, *args): return _pywrapcp.Solver_SemiContinuousExpr(self, *args)
    def ConditionalExpression(self, *args): return _pywrapcp.Solver_ConditionalExpression(self, *args)
    def TrueConstraint(self): return _pywrapcp.Solver_TrueConstraint(self)
    def FalseConstraint(self, *args): return _pywrapcp.Solver_FalseConstraint(self, *args)
    def IsEqualCstCt(self, *args): return _pywrapcp.Solver_IsEqualCstCt(self, *args)
    def IsEqualCstVar(self, *args): return _pywrapcp.Solver_IsEqualCstVar(self, *args)
    def IsEqualCt(self, *args): return _pywrapcp.Solver_IsEqualCt(self, *args)
    def IsEqualVar(self, *args): return _pywrapcp.Solver_IsEqualVar(self, *args)
    def IsDifferentCstCt(self, *args): return _pywrapcp.Solver_IsDifferentCstCt(self, *args)
    def IsDifferentCstVar(self, *args): return _pywrapcp.Solver_IsDifferentCstVar(self, *args)
    def IsDifferentVar(self, *args): return _pywrapcp.Solver_IsDifferentVar(self, *args)
    def IsDifferentCt(self, *args): return _pywrapcp.Solver_IsDifferentCt(self, *args)
    def IsLessOrEqualCstCt(self, *args): return _pywrapcp.Solver_IsLessOrEqualCstCt(self, *args)
    def IsLessOrEqualCstVar(self, *args): return _pywrapcp.Solver_IsLessOrEqualCstVar(self, *args)
    def IsLessOrEqualVar(self, *args): return _pywrapcp.Solver_IsLessOrEqualVar(self, *args)
    def IsLessOrEqualCt(self, *args): return _pywrapcp.Solver_IsLessOrEqualCt(self, *args)
    def IsGreaterOrEqualCstCt(self, *args): return _pywrapcp.Solver_IsGreaterOrEqualCstCt(self, *args)
    def IsGreaterOrEqualCstVar(self, *args): return _pywrapcp.Solver_IsGreaterOrEqualCstVar(self, *args)
    def IsGreaterOrEqualVar(self, *args): return _pywrapcp.Solver_IsGreaterOrEqualVar(self, *args)
    def IsGreaterOrEqualCt(self, *args): return _pywrapcp.Solver_IsGreaterOrEqualCt(self, *args)
    def IsGreaterCstCt(self, *args): return _pywrapcp.Solver_IsGreaterCstCt(self, *args)
    def IsGreaterCstVar(self, *args): return _pywrapcp.Solver_IsGreaterCstVar(self, *args)
    def IsGreaterVar(self, *args): return _pywrapcp.Solver_IsGreaterVar(self, *args)
    def IsGreaterCt(self, *args): return _pywrapcp.Solver_IsGreaterCt(self, *args)
    def IsLessCstCt(self, *args): return _pywrapcp.Solver_IsLessCstCt(self, *args)
    def IsLessCstVar(self, *args): return _pywrapcp.Solver_IsLessCstVar(self, *args)
    def IsLessVar(self, *args): return _pywrapcp.Solver_IsLessVar(self, *args)
    def IsLessCt(self, *args): return _pywrapcp.Solver_IsLessCt(self, *args)
    def SumLessOrEqual(self, *args): return _pywrapcp.Solver_SumLessOrEqual(self, *args)
    def SumGreaterOrEqual(self, *args): return _pywrapcp.Solver_SumGreaterOrEqual(self, *args)
    def SumEquality(self, *args): return _pywrapcp.Solver_SumEquality(self, *args)
    def ScalProdEquality(self, *args): return _pywrapcp.Solver_ScalProdEquality(self, *args)
    def ScalProdGreaterOrEqual(self, *args): return _pywrapcp.Solver_ScalProdGreaterOrEqual(self, *args)
    def ScalProdLessOrEqual(self, *args): return _pywrapcp.Solver_ScalProdLessOrEqual(self, *args)
    def MinEquality(self, *args): return _pywrapcp.Solver_MinEquality(self, *args)
    def MaxEquality(self, *args): return _pywrapcp.Solver_MaxEquality(self, *args)
    def ElementEquality(self, *args): return _pywrapcp.Solver_ElementEquality(self, *args)
    def AbsEquality(self, *args): return _pywrapcp.Solver_AbsEquality(self, *args)
    def IndexOfConstraint(self, *args): return _pywrapcp.Solver_IndexOfConstraint(self, *args)
    def ConstraintInitialPropagateCallback(self, *args): return _pywrapcp.Solver_ConstraintInitialPropagateCallback(self, *args)
    def DelayedConstraintInitialPropagateCallback(self, *args): return _pywrapcp.Solver_DelayedConstraintInitialPropagateCallback(self, *args)
    def BetweenCt(self, *args): return _pywrapcp.Solver_BetweenCt(self, *args)
    def IsBetweenCt(self, *args): return _pywrapcp.Solver_IsBetweenCt(self, *args)
    def IsBetweenVar(self, *args): return _pywrapcp.Solver_IsBetweenVar(self, *args)
    def IsMemberCt(self, *args): return _pywrapcp.Solver_IsMemberCt(self, *args)
    def IsMemberVar(self, *args): return _pywrapcp.Solver_IsMemberVar(self, *args)
    def MemberCt(self, *args): return _pywrapcp.Solver_MemberCt(self, *args)
    def Count(self, *args): return _pywrapcp.Solver_Count(self, *args)
    def Distribute(self, *args): return _pywrapcp.Solver_Distribute(self, *args)
    def Deviation(self, *args): return _pywrapcp.Solver_Deviation(self, *args)
    def AllDifferent(self, *args): return _pywrapcp.Solver_AllDifferent(self, *args)
    def AllDifferentExcept(self, *args): return _pywrapcp.Solver_AllDifferentExcept(self, *args)
    def SortingConstraint(self, *args): return _pywrapcp.Solver_SortingConstraint(self, *args)
    def LexicalLess(self, *args): return _pywrapcp.Solver_LexicalLess(self, *args)
    def LexicalLessOrEqual(self, *args): return _pywrapcp.Solver_LexicalLessOrEqual(self, *args)
    def InversePermutationConstraint(self, *args): return _pywrapcp.Solver_InversePermutationConstraint(self, *args)
    def NullIntersect(self, *args): return _pywrapcp.Solver_NullIntersect(self, *args)
    def NullIntersectExcept(self, *args): return _pywrapcp.Solver_NullIntersectExcept(self, *args)
    def Circuit(self, *args): return _pywrapcp.Solver_Circuit(self, *args)
    def SubCircuit(self, *args): return _pywrapcp.Solver_SubCircuit(self, *args)
    def DelayedPathCumul(self, *args): return _pywrapcp.Solver_DelayedPathCumul(self, *args)
    def PathCumul(self, *args): return _pywrapcp.Solver_PathCumul(self, *args)
    def AllowedAssignments(self, *args): return _pywrapcp.Solver_AllowedAssignments(self, *args)
    def TransitionConstraint(self, *args): return _pywrapcp.Solver_TransitionConstraint(self, *args)
    def NonOverlappingBoxesConstraint(self, *args): return _pywrapcp.Solver_NonOverlappingBoxesConstraint(self, *args)
    def Pack(self, *args): return _pywrapcp.Solver_Pack(self, *args)
    def FixedDurationIntervalVar(self, *args): return _pywrapcp.Solver_FixedDurationIntervalVar(self, *args)
    def FixedInterval(self, *args): return _pywrapcp.Solver_FixedInterval(self, *args)
    def MirrorInterval(self, *args): return _pywrapcp.Solver_MirrorInterval(self, *args)
    def FixedDurationStartSyncedOnStartIntervalVar(self, *args): return _pywrapcp.Solver_FixedDurationStartSyncedOnStartIntervalVar(self, *args)
    def FixedDurationEndSyncedOnEndIntervalVar(self, *args): return _pywrapcp.Solver_FixedDurationEndSyncedOnEndIntervalVar(self, *args)
    def IntervalRelaxedMin(self, *args): return _pywrapcp.Solver_IntervalRelaxedMin(self, *args)
    def IntervalRelaxedMax(self, *args): return _pywrapcp.Solver_IntervalRelaxedMax(self, *args)
    def TemporalDisjunction(self, *args): return _pywrapcp.Solver_TemporalDisjunction(self, *args)
    def DisjunctiveConstraint(self, *args): return _pywrapcp.Solver_DisjunctiveConstraint(self, *args)
    def Cumulative(self, *args): return _pywrapcp.Solver_Cumulative(self, *args)
    def Cover(self, *args): return _pywrapcp.Solver_Cover(self, *args)
    def Assignment(self, *args): return _pywrapcp.Solver_Assignment(self, *args)
    def FirstSolutionCollector(self, *args): return _pywrapcp.Solver_FirstSolutionCollector(self, *args)
    def LastSolutionCollector(self, *args): return _pywrapcp.Solver_LastSolutionCollector(self, *args)
    def BestValueSolutionCollector(self, *args): return _pywrapcp.Solver_BestValueSolutionCollector(self, *args)
    def AllSolutionCollector(self, *args): return _pywrapcp.Solver_AllSolutionCollector(self, *args)
    def Minimize(self, *args): return _pywrapcp.Solver_Minimize(self, *args)
    def Maximize(self, *args): return _pywrapcp.Solver_Maximize(self, *args)
    def Optimize(self, *args): return _pywrapcp.Solver_Optimize(self, *args)
    def WeightedMinimize(self, *args): return _pywrapcp.Solver_WeightedMinimize(self, *args)
    def WeightedMaximize(self, *args): return _pywrapcp.Solver_WeightedMaximize(self, *args)
    def WeightedOptimize(self, *args): return _pywrapcp.Solver_WeightedOptimize(self, *args)
    def TabuSearch(self, *args): return _pywrapcp.Solver_TabuSearch(self, *args)
    def SimulatedAnnealing(self, *args): return _pywrapcp.Solver_SimulatedAnnealing(self, *args)
    def LubyRestart(self, *args): return _pywrapcp.Solver_LubyRestart(self, *args)
    def ConstantRestart(self, *args): return _pywrapcp.Solver_ConstantRestart(self, *args)
    def TimeLimit(self, *args): return _pywrapcp.Solver_TimeLimit(self, *args)
    def BranchesLimit(self, *args): return _pywrapcp.Solver_BranchesLimit(self, *args)
    def FailuresLimit(self, *args): return _pywrapcp.Solver_FailuresLimit(self, *args)
    def SolutionsLimit(self, *args): return _pywrapcp.Solver_SolutionsLimit(self, *args)
    def Limit(self, *args): return _pywrapcp.Solver_Limit(self, *args)
    def CustomLimit(self, *args): return _pywrapcp.Solver_CustomLimit(self, *args)
    def SearchLog(self, *args): return _pywrapcp.Solver_SearchLog(self, *args)
    def SearchTrace(self, *args): return _pywrapcp.Solver_SearchTrace(self, *args)
    def PrintModelVisitor(self): return _pywrapcp.Solver_PrintModelVisitor(self)
    def StatisticsModelVisitor(self): return _pywrapcp.Solver_StatisticsModelVisitor(self)
    def AssignVariableValue(self, *args): return _pywrapcp.Solver_AssignVariableValue(self, *args)
    def VariableLessOrEqualValue(self, *args): return _pywrapcp.Solver_VariableLessOrEqualValue(self, *args)
    def VariableGreaterOrEqualValue(self, *args): return _pywrapcp.Solver_VariableGreaterOrEqualValue(self, *args)
    def SplitVariableDomain(self, *args): return _pywrapcp.Solver_SplitVariableDomain(self, *args)
    def AssignVariableValueOrFail(self, *args): return _pywrapcp.Solver_AssignVariableValueOrFail(self, *args)
    def AssignVariablesValues(self, *args): return _pywrapcp.Solver_AssignVariablesValues(self, *args)
    def FailDecision(self): return _pywrapcp.Solver_FailDecision(self)
    def Compose(self, *args): return _pywrapcp.Solver_Compose(self, *args)
    def Try(self, *args): return _pywrapcp.Solver_Try(self, *args)
    def DefaultPhase(self, *args): return _pywrapcp.Solver_DefaultPhase(self, *args)
    def ScheduleOrPostpone(self, *args): return _pywrapcp.Solver_ScheduleOrPostpone(self, *args)
    def ScheduleOrExpedite(self, *args): return _pywrapcp.Solver_ScheduleOrExpedite(self, *args)
    def RankFirstInterval(self, *args): return _pywrapcp.Solver_RankFirstInterval(self, *args)
    def RankLastInterval(self, *args): return _pywrapcp.Solver_RankLastInterval(self, *args)
    def Phase(self, *args): return _pywrapcp.Solver_Phase(self, *args)
    def DecisionBuilderFromAssignment(self, *args): return _pywrapcp.Solver_DecisionBuilderFromAssignment(self, *args)
    def ConstraintAdder(self, *args): return _pywrapcp.Solver_ConstraintAdder(self, *args)
    def SolveOnce(self, *args): return _pywrapcp.Solver_SolveOnce(self, *args)
    def NestedOptimize(self, *args): return _pywrapcp.Solver_NestedOptimize(self, *args)
    def RestoreAssignment(self, *args): return _pywrapcp.Solver_RestoreAssignment(self, *args)
    def StoreAssignment(self, *args): return _pywrapcp.Solver_StoreAssignment(self, *args)
    def Operator(self, *args): return _pywrapcp.Solver_Operator(self, *args)
    def RandomLNSOperator(self, *args): return _pywrapcp.Solver_RandomLNSOperator(self, *args)
    def MoveTowardTargetOperator(self, *args): return _pywrapcp.Solver_MoveTowardTargetOperator(self, *args)
    def ConcatenateOperators(self, *args): return _pywrapcp.Solver_ConcatenateOperators(self, *args)
    def RandomConcatenateOperators(self, *args): return _pywrapcp.Solver_RandomConcatenateOperators(self, *args)
    def NeighborhoodLimit(self, *args): return _pywrapcp.Solver_NeighborhoodLimit(self, *args)
    def LocalSearchPhase(self, *args): return _pywrapcp.Solver_LocalSearchPhase(self, *args)
    def LocalSearchPhaseParameters(self, *args): return _pywrapcp.Solver_LocalSearchPhaseParameters(self, *args)
    def SearchDepth(self): return _pywrapcp.Solver_SearchDepth(self)
    def SearchLeftDepth(self): return _pywrapcp.Solver_SearchLeftDepth(self)
    def SolveDepth(self): return _pywrapcp.Solver_SolveDepth(self)
    def Constraints(self): return _pywrapcp.Solver_Constraints(self)
    def Accept(self, *args): return _pywrapcp.Solver_Accept(self, *args)
    def FinishCurrentSearch(self): return _pywrapcp.Solver_FinishCurrentSearch(self)
    def RestartCurrentSearch(self): return _pywrapcp.Solver_RestartCurrentSearch(self)
    def ShouldFail(self): return _pywrapcp.Solver_ShouldFail(self)
    def __str__(self): return _pywrapcp.Solver___str__(self)
    def TreeNoCycle(self, *args): return _pywrapcp.Solver_TreeNoCycle(self, *args)
    def SearchLogWithCallback(self, *args): return _pywrapcp.Solver_SearchLogWithCallback(self, *args)
    def ElementFunction(self, *args): return _pywrapcp.Solver_ElementFunction(self, *args)
    def LNSOperator(self, *args): return _pywrapcp.Solver_LNSOperator(self, *args)
    def LNSNoValuesOperator(self, *args): return _pywrapcp.Solver_LNSNoValuesOperator(self, *args)
    def VarEvalValStrPhase(self, *args): return _pywrapcp.Solver_VarEvalValStrPhase(self, *args)
    def VarStrValEvalPhase(self, *args): return _pywrapcp.Solver_VarStrValEvalPhase(self, *args)
    def VarEvalValEvalPhase(self, *args): return _pywrapcp.Solver_VarEvalValEvalPhase(self, *args)
    def VarStrValEvalTieBreakPhase(self, *args): return _pywrapcp.Solver_VarStrValEvalTieBreakPhase(self, *args)
    def VarEvalValEvalTieBreakPhase(self, *args): return _pywrapcp.Solver_VarEvalValEvalTieBreakPhase(self, *args)
    def EvalEvalStrPhase(self, *args): return _pywrapcp.Solver_EvalEvalStrPhase(self, *args)
    def EvalEvalStrTieBreakPhase(self, *args): return _pywrapcp.Solver_EvalEvalStrTieBreakPhase(self, *args)
    def GuidedLocalSearch(self, *args): return _pywrapcp.Solver_GuidedLocalSearch(self, *args)
    def LocalSearchObjectiveFilter(self, *args): return _pywrapcp.Solver_LocalSearchObjectiveFilter(self, *args)
    __swig_getmethods__["SetFlags"] = lambda x: _pywrapcp.Solver_SetFlags
    if _newclass:SetFlags = staticmethod(_pywrapcp.Solver_SetFlags)
Solver_swigregister = _pywrapcp.Solver_swigregister
Solver_swigregister(Solver)

def Solver_MemoryUsage():
  return _pywrapcp.Solver_MemoryUsage()
Solver_MemoryUsage = _pywrapcp.Solver_MemoryUsage

def Solver_SetFlags(*args):
  return _pywrapcp.Solver_SetFlags(*args)
Solver_SetFlags = _pywrapcp.Solver_SetFlags

class PropagationBaseObject(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PropagationBaseObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PropagationBaseObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def solver(self): return _pywrapcp.PropagationBaseObject_solver(self)
    def Name(self): return _pywrapcp.PropagationBaseObject_Name(self)
PropagationBaseObject_swigregister = _pywrapcp.PropagationBaseObject_swigregister
PropagationBaseObject_swigregister(PropagationBaseObject)

class Decision(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Decision, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Decision, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _pywrapcp.delete_Decision
    __del__ = lambda self : None;
    def Apply(self, *args): return _pywrapcp.Decision_Apply(self, *args)
    def Refute(self, *args): return _pywrapcp.Decision_Refute(self, *args)
    def __repr__(self): return _pywrapcp.Decision___repr__(self)
Decision_swigregister = _pywrapcp.Decision_swigregister
Decision_swigregister(Decision)

class DecisionBuilder(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecisionBuilder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DecisionBuilder, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _pywrapcp.delete_DecisionBuilder
    __del__ = lambda self : None;
    def Next(self, *args): return _pywrapcp.DecisionBuilder_Next(self, *args)
    def __repr__(self): return _pywrapcp.DecisionBuilder___repr__(self)
DecisionBuilder_swigregister = _pywrapcp.DecisionBuilder_swigregister
DecisionBuilder_swigregister(DecisionBuilder)

class Demon(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Demon, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Demon, name)
    __repr__ = _swig_repr
    def __init__(self): 
        if self.__class__ == Demon:
            _self = None
        else:
            _self = self
        this = _pywrapcp.new_Demon(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pywrapcp.delete_Demon
    __del__ = lambda self : None;
    def RunWrapper(self, *args): return _pywrapcp.Demon_RunWrapper(self, *args)
    def Inhibit(self, *args): return _pywrapcp.Demon_Inhibit(self, *args)
    def Desinhibit(self, *args): return _pywrapcp.Demon_Desinhibit(self, *args)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_Demon(self)
        return weakref_proxy(self)
Demon_swigregister = _pywrapcp.Demon_swigregister
Demon_swigregister(Demon)

class Constraint(PropagationBaseObject):
    __swig_setmethods__ = {}
    for _s in [PropagationBaseObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Constraint, name, value)
    __swig_getmethods__ = {}
    for _s in [PropagationBaseObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Constraint, name)
    def __init__(self, *args): 
        if self.__class__ == Constraint:
            _self = None
        else:
            _self = self
        this = _pywrapcp.new_Constraint(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pywrapcp.delete_Constraint
    __del__ = lambda self : None;
    def Post(self): return _pywrapcp.Constraint_Post(self)
    def InitialPropagateWrapper(self): return _pywrapcp.Constraint_InitialPropagateWrapper(self)
    def Var(self): return _pywrapcp.Constraint_Var(self)
    def __repr__(self): return _pywrapcp.Constraint___repr__(self)
    def __add__(self, *args): return _pywrapcp.Constraint___add__(self, *args)
    def __radd__(self, *args): return _pywrapcp.Constraint___radd__(self, *args)
    def __sub__(self, *args): return _pywrapcp.Constraint___sub__(self, *args)
    def __rsub__(self, *args): return _pywrapcp.Constraint___rsub__(self, *args)
    def __mul__(self, *args): return _pywrapcp.Constraint___mul__(self, *args)
    def __rmul__(self, *args): return _pywrapcp.Constraint___rmul__(self, *args)
    def __floordiv__(self, *args): return _pywrapcp.Constraint___floordiv__(self, *args)
    def __neg__(self): return _pywrapcp.Constraint___neg__(self)
    def __abs__(self): return _pywrapcp.Constraint___abs__(self)
    def Square(self): return _pywrapcp.Constraint_Square(self)
    def __eq__(self, *args): return _pywrapcp.Constraint___eq__(self, *args)
    def __ne__(self, *args): return _pywrapcp.Constraint___ne__(self, *args)
    def __ge__(self, *args): return _pywrapcp.Constraint___ge__(self, *args)
    def __gt__(self, *args): return _pywrapcp.Constraint___gt__(self, *args)
    def __le__(self, *args): return _pywrapcp.Constraint___le__(self, *args)
    def __lt__(self, *args): return _pywrapcp.Constraint___lt__(self, *args)
    def MapTo(self, *args): return _pywrapcp.Constraint_MapTo(self, *args)
    def IndexOf(self, *args): return _pywrapcp.Constraint_IndexOf(self, *args)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_Constraint(self)
        return weakref_proxy(self)
Constraint_swigregister = _pywrapcp.Constraint_swigregister
Constraint_swigregister(Constraint)

class SearchMonitor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SearchMonitor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SearchMonitor, name)
    def __init__(self, *args): 
        if self.__class__ == SearchMonitor:
            _self = None
        else:
            _self = self
        this = _pywrapcp.new_SearchMonitor(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pywrapcp.delete_SearchMonitor
    __del__ = lambda self : None;
    def EnterSearch(self): return _pywrapcp.SearchMonitor_EnterSearch(self)
    def RestartSearch(self): return _pywrapcp.SearchMonitor_RestartSearch(self)
    def ExitSearch(self): return _pywrapcp.SearchMonitor_ExitSearch(self)
    def BeginNextDecision(self, *args): return _pywrapcp.SearchMonitor_BeginNextDecision(self, *args)
    def EndNextDecision(self, *args): return _pywrapcp.SearchMonitor_EndNextDecision(self, *args)
    def ApplyDecision(self, *args): return _pywrapcp.SearchMonitor_ApplyDecision(self, *args)
    def RefuteDecision(self, *args): return _pywrapcp.SearchMonitor_RefuteDecision(self, *args)
    def AfterDecision(self, *args): return _pywrapcp.SearchMonitor_AfterDecision(self, *args)
    def BeginFail(self): return _pywrapcp.SearchMonitor_BeginFail(self)
    def EndFail(self): return _pywrapcp.SearchMonitor_EndFail(self)
    def BeginInitialPropagation(self): return _pywrapcp.SearchMonitor_BeginInitialPropagation(self)
    def EndInitialPropagation(self): return _pywrapcp.SearchMonitor_EndInitialPropagation(self)
    def AcceptSolution(self): return _pywrapcp.SearchMonitor_AcceptSolution(self)
    def AtSolution(self): return _pywrapcp.SearchMonitor_AtSolution(self)
    def NoMoreSolutions(self): return _pywrapcp.SearchMonitor_NoMoreSolutions(self)
    def LocalOptimum(self): return _pywrapcp.SearchMonitor_LocalOptimum(self)
    def AcceptDelta(self, *args): return _pywrapcp.SearchMonitor_AcceptDelta(self, *args)
    def AcceptNeighbor(self): return _pywrapcp.SearchMonitor_AcceptNeighbor(self)
    def solver(self): return _pywrapcp.SearchMonitor_solver(self)
    def __repr__(self): return _pywrapcp.SearchMonitor___repr__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_SearchMonitor(self)
        return weakref_proxy(self)
SearchMonitor_swigregister = _pywrapcp.SearchMonitor_swigregister
SearchMonitor_swigregister(SearchMonitor)

class IntExpr(PropagationBaseObject):
    __swig_setmethods__ = {}
    for _s in [PropagationBaseObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntExpr, name, value)
    __swig_getmethods__ = {}
    for _s in [PropagationBaseObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntExpr, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    def Min(self): return _pywrapcp.IntExpr_Min(self)
    def SetMin(self, *args): return _pywrapcp.IntExpr_SetMin(self, *args)
    def Max(self): return _pywrapcp.IntExpr_Max(self)
    def SetMax(self, *args): return _pywrapcp.IntExpr_SetMax(self, *args)
    def SetRange(self, *args): return _pywrapcp.IntExpr_SetRange(self, *args)
    def SetValue(self, *args): return _pywrapcp.IntExpr_SetValue(self, *args)
    def Bound(self): return _pywrapcp.IntExpr_Bound(self)
    def IsVar(self): return _pywrapcp.IntExpr_IsVar(self)
    def Var(self): return _pywrapcp.IntExpr_Var(self)
    def VarWithName(self, *args): return _pywrapcp.IntExpr_VarWithName(self, *args)
    def WhenRange(self, *args): return _pywrapcp.IntExpr_WhenRange(self, *args)
    def __repr__(self): return _pywrapcp.IntExpr___repr__(self)
    def __add__(self, *args): return _pywrapcp.IntExpr___add__(self, *args)
    def __radd__(self, *args): return _pywrapcp.IntExpr___radd__(self, *args)
    def __sub__(self, *args): return _pywrapcp.IntExpr___sub__(self, *args)
    def __rsub__(self, *args): return _pywrapcp.IntExpr___rsub__(self, *args)
    def __mul__(self, *args): return _pywrapcp.IntExpr___mul__(self, *args)
    def __rmul__(self, *args): return _pywrapcp.IntExpr___rmul__(self, *args)
    def __floordiv__(self, *args): return _pywrapcp.IntExpr___floordiv__(self, *args)
    def __mod__(self, *args): return _pywrapcp.IntExpr___mod__(self, *args)
    def __neg__(self): return _pywrapcp.IntExpr___neg__(self)
    def __abs__(self): return _pywrapcp.IntExpr___abs__(self)
    def Square(self): return _pywrapcp.IntExpr_Square(self)
    def __eq__(self, *args): return _pywrapcp.IntExpr___eq__(self, *args)
    def __ne__(self, *args): return _pywrapcp.IntExpr___ne__(self, *args)
    def __ge__(self, *args): return _pywrapcp.IntExpr___ge__(self, *args)
    def __gt__(self, *args): return _pywrapcp.IntExpr___gt__(self, *args)
    def __le__(self, *args): return _pywrapcp.IntExpr___le__(self, *args)
    def __lt__(self, *args): return _pywrapcp.IntExpr___lt__(self, *args)
    def MapTo(self, *args): return _pywrapcp.IntExpr_MapTo(self, *args)
    def IndexOf(self, *args): return _pywrapcp.IntExpr_IndexOf(self, *args)
    def IsMember(self, *args): return _pywrapcp.IntExpr_IsMember(self, *args)
    def Member(self, *args): return _pywrapcp.IntExpr_Member(self, *args)
IntExpr_swigregister = _pywrapcp.IntExpr_swigregister
IntExpr_swigregister(IntExpr)

class IntVarIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVarIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVarIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def Init(self): return _pywrapcp.IntVarIterator_Init(self)
    def Ok(self): return _pywrapcp.IntVarIterator_Ok(self)
    def Value(self): return _pywrapcp.IntVarIterator_Value(self)
    def Next(self): return _pywrapcp.IntVarIterator_Next(self)
    def __iter__(self):
      self.Init()
      return self

    def next(self):
      if self.Ok():
        result = self.Value()
        self.Next()
        return result
      else:
        raise StopIteration()

IntVarIterator_swigregister = _pywrapcp.IntVarIterator_swigregister
IntVarIterator_swigregister(IntVarIterator)

class IntVar(IntExpr):
    __swig_setmethods__ = {}
    for _s in [IntExpr]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVar, name, value)
    __swig_getmethods__ = {}
    for _s in [IntExpr]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntVar, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    def IsVar(self): return _pywrapcp.IntVar_IsVar(self)
    def Var(self): return _pywrapcp.IntVar_Var(self)
    def Value(self): return _pywrapcp.IntVar_Value(self)
    def RemoveValue(self, *args): return _pywrapcp.IntVar_RemoveValue(self, *args)
    def RemoveInterval(self, *args): return _pywrapcp.IntVar_RemoveInterval(self, *args)
    def RemoveValues(self, *args): return _pywrapcp.IntVar_RemoveValues(self, *args)
    def SetValues(self, *args): return _pywrapcp.IntVar_SetValues(self, *args)
    def WhenBound(self, *args): return _pywrapcp.IntVar_WhenBound(self, *args)
    def WhenDomain(self, *args): return _pywrapcp.IntVar_WhenDomain(self, *args)
    def Size(self): return _pywrapcp.IntVar_Size(self)
    def Contains(self, *args): return _pywrapcp.IntVar_Contains(self, *args)
    def HoleIteratorAux(self, *args): return _pywrapcp.IntVar_HoleIteratorAux(self, *args)
    def DomainIteratorAux(self, *args): return _pywrapcp.IntVar_DomainIteratorAux(self, *args)
    def OldMin(self): return _pywrapcp.IntVar_OldMin(self)
    def OldMax(self): return _pywrapcp.IntVar_OldMax(self)
    def __repr__(self): return _pywrapcp.IntVar___repr__(self)
    def DomainIterator(self):
      return iter(self.DomainIteratorAux(False))

    def HoleIterator(self):
      return iter(self.HoleIteratorAux(False))

IntVar_swigregister = _pywrapcp.IntVar_swigregister
IntVar_swigregister(IntVar)

class SolutionCollector(SearchMonitor):
    __swig_setmethods__ = {}
    for _s in [SearchMonitor]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SolutionCollector, name, value)
    __swig_getmethods__ = {}
    for _s in [SearchMonitor]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SolutionCollector, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Add(self, *args): return _pywrapcp.SolutionCollector_Add(self, *args)
    def AddObjective(self, *args): return _pywrapcp.SolutionCollector_AddObjective(self, *args)
    def EnterSearch(self): return _pywrapcp.SolutionCollector_EnterSearch(self)
    def SolutionCount(self): return _pywrapcp.SolutionCollector_SolutionCount(self)
    def Solution(self, *args): return _pywrapcp.SolutionCollector_Solution(self, *args)
    def WallTime(self, *args): return _pywrapcp.SolutionCollector_WallTime(self, *args)
    def Branches(self, *args): return _pywrapcp.SolutionCollector_Branches(self, *args)
    def Failures(self, *args): return _pywrapcp.SolutionCollector_Failures(self, *args)
    def ObjectiveValue(self, *args): return _pywrapcp.SolutionCollector_ObjectiveValue(self, *args)
    def Value(self, *args): return _pywrapcp.SolutionCollector_Value(self, *args)
    def StartValue(self, *args): return _pywrapcp.SolutionCollector_StartValue(self, *args)
    def EndValue(self, *args): return _pywrapcp.SolutionCollector_EndValue(self, *args)
    def DurationValue(self, *args): return _pywrapcp.SolutionCollector_DurationValue(self, *args)
    def PerformedValue(self, *args): return _pywrapcp.SolutionCollector_PerformedValue(self, *args)
    def ForwardSequence(self, *args): return _pywrapcp.SolutionCollector_ForwardSequence(self, *args)
    def BackwardSequence(self, *args): return _pywrapcp.SolutionCollector_BackwardSequence(self, *args)
    def Unperformed(self, *args): return _pywrapcp.SolutionCollector_Unperformed(self, *args)
SolutionCollector_swigregister = _pywrapcp.SolutionCollector_swigregister
SolutionCollector_swigregister(SolutionCollector)

class OptimizeVar(SearchMonitor):
    __swig_setmethods__ = {}
    for _s in [SearchMonitor]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptimizeVar, name, value)
    __swig_getmethods__ = {}
    for _s in [SearchMonitor]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OptimizeVar, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Best(self): return _pywrapcp.OptimizeVar_Best(self)
    def Var(self): return _pywrapcp.OptimizeVar_Var(self)
    def EnterSearch(self): return _pywrapcp.OptimizeVar_EnterSearch(self)
    def BeginNextDecision(self, *args): return _pywrapcp.OptimizeVar_BeginNextDecision(self, *args)
    def RefuteDecision(self, *args): return _pywrapcp.OptimizeVar_RefuteDecision(self, *args)
    def AtSolution(self): return _pywrapcp.OptimizeVar_AtSolution(self)
    def AcceptSolution(self): return _pywrapcp.OptimizeVar_AcceptSolution(self)
OptimizeVar_swigregister = _pywrapcp.OptimizeVar_swigregister
OptimizeVar_swigregister(OptimizeVar)

class SearchLimit(SearchMonitor):
    __swig_setmethods__ = {}
    for _s in [SearchMonitor]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SearchLimit, name, value)
    __swig_getmethods__ = {}
    for _s in [SearchMonitor]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SearchLimit, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_SearchLimit
    __del__ = lambda self : None;
    def Crossed(self): return _pywrapcp.SearchLimit_Crossed(self)
    def Check(self): return _pywrapcp.SearchLimit_Check(self)
    def Init(self): return _pywrapcp.SearchLimit_Init(self)
    def EnterSearch(self): return _pywrapcp.SearchLimit_EnterSearch(self)
    def BeginNextDecision(self, *args): return _pywrapcp.SearchLimit_BeginNextDecision(self, *args)
    def RefuteDecision(self, *args): return _pywrapcp.SearchLimit_RefuteDecision(self, *args)
SearchLimit_swigregister = _pywrapcp.SearchLimit_swigregister
SearchLimit_swigregister(SearchLimit)

class IntervalVar(PropagationBaseObject):
    __swig_setmethods__ = {}
    for _s in [PropagationBaseObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntervalVar, name, value)
    __swig_getmethods__ = {}
    for _s in [PropagationBaseObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntervalVar, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    def StartMin(self): return _pywrapcp.IntervalVar_StartMin(self)
    def StartMax(self): return _pywrapcp.IntervalVar_StartMax(self)
    def SetStartMin(self, *args): return _pywrapcp.IntervalVar_SetStartMin(self, *args)
    def SetStartMax(self, *args): return _pywrapcp.IntervalVar_SetStartMax(self, *args)
    def SetStartRange(self, *args): return _pywrapcp.IntervalVar_SetStartRange(self, *args)
    def OldStartMin(self): return _pywrapcp.IntervalVar_OldStartMin(self)
    def OldStartMax(self): return _pywrapcp.IntervalVar_OldStartMax(self)
    def WhenStartRange(self, *args): return _pywrapcp.IntervalVar_WhenStartRange(self, *args)
    def WhenStartBound(self, *args): return _pywrapcp.IntervalVar_WhenStartBound(self, *args)
    def DurationMin(self): return _pywrapcp.IntervalVar_DurationMin(self)
    def DurationMax(self): return _pywrapcp.IntervalVar_DurationMax(self)
    def SetDurationMin(self, *args): return _pywrapcp.IntervalVar_SetDurationMin(self, *args)
    def SetDurationMax(self, *args): return _pywrapcp.IntervalVar_SetDurationMax(self, *args)
    def SetDurationRange(self, *args): return _pywrapcp.IntervalVar_SetDurationRange(self, *args)
    def OldDurationMin(self): return _pywrapcp.IntervalVar_OldDurationMin(self)
    def OldDurationMax(self): return _pywrapcp.IntervalVar_OldDurationMax(self)
    def WhenDurationRange(self, *args): return _pywrapcp.IntervalVar_WhenDurationRange(self, *args)
    def WhenDurationBound(self, *args): return _pywrapcp.IntervalVar_WhenDurationBound(self, *args)
    def EndMin(self): return _pywrapcp.IntervalVar_EndMin(self)
    def EndMax(self): return _pywrapcp.IntervalVar_EndMax(self)
    def SetEndMin(self, *args): return _pywrapcp.IntervalVar_SetEndMin(self, *args)
    def SetEndMax(self, *args): return _pywrapcp.IntervalVar_SetEndMax(self, *args)
    def SetEndRange(self, *args): return _pywrapcp.IntervalVar_SetEndRange(self, *args)
    def OldEndMin(self): return _pywrapcp.IntervalVar_OldEndMin(self)
    def OldEndMax(self): return _pywrapcp.IntervalVar_OldEndMax(self)
    def WhenEndRange(self, *args): return _pywrapcp.IntervalVar_WhenEndRange(self, *args)
    def WhenEndBound(self, *args): return _pywrapcp.IntervalVar_WhenEndBound(self, *args)
    def MustBePerformed(self): return _pywrapcp.IntervalVar_MustBePerformed(self)
    def MayBePerformed(self): return _pywrapcp.IntervalVar_MayBePerformed(self)
    def CannotBePerformed(self): return _pywrapcp.IntervalVar_CannotBePerformed(self)
    def IsPerformedBound(self): return _pywrapcp.IntervalVar_IsPerformedBound(self)
    def SetPerformed(self, *args): return _pywrapcp.IntervalVar_SetPerformed(self, *args)
    def WasPerformedBound(self): return _pywrapcp.IntervalVar_WasPerformedBound(self)
    def WhenPerformedBound(self, *args): return _pywrapcp.IntervalVar_WhenPerformedBound(self, *args)
    def WhenAnything(self, *args): return _pywrapcp.IntervalVar_WhenAnything(self, *args)
    def StartExpr(self): return _pywrapcp.IntervalVar_StartExpr(self)
    def DurationExpr(self): return _pywrapcp.IntervalVar_DurationExpr(self)
    def EndExpr(self): return _pywrapcp.IntervalVar_EndExpr(self)
    def PerformedExpr(self): return _pywrapcp.IntervalVar_PerformedExpr(self)
    def SafeStartExpr(self, *args): return _pywrapcp.IntervalVar_SafeStartExpr(self, *args)
    def SafeDurationExpr(self, *args): return _pywrapcp.IntervalVar_SafeDurationExpr(self, *args)
    def SafeEndExpr(self, *args): return _pywrapcp.IntervalVar_SafeEndExpr(self, *args)
    def EndsAfterEnd(self, *args): return _pywrapcp.IntervalVar_EndsAfterEnd(self, *args)
    def EndsAfterStart(self, *args): return _pywrapcp.IntervalVar_EndsAfterStart(self, *args)
    def EndsAtEnd(self, *args): return _pywrapcp.IntervalVar_EndsAtEnd(self, *args)
    def EndsAtStart(self, *args): return _pywrapcp.IntervalVar_EndsAtStart(self, *args)
    def StartsAfterEnd(self, *args): return _pywrapcp.IntervalVar_StartsAfterEnd(self, *args)
    def StartsAfterStart(self, *args): return _pywrapcp.IntervalVar_StartsAfterStart(self, *args)
    def StartsAtEnd(self, *args): return _pywrapcp.IntervalVar_StartsAtEnd(self, *args)
    def StartsAtStart(self, *args): return _pywrapcp.IntervalVar_StartsAtStart(self, *args)
    def StaysInSync(self, *args): return _pywrapcp.IntervalVar_StaysInSync(self, *args)
    def EndsAfter(self, *args): return _pywrapcp.IntervalVar_EndsAfter(self, *args)
    def EndsAt(self, *args): return _pywrapcp.IntervalVar_EndsAt(self, *args)
    def EndsBefore(self, *args): return _pywrapcp.IntervalVar_EndsBefore(self, *args)
    def StartsAfter(self, *args): return _pywrapcp.IntervalVar_StartsAfter(self, *args)
    def StartsAt(self, *args): return _pywrapcp.IntervalVar_StartsAt(self, *args)
    def StartsBefore(self, *args): return _pywrapcp.IntervalVar_StartsBefore(self, *args)
    def CrossesDate(self, *args): return _pywrapcp.IntervalVar_CrossesDate(self, *args)
    def AvoidsDate(self, *args): return _pywrapcp.IntervalVar_AvoidsDate(self, *args)
    def __repr__(self): return _pywrapcp.IntervalVar___repr__(self)
IntervalVar_swigregister = _pywrapcp.IntervalVar_swigregister
IntervalVar_swigregister(IntervalVar)

class SequenceVar(PropagationBaseObject):
    __swig_setmethods__ = {}
    for _s in [PropagationBaseObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SequenceVar, name, value)
    __swig_getmethods__ = {}
    for _s in [PropagationBaseObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SequenceVar, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    def RankFirst(self, *args): return _pywrapcp.SequenceVar_RankFirst(self, *args)
    def RankNotFirst(self, *args): return _pywrapcp.SequenceVar_RankNotFirst(self, *args)
    def RankLast(self, *args): return _pywrapcp.SequenceVar_RankLast(self, *args)
    def RankNotLast(self, *args): return _pywrapcp.SequenceVar_RankNotLast(self, *args)
    def Interval(self, *args): return _pywrapcp.SequenceVar_Interval(self, *args)
    def Next(self, *args): return _pywrapcp.SequenceVar_Next(self, *args)
    def Size(self): return _pywrapcp.SequenceVar_Size(self)
    def __repr__(self): return _pywrapcp.SequenceVar___repr__(self)
SequenceVar_swigregister = _pywrapcp.SequenceVar_swigregister
SequenceVar_swigregister(SequenceVar)

class AssignmentElement(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AssignmentElement, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AssignmentElement, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Activate(self): return _pywrapcp.AssignmentElement_Activate(self)
    def Deactivate(self): return _pywrapcp.AssignmentElement_Deactivate(self)
    def Activated(self): return _pywrapcp.AssignmentElement_Activated(self)
    __swig_destroy__ = _pywrapcp.delete_AssignmentElement
    __del__ = lambda self : None;
AssignmentElement_swigregister = _pywrapcp.AssignmentElement_swigregister
AssignmentElement_swigregister(AssignmentElement)

class IntVarElement(AssignmentElement):
    __swig_setmethods__ = {}
    for _s in [AssignmentElement]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVarElement, name, value)
    __swig_getmethods__ = {}
    for _s in [AssignmentElement]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntVarElement, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Var(self): return _pywrapcp.IntVarElement_Var(self)
    def Min(self): return _pywrapcp.IntVarElement_Min(self)
    def SetMin(self, *args): return _pywrapcp.IntVarElement_SetMin(self, *args)
    def Max(self): return _pywrapcp.IntVarElement_Max(self)
    def SetMax(self, *args): return _pywrapcp.IntVarElement_SetMax(self, *args)
    def Value(self): return _pywrapcp.IntVarElement_Value(self)
    def Bound(self): return _pywrapcp.IntVarElement_Bound(self)
    def SetRange(self, *args): return _pywrapcp.IntVarElement_SetRange(self, *args)
    def SetValue(self, *args): return _pywrapcp.IntVarElement_SetValue(self, *args)
    def __eq__(self, *args): return _pywrapcp.IntVarElement___eq__(self, *args)
    def __ne__(self, *args): return _pywrapcp.IntVarElement___ne__(self, *args)
    __swig_destroy__ = _pywrapcp.delete_IntVarElement
    __del__ = lambda self : None;
IntVarElement_swigregister = _pywrapcp.IntVarElement_swigregister
IntVarElement_swigregister(IntVarElement)

class IntervalVarElement(AssignmentElement):
    __swig_setmethods__ = {}
    for _s in [AssignmentElement]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntervalVarElement, name, value)
    __swig_getmethods__ = {}
    for _s in [AssignmentElement]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntervalVarElement, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def StartMin(self): return _pywrapcp.IntervalVarElement_StartMin(self)
    def StartMax(self): return _pywrapcp.IntervalVarElement_StartMax(self)
    def StartValue(self): return _pywrapcp.IntervalVarElement_StartValue(self)
    def DurationMin(self): return _pywrapcp.IntervalVarElement_DurationMin(self)
    def DurationMax(self): return _pywrapcp.IntervalVarElement_DurationMax(self)
    def DurationValue(self): return _pywrapcp.IntervalVarElement_DurationValue(self)
    def EndMin(self): return _pywrapcp.IntervalVarElement_EndMin(self)
    def EndMax(self): return _pywrapcp.IntervalVarElement_EndMax(self)
    def EndValue(self): return _pywrapcp.IntervalVarElement_EndValue(self)
    def PerformedMin(self): return _pywrapcp.IntervalVarElement_PerformedMin(self)
    def PerformedMax(self): return _pywrapcp.IntervalVarElement_PerformedMax(self)
    def PerformedValue(self): return _pywrapcp.IntervalVarElement_PerformedValue(self)
    def SetStartMin(self, *args): return _pywrapcp.IntervalVarElement_SetStartMin(self, *args)
    def SetStartMax(self, *args): return _pywrapcp.IntervalVarElement_SetStartMax(self, *args)
    def SetStartRange(self, *args): return _pywrapcp.IntervalVarElement_SetStartRange(self, *args)
    def SetStartValue(self, *args): return _pywrapcp.IntervalVarElement_SetStartValue(self, *args)
    def SetDurationMin(self, *args): return _pywrapcp.IntervalVarElement_SetDurationMin(self, *args)
    def SetDurationMax(self, *args): return _pywrapcp.IntervalVarElement_SetDurationMax(self, *args)
    def SetDurationRange(self, *args): return _pywrapcp.IntervalVarElement_SetDurationRange(self, *args)
    def SetDurationValue(self, *args): return _pywrapcp.IntervalVarElement_SetDurationValue(self, *args)
    def SetEndMin(self, *args): return _pywrapcp.IntervalVarElement_SetEndMin(self, *args)
    def SetEndMax(self, *args): return _pywrapcp.IntervalVarElement_SetEndMax(self, *args)
    def SetEndRange(self, *args): return _pywrapcp.IntervalVarElement_SetEndRange(self, *args)
    def SetEndValue(self, *args): return _pywrapcp.IntervalVarElement_SetEndValue(self, *args)
    def SetPerformedMin(self, *args): return _pywrapcp.IntervalVarElement_SetPerformedMin(self, *args)
    def SetPerformedMax(self, *args): return _pywrapcp.IntervalVarElement_SetPerformedMax(self, *args)
    def SetPerformedRange(self, *args): return _pywrapcp.IntervalVarElement_SetPerformedRange(self, *args)
    def SetPerformedValue(self, *args): return _pywrapcp.IntervalVarElement_SetPerformedValue(self, *args)
    def __eq__(self, *args): return _pywrapcp.IntervalVarElement___eq__(self, *args)
    def __ne__(self, *args): return _pywrapcp.IntervalVarElement___ne__(self, *args)
    __swig_destroy__ = _pywrapcp.delete_IntervalVarElement
    __del__ = lambda self : None;
IntervalVarElement_swigregister = _pywrapcp.IntervalVarElement_swigregister
IntervalVarElement_swigregister(IntervalVarElement)

class SequenceVarElement(AssignmentElement):
    __swig_setmethods__ = {}
    for _s in [AssignmentElement]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SequenceVarElement, name, value)
    __swig_getmethods__ = {}
    for _s in [AssignmentElement]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SequenceVarElement, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def ForwardSequence(self): return _pywrapcp.SequenceVarElement_ForwardSequence(self)
    def BackwardSequence(self): return _pywrapcp.SequenceVarElement_BackwardSequence(self)
    def Unperformed(self): return _pywrapcp.SequenceVarElement_Unperformed(self)
    def SetSequence(self, *args): return _pywrapcp.SequenceVarElement_SetSequence(self, *args)
    def SetForwardSequence(self, *args): return _pywrapcp.SequenceVarElement_SetForwardSequence(self, *args)
    def SetBackwardSequence(self, *args): return _pywrapcp.SequenceVarElement_SetBackwardSequence(self, *args)
    def SetUnperformed(self, *args): return _pywrapcp.SequenceVarElement_SetUnperformed(self, *args)
    def __eq__(self, *args): return _pywrapcp.SequenceVarElement___eq__(self, *args)
    def __ne__(self, *args): return _pywrapcp.SequenceVarElement___ne__(self, *args)
    __swig_destroy__ = _pywrapcp.delete_SequenceVarElement
    __del__ = lambda self : None;
SequenceVarElement_swigregister = _pywrapcp.SequenceVarElement_swigregister
SequenceVarElement_swigregister(SequenceVarElement)

class Assignment(PropagationBaseObject):
    __swig_setmethods__ = {}
    for _s in [PropagationBaseObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Assignment, name, value)
    __swig_getmethods__ = {}
    for _s in [PropagationBaseObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Assignment, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Clear(self): return _pywrapcp.Assignment_Clear(self)
    def Empty(self): return _pywrapcp.Assignment_Empty(self)
    def Size(self): return _pywrapcp.Assignment_Size(self)
    def NumIntVars(self): return _pywrapcp.Assignment_NumIntVars(self)
    def NumIntervalVars(self): return _pywrapcp.Assignment_NumIntervalVars(self)
    def NumSequenceVars(self): return _pywrapcp.Assignment_NumSequenceVars(self)
    def Store(self): return _pywrapcp.Assignment_Store(self)
    def Restore(self): return _pywrapcp.Assignment_Restore(self)
    def Load(self, *args): return _pywrapcp.Assignment_Load(self, *args)
    def Save(self, *args): return _pywrapcp.Assignment_Save(self, *args)
    def AddObjective(self, *args): return _pywrapcp.Assignment_AddObjective(self, *args)
    def Objective(self): return _pywrapcp.Assignment_Objective(self)
    def HasObjective(self): return _pywrapcp.Assignment_HasObjective(self)
    def ObjectiveMin(self): return _pywrapcp.Assignment_ObjectiveMin(self)
    def ObjectiveMax(self): return _pywrapcp.Assignment_ObjectiveMax(self)
    def ObjectiveValue(self): return _pywrapcp.Assignment_ObjectiveValue(self)
    def ObjectiveBound(self): return _pywrapcp.Assignment_ObjectiveBound(self)
    def SetObjectiveMin(self, *args): return _pywrapcp.Assignment_SetObjectiveMin(self, *args)
    def SetObjectiveMax(self, *args): return _pywrapcp.Assignment_SetObjectiveMax(self, *args)
    def SetObjectiveValue(self, *args): return _pywrapcp.Assignment_SetObjectiveValue(self, *args)
    def SetObjectiveRange(self, *args): return _pywrapcp.Assignment_SetObjectiveRange(self, *args)
    def Min(self, *args): return _pywrapcp.Assignment_Min(self, *args)
    def Max(self, *args): return _pywrapcp.Assignment_Max(self, *args)
    def Value(self, *args): return _pywrapcp.Assignment_Value(self, *args)
    def Bound(self, *args): return _pywrapcp.Assignment_Bound(self, *args)
    def SetMin(self, *args): return _pywrapcp.Assignment_SetMin(self, *args)
    def SetMax(self, *args): return _pywrapcp.Assignment_SetMax(self, *args)
    def SetRange(self, *args): return _pywrapcp.Assignment_SetRange(self, *args)
    def SetValue(self, *args): return _pywrapcp.Assignment_SetValue(self, *args)
    def StartMin(self, *args): return _pywrapcp.Assignment_StartMin(self, *args)
    def StartMax(self, *args): return _pywrapcp.Assignment_StartMax(self, *args)
    def StartValue(self, *args): return _pywrapcp.Assignment_StartValue(self, *args)
    def DurationMin(self, *args): return _pywrapcp.Assignment_DurationMin(self, *args)
    def DurationMax(self, *args): return _pywrapcp.Assignment_DurationMax(self, *args)
    def DurationValue(self, *args): return _pywrapcp.Assignment_DurationValue(self, *args)
    def EndMin(self, *args): return _pywrapcp.Assignment_EndMin(self, *args)
    def EndMax(self, *args): return _pywrapcp.Assignment_EndMax(self, *args)
    def EndValue(self, *args): return _pywrapcp.Assignment_EndValue(self, *args)
    def PerformedMin(self, *args): return _pywrapcp.Assignment_PerformedMin(self, *args)
    def PerformedMax(self, *args): return _pywrapcp.Assignment_PerformedMax(self, *args)
    def PerformedValue(self, *args): return _pywrapcp.Assignment_PerformedValue(self, *args)
    def SetStartMin(self, *args): return _pywrapcp.Assignment_SetStartMin(self, *args)
    def SetStartMax(self, *args): return _pywrapcp.Assignment_SetStartMax(self, *args)
    def SetStartRange(self, *args): return _pywrapcp.Assignment_SetStartRange(self, *args)
    def SetStartValue(self, *args): return _pywrapcp.Assignment_SetStartValue(self, *args)
    def SetDurationMin(self, *args): return _pywrapcp.Assignment_SetDurationMin(self, *args)
    def SetDurationMax(self, *args): return _pywrapcp.Assignment_SetDurationMax(self, *args)
    def SetDurationRange(self, *args): return _pywrapcp.Assignment_SetDurationRange(self, *args)
    def SetDurationValue(self, *args): return _pywrapcp.Assignment_SetDurationValue(self, *args)
    def SetEndMin(self, *args): return _pywrapcp.Assignment_SetEndMin(self, *args)
    def SetEndMax(self, *args): return _pywrapcp.Assignment_SetEndMax(self, *args)
    def SetEndRange(self, *args): return _pywrapcp.Assignment_SetEndRange(self, *args)
    def SetEndValue(self, *args): return _pywrapcp.Assignment_SetEndValue(self, *args)
    def SetPerformedMin(self, *args): return _pywrapcp.Assignment_SetPerformedMin(self, *args)
    def SetPerformedMax(self, *args): return _pywrapcp.Assignment_SetPerformedMax(self, *args)
    def SetPerformedRange(self, *args): return _pywrapcp.Assignment_SetPerformedRange(self, *args)
    def SetPerformedValue(self, *args): return _pywrapcp.Assignment_SetPerformedValue(self, *args)
    def Add(self, *args): return _pywrapcp.Assignment_Add(self, *args)
    def ForwardSequence(self, *args): return _pywrapcp.Assignment_ForwardSequence(self, *args)
    def BackwardSequence(self, *args): return _pywrapcp.Assignment_BackwardSequence(self, *args)
    def Unperformed(self, *args): return _pywrapcp.Assignment_Unperformed(self, *args)
    def SetSequence(self, *args): return _pywrapcp.Assignment_SetSequence(self, *args)
    def SetForwardSequence(self, *args): return _pywrapcp.Assignment_SetForwardSequence(self, *args)
    def SetBackwardSequence(self, *args): return _pywrapcp.Assignment_SetBackwardSequence(self, *args)
    def SetUnperformed(self, *args): return _pywrapcp.Assignment_SetUnperformed(self, *args)
    def Activate(self, *args): return _pywrapcp.Assignment_Activate(self, *args)
    def Deactivate(self, *args): return _pywrapcp.Assignment_Deactivate(self, *args)
    def Activated(self, *args): return _pywrapcp.Assignment_Activated(self, *args)
    def IntVarContainer(self): return _pywrapcp.Assignment_IntVarContainer(self)
    def MutableIntVarContainer(self): return _pywrapcp.Assignment_MutableIntVarContainer(self)
    def IntervalVarContainer(self): return _pywrapcp.Assignment_IntervalVarContainer(self)
    def MutableIntervalVarContainer(self): return _pywrapcp.Assignment_MutableIntervalVarContainer(self)
    def SequenceVarContainer(self): return _pywrapcp.Assignment_SequenceVarContainer(self)
    def MutableSequenceVarContainer(self): return _pywrapcp.Assignment_MutableSequenceVarContainer(self)
    def __eq__(self, *args): return _pywrapcp.Assignment___eq__(self, *args)
    def __ne__(self, *args): return _pywrapcp.Assignment___ne__(self, *args)
Assignment_swigregister = _pywrapcp.Assignment_swigregister
Assignment_swigregister(Assignment)


def __lshift__(*args):
  return _pywrapcp.__lshift__(*args)
__lshift__ = _pywrapcp.__lshift__
class Pack(Constraint):
    __swig_setmethods__ = {}
    for _s in [Constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pack, name, value)
    __swig_getmethods__ = {}
    for _s in [Constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Pack, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def AddWeightedSumLessOrEqualConstantDimension(self, *args): return _pywrapcp.Pack_AddWeightedSumLessOrEqualConstantDimension(self, *args)
    def AddWeightedSumEqualVarDimension(self, *args): return _pywrapcp.Pack_AddWeightedSumEqualVarDimension(self, *args)
    def AddSumVariableWeightsLessOrEqualConstantDimension(self, *args): return _pywrapcp.Pack_AddSumVariableWeightsLessOrEqualConstantDimension(self, *args)
    def AddWeightedSumOfAssignedDimension(self, *args): return _pywrapcp.Pack_AddWeightedSumOfAssignedDimension(self, *args)
    def AddCountUsedBinDimension(self, *args): return _pywrapcp.Pack_AddCountUsedBinDimension(self, *args)
    def AddCountAssignedItemsDimension(self, *args): return _pywrapcp.Pack_AddCountAssignedItemsDimension(self, *args)
    def Post(self): return _pywrapcp.Pack_Post(self)
    def InitialPropagateWrapper(self): return _pywrapcp.Pack_InitialPropagateWrapper(self)
Pack_swigregister = _pywrapcp.Pack_swigregister
Pack_swigregister(Pack)

class DisjunctiveConstraint(Constraint):
    __swig_setmethods__ = {}
    for _s in [Constraint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DisjunctiveConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [Constraint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DisjunctiveConstraint, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def SequenceVar(self): return _pywrapcp.DisjunctiveConstraint_SequenceVar(self)
    def SetTransitionTime(self, *args): return _pywrapcp.DisjunctiveConstraint_SetTransitionTime(self, *args)
    def TransitionTime(self, *args): return _pywrapcp.DisjunctiveConstraint_TransitionTime(self, *args)
DisjunctiveConstraint_swigregister = _pywrapcp.DisjunctiveConstraint_swigregister
DisjunctiveConstraint_swigregister(DisjunctiveConstraint)

class RevInteger(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RevInteger, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RevInteger, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pywrapcp.new_RevInteger(*args)
        try: self.this.append(this)
        except: self.this = this
    def Value(self): return _pywrapcp.RevInteger_Value(self)
    def SetValue(self, *args): return _pywrapcp.RevInteger_SetValue(self, *args)
    __swig_destroy__ = _pywrapcp.delete_RevInteger
    __del__ = lambda self : None;
RevInteger_swigregister = _pywrapcp.RevInteger_swigregister
RevInteger_swigregister(RevInteger)

class RevBool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RevBool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RevBool, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pywrapcp.new_RevBool(*args)
        try: self.this.append(this)
        except: self.this = this
    def Value(self): return _pywrapcp.RevBool_Value(self)
    def SetValue(self, *args): return _pywrapcp.RevBool_SetValue(self, *args)
    __swig_destroy__ = _pywrapcp.delete_RevBool
    __del__ = lambda self : None;
RevBool_swigregister = _pywrapcp.RevBool_swigregister
RevBool_swigregister(RevBool)

class IntContainer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntContainer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntContainer, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Element(self, *args): return _pywrapcp.IntContainer_Element(self, *args)
    def Size(self): return _pywrapcp.IntContainer_Size(self)
    def __eq__(self, *args): return _pywrapcp.IntContainer___eq__(self, *args)
    def __ne__(self, *args): return _pywrapcp.IntContainer___ne__(self, *args)
    __swig_destroy__ = _pywrapcp.delete_IntContainer
    __del__ = lambda self : None;
IntContainer_swigregister = _pywrapcp.IntContainer_swigregister
IntContainer_swigregister(IntContainer)

class IntervalContainer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntervalContainer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntervalContainer, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __eq__(self, *args): return _pywrapcp.IntervalContainer___eq__(self, *args)
    def __ne__(self, *args): return _pywrapcp.IntervalContainer___ne__(self, *args)
    __swig_destroy__ = _pywrapcp.delete_IntervalContainer
    __del__ = lambda self : None;
IntervalContainer_swigregister = _pywrapcp.IntervalContainer_swigregister
IntervalContainer_swigregister(IntervalContainer)

class SequenceContainer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SequenceContainer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SequenceContainer, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __eq__(self, *args): return _pywrapcp.SequenceContainer___eq__(self, *args)
    def __ne__(self, *args): return _pywrapcp.SequenceContainer___ne__(self, *args)
    __swig_destroy__ = _pywrapcp.delete_SequenceContainer
    __del__ = lambda self : None;
SequenceContainer_swigregister = _pywrapcp.SequenceContainer_swigregister
SequenceContainer_swigregister(SequenceContainer)

class LocalSearchOperator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalSearchOperator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LocalSearchOperator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def NextNeighbor(self, *args): return _pywrapcp.LocalSearchOperator_NextNeighbor(self, *args)
    def Start(self, *args): return _pywrapcp.LocalSearchOperator_Start(self, *args)
LocalSearchOperator_swigregister = _pywrapcp.LocalSearchOperator_swigregister
LocalSearchOperator_swigregister(LocalSearchOperator)

class IntVarLocalSearchOperatorTemplate(LocalSearchOperator):
    __swig_setmethods__ = {}
    for _s in [LocalSearchOperator]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVarLocalSearchOperatorTemplate, name, value)
    __swig_getmethods__ = {}
    for _s in [LocalSearchOperator]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntVarLocalSearchOperatorTemplate, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def IsIncremental(self): return _pywrapcp.IntVarLocalSearchOperatorTemplate_IsIncremental(self)
    def Size(self): return _pywrapcp.IntVarLocalSearchOperatorTemplate_Size(self)
    def Value(self, *args): return _pywrapcp.IntVarLocalSearchOperatorTemplate_Value(self, *args)
    def OldValue(self, *args): return _pywrapcp.IntVarLocalSearchOperatorTemplate_OldValue(self, *args)
    def SetValue(self, *args): return _pywrapcp.IntVarLocalSearchOperatorTemplate_SetValue(self, *args)
    def OnStart(self): return _pywrapcp.IntVarLocalSearchOperatorTemplate_OnStart(self)
IntVarLocalSearchOperatorTemplate_swigregister = _pywrapcp.IntVarLocalSearchOperatorTemplate_swigregister
IntVarLocalSearchOperatorTemplate_swigregister(IntVarLocalSearchOperatorTemplate)

class IntVarLocalSearchOperator(IntVarLocalSearchOperatorTemplate):
    __swig_setmethods__ = {}
    for _s in [IntVarLocalSearchOperatorTemplate]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVarLocalSearchOperator, name, value)
    __swig_getmethods__ = {}
    for _s in [IntVarLocalSearchOperatorTemplate]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntVarLocalSearchOperator, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        if self.__class__ == IntVarLocalSearchOperator:
            _self = None
        else:
            _self = self
        this = _pywrapcp.new_IntVarLocalSearchOperator(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pywrapcp.delete_IntVarLocalSearchOperator
    __del__ = lambda self : None;
    def NextNeighbor(self, *args): return _pywrapcp.IntVarLocalSearchOperator_NextNeighbor(self, *args)
    def OneNeighbor(self): return _pywrapcp.IntVarLocalSearchOperator_OneNeighbor(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_IntVarLocalSearchOperator(self)
        return weakref_proxy(self)
IntVarLocalSearchOperator_swigregister = _pywrapcp.IntVarLocalSearchOperator_swigregister
IntVarLocalSearchOperator_swigregister(IntVarLocalSearchOperator)

class SequenceVarLocalSearchOperatorTemplate(LocalSearchOperator):
    __swig_setmethods__ = {}
    for _s in [LocalSearchOperator]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SequenceVarLocalSearchOperatorTemplate, name, value)
    __swig_getmethods__ = {}
    for _s in [LocalSearchOperator]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SequenceVarLocalSearchOperatorTemplate, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
SequenceVarLocalSearchOperatorTemplate_swigregister = _pywrapcp.SequenceVarLocalSearchOperatorTemplate_swigregister
SequenceVarLocalSearchOperatorTemplate_swigregister(SequenceVarLocalSearchOperatorTemplate)

class SequenceVarLocalSearchOperator(SequenceVarLocalSearchOperatorTemplate):
    __swig_setmethods__ = {}
    for _s in [SequenceVarLocalSearchOperatorTemplate]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SequenceVarLocalSearchOperator, name, value)
    __swig_getmethods__ = {}
    for _s in [SequenceVarLocalSearchOperatorTemplate]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SequenceVarLocalSearchOperator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
SequenceVarLocalSearchOperator_swigregister = _pywrapcp.SequenceVarLocalSearchOperator_swigregister
SequenceVarLocalSearchOperator_swigregister(SequenceVarLocalSearchOperator)

class BaseLNS(IntVarLocalSearchOperator):
    __swig_setmethods__ = {}
    for _s in [IntVarLocalSearchOperator]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseLNS, name, value)
    __swig_getmethods__ = {}
    for _s in [IntVarLocalSearchOperator]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BaseLNS, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        if self.__class__ == BaseLNS:
            _self = None
        else:
            _self = self
        this = _pywrapcp.new_BaseLNS(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pywrapcp.delete_BaseLNS
    __del__ = lambda self : None;
    def InitFragments(self): return _pywrapcp.BaseLNS_InitFragments(self)
    def NextFragmentWrapper(self, *args): return _pywrapcp.BaseLNS_NextFragmentWrapper(self, *args)
    def OneNeighbor(self): return _pywrapcp.BaseLNS_OneNeighbor(self)
    def __getitem__(self, *args): return _pywrapcp.BaseLNS___getitem__(self, *args)
    def __len__(self): return _pywrapcp.BaseLNS___len__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_BaseLNS(self)
        return weakref_proxy(self)
BaseLNS_swigregister = _pywrapcp.BaseLNS_swigregister
BaseLNS_swigregister(BaseLNS)

class ChangeValue(IntVarLocalSearchOperator):
    __swig_setmethods__ = {}
    for _s in [IntVarLocalSearchOperator]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChangeValue, name, value)
    __swig_getmethods__ = {}
    for _s in [IntVarLocalSearchOperator]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChangeValue, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_ChangeValue
    __del__ = lambda self : None;
    def ModifyValue(self, *args): return _pywrapcp.ChangeValue_ModifyValue(self, *args)
ChangeValue_swigregister = _pywrapcp.ChangeValue_swigregister
ChangeValue_swigregister(ChangeValue)

class PathOperator(IntVarLocalSearchOperator):
    __swig_setmethods__ = {}
    for _s in [IntVarLocalSearchOperator]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PathOperator, name, value)
    __swig_getmethods__ = {}
    for _s in [IntVarLocalSearchOperator]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PathOperator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def Neighbor(self): return _pywrapcp.PathOperator_Neighbor(self)
PathOperator_swigregister = _pywrapcp.PathOperator_swigregister
PathOperator_swigregister(PathOperator)

class LocalSearchFilter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalSearchFilter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LocalSearchFilter, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def Accept(self, *args): return _pywrapcp.LocalSearchFilter_Accept(self, *args)
    def Synchronize(self, *args): return _pywrapcp.LocalSearchFilter_Synchronize(self, *args)
    def IsIncremental(self): return _pywrapcp.LocalSearchFilter_IsIncremental(self)
    __swig_destroy__ = _pywrapcp.delete_LocalSearchFilter
    __del__ = lambda self : None;
LocalSearchFilter_swigregister = _pywrapcp.LocalSearchFilter_swigregister
LocalSearchFilter_swigregister(LocalSearchFilter)

class IntVarLocalSearchFilter(LocalSearchFilter):
    __swig_setmethods__ = {}
    for _s in [LocalSearchFilter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVarLocalSearchFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [LocalSearchFilter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntVarLocalSearchFilter, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        if self.__class__ == IntVarLocalSearchFilter:
            _self = None
        else:
            _self = self
        this = _pywrapcp.new_IntVarLocalSearchFilter(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pywrapcp.delete_IntVarLocalSearchFilter
    __del__ = lambda self : None;
    def Synchronize(self, *args): return _pywrapcp.IntVarLocalSearchFilter_Synchronize(self, *args)
    def Size(self): return _pywrapcp.IntVarLocalSearchFilter_Size(self)
    def Value(self, *args): return _pywrapcp.IntVarLocalSearchFilter_Value(self, *args)
    def IndexFromVar(self, *args): return _pywrapcp.IntVarLocalSearchFilter_IndexFromVar(self, *args)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_IntVarLocalSearchFilter(self)
        return weakref_proxy(self)
IntVarLocalSearchFilter_swigregister = _pywrapcp.IntVarLocalSearchFilter_swigregister
IntVarLocalSearchFilter_swigregister(IntVarLocalSearchFilter)

class BooleanVar(IntVar):
    __swig_setmethods__ = {}
    for _s in [IntVar]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BooleanVar, name, value)
    __swig_getmethods__ = {}
    for _s in [IntVar]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BooleanVar, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def Min(self): return _pywrapcp.BooleanVar_Min(self)
    def SetMin(self, *args): return _pywrapcp.BooleanVar_SetMin(self, *args)
    def Max(self): return _pywrapcp.BooleanVar_Max(self)
    def SetMax(self, *args): return _pywrapcp.BooleanVar_SetMax(self, *args)
    def SetRange(self, *args): return _pywrapcp.BooleanVar_SetRange(self, *args)
    def Bound(self): return _pywrapcp.BooleanVar_Bound(self)
    def Value(self): return _pywrapcp.BooleanVar_Value(self)
    def RemoveValue(self, *args): return _pywrapcp.BooleanVar_RemoveValue(self, *args)
    def RemoveInterval(self, *args): return _pywrapcp.BooleanVar_RemoveInterval(self, *args)
    def WhenBound(self, *args): return _pywrapcp.BooleanVar_WhenBound(self, *args)
    def WhenRange(self, *args): return _pywrapcp.BooleanVar_WhenRange(self, *args)
    def WhenDomain(self, *args): return _pywrapcp.BooleanVar_WhenDomain(self, *args)
    def Size(self): return _pywrapcp.BooleanVar_Size(self)
    def Contains(self, *args): return _pywrapcp.BooleanVar_Contains(self, *args)
    def HoleIteratorAux(self, *args): return _pywrapcp.BooleanVar_HoleIteratorAux(self, *args)
    def DomainIteratorAux(self, *args): return _pywrapcp.BooleanVar_DomainIteratorAux(self, *args)
BooleanVar_swigregister = _pywrapcp.BooleanVar_swigregister
BooleanVar_swigregister(BooleanVar)


def ClearIntVector(*args):
  return _pywrapcp.ClearIntVector(*args)
ClearIntVector = _pywrapcp.ClearIntVector

def PushBackIntVector(*args):
  return _pywrapcp.PushBackIntVector(*args)
PushBackIntVector = _pywrapcp.PushBackIntVector
class PyDecisionBuilder(object):

  def NextWrapper(self, solver):
    try:
      return self.Next(solver)
    except Exception as e:
      if 'CP Solver fail' in str(e):
        return solver.FailDecision()
      else:
        raise

  def DebugString(self):
    return "PyDecisionBuilder"


class PyConstraint(Constraint):

  def InitialPropagateWrapper(self):
    try:
      self.InitialPropagate()
    except Exception as e:
      if 'CP Solver fail' in str(e):
        self.solver().ShouldFail()
      else:
        raise

  def DebugString(self):
    return "PyConstraint"


class PyDemon(Demon):

  def RunWrapper(self, solver):
    try:
      self.Run(solver)
    except Exception as e:
      if 'CP Solver fail' in str(e):
        solver.ShouldFail()
      else:
        raise

  def DebugString(self):
    return "PyDemon"


class PyLns(BaseLNS):

  def NextFragment(self):
    return []

  def InitFragments(self):
    pass

  def NextFragmentWrapper(self, output_cpp_vector_fragments):
    ClearIntVector(output_cpp_vector_fragments);
    f = self.NextFragment()
    if not f:
      return False
    for x in f:
      PushBackIntVector(x, output_cpp_vector_fragments);
    return True

class RoutingParameters(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RoutingParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RoutingParameters, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pywrapcp.new_RoutingParameters()
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["use_light_propagation"] = _pywrapcp.RoutingParameters_use_light_propagation_set
    __swig_getmethods__["use_light_propagation"] = _pywrapcp.RoutingParameters_use_light_propagation_get
    if _newclass:use_light_propagation = _swig_property(_pywrapcp.RoutingParameters_use_light_propagation_get, _pywrapcp.RoutingParameters_use_light_propagation_set)
    __swig_setmethods__["cache_callbacks"] = _pywrapcp.RoutingParameters_cache_callbacks_set
    __swig_getmethods__["cache_callbacks"] = _pywrapcp.RoutingParameters_cache_callbacks_get
    if _newclass:cache_callbacks = _swig_property(_pywrapcp.RoutingParameters_cache_callbacks_get, _pywrapcp.RoutingParameters_cache_callbacks_set)
    __swig_setmethods__["max_cache_size"] = _pywrapcp.RoutingParameters_max_cache_size_set
    __swig_getmethods__["max_cache_size"] = _pywrapcp.RoutingParameters_max_cache_size_get
    if _newclass:max_cache_size = _swig_property(_pywrapcp.RoutingParameters_max_cache_size_get, _pywrapcp.RoutingParameters_max_cache_size_set)
    __swig_destroy__ = _pywrapcp.delete_RoutingParameters
    __del__ = lambda self : None;
RoutingParameters_swigregister = _pywrapcp.RoutingParameters_swigregister
RoutingParameters_swigregister(RoutingParameters)

class RoutingSearchParameters(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RoutingSearchParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RoutingSearchParameters, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pywrapcp.new_RoutingSearchParameters()
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["no_lns"] = _pywrapcp.RoutingSearchParameters_no_lns_set
    __swig_getmethods__["no_lns"] = _pywrapcp.RoutingSearchParameters_no_lns_get
    if _newclass:no_lns = _swig_property(_pywrapcp.RoutingSearchParameters_no_lns_get, _pywrapcp.RoutingSearchParameters_no_lns_set)
    __swig_setmethods__["no_fullpathlns"] = _pywrapcp.RoutingSearchParameters_no_fullpathlns_set
    __swig_getmethods__["no_fullpathlns"] = _pywrapcp.RoutingSearchParameters_no_fullpathlns_get
    if _newclass:no_fullpathlns = _swig_property(_pywrapcp.RoutingSearchParameters_no_fullpathlns_get, _pywrapcp.RoutingSearchParameters_no_fullpathlns_set)
    __swig_setmethods__["no_relocate"] = _pywrapcp.RoutingSearchParameters_no_relocate_set
    __swig_getmethods__["no_relocate"] = _pywrapcp.RoutingSearchParameters_no_relocate_get
    if _newclass:no_relocate = _swig_property(_pywrapcp.RoutingSearchParameters_no_relocate_get, _pywrapcp.RoutingSearchParameters_no_relocate_set)
    __swig_setmethods__["no_relocate_neighbors"] = _pywrapcp.RoutingSearchParameters_no_relocate_neighbors_set
    __swig_getmethods__["no_relocate_neighbors"] = _pywrapcp.RoutingSearchParameters_no_relocate_neighbors_get
    if _newclass:no_relocate_neighbors = _swig_property(_pywrapcp.RoutingSearchParameters_no_relocate_neighbors_get, _pywrapcp.RoutingSearchParameters_no_relocate_neighbors_set)
    __swig_setmethods__["no_exchange"] = _pywrapcp.RoutingSearchParameters_no_exchange_set
    __swig_getmethods__["no_exchange"] = _pywrapcp.RoutingSearchParameters_no_exchange_get
    if _newclass:no_exchange = _swig_property(_pywrapcp.RoutingSearchParameters_no_exchange_get, _pywrapcp.RoutingSearchParameters_no_exchange_set)
    __swig_setmethods__["no_cross"] = _pywrapcp.RoutingSearchParameters_no_cross_set
    __swig_getmethods__["no_cross"] = _pywrapcp.RoutingSearchParameters_no_cross_get
    if _newclass:no_cross = _swig_property(_pywrapcp.RoutingSearchParameters_no_cross_get, _pywrapcp.RoutingSearchParameters_no_cross_set)
    __swig_setmethods__["no_2opt"] = _pywrapcp.RoutingSearchParameters_no_2opt_set
    __swig_getmethods__["no_2opt"] = _pywrapcp.RoutingSearchParameters_no_2opt_get
    if _newclass:no_2opt = _swig_property(_pywrapcp.RoutingSearchParameters_no_2opt_get, _pywrapcp.RoutingSearchParameters_no_2opt_set)
    __swig_setmethods__["no_oropt"] = _pywrapcp.RoutingSearchParameters_no_oropt_set
    __swig_getmethods__["no_oropt"] = _pywrapcp.RoutingSearchParameters_no_oropt_get
    if _newclass:no_oropt = _swig_property(_pywrapcp.RoutingSearchParameters_no_oropt_get, _pywrapcp.RoutingSearchParameters_no_oropt_set)
    __swig_setmethods__["no_make_active"] = _pywrapcp.RoutingSearchParameters_no_make_active_set
    __swig_getmethods__["no_make_active"] = _pywrapcp.RoutingSearchParameters_no_make_active_get
    if _newclass:no_make_active = _swig_property(_pywrapcp.RoutingSearchParameters_no_make_active_get, _pywrapcp.RoutingSearchParameters_no_make_active_set)
    __swig_setmethods__["no_lkh"] = _pywrapcp.RoutingSearchParameters_no_lkh_set
    __swig_getmethods__["no_lkh"] = _pywrapcp.RoutingSearchParameters_no_lkh_get
    if _newclass:no_lkh = _swig_property(_pywrapcp.RoutingSearchParameters_no_lkh_get, _pywrapcp.RoutingSearchParameters_no_lkh_set)
    __swig_setmethods__["no_tsp"] = _pywrapcp.RoutingSearchParameters_no_tsp_set
    __swig_getmethods__["no_tsp"] = _pywrapcp.RoutingSearchParameters_no_tsp_get
    if _newclass:no_tsp = _swig_property(_pywrapcp.RoutingSearchParameters_no_tsp_get, _pywrapcp.RoutingSearchParameters_no_tsp_set)
    __swig_setmethods__["no_tsplns"] = _pywrapcp.RoutingSearchParameters_no_tsplns_set
    __swig_getmethods__["no_tsplns"] = _pywrapcp.RoutingSearchParameters_no_tsplns_get
    if _newclass:no_tsplns = _swig_property(_pywrapcp.RoutingSearchParameters_no_tsplns_get, _pywrapcp.RoutingSearchParameters_no_tsplns_set)
    __swig_setmethods__["use_chain_make_inactive"] = _pywrapcp.RoutingSearchParameters_use_chain_make_inactive_set
    __swig_getmethods__["use_chain_make_inactive"] = _pywrapcp.RoutingSearchParameters_use_chain_make_inactive_get
    if _newclass:use_chain_make_inactive = _swig_property(_pywrapcp.RoutingSearchParameters_use_chain_make_inactive_get, _pywrapcp.RoutingSearchParameters_use_chain_make_inactive_set)
    __swig_setmethods__["use_extended_swap_active"] = _pywrapcp.RoutingSearchParameters_use_extended_swap_active_set
    __swig_getmethods__["use_extended_swap_active"] = _pywrapcp.RoutingSearchParameters_use_extended_swap_active_get
    if _newclass:use_extended_swap_active = _swig_property(_pywrapcp.RoutingSearchParameters_use_extended_swap_active_get, _pywrapcp.RoutingSearchParameters_use_extended_swap_active_set)
    __swig_setmethods__["solution_limit"] = _pywrapcp.RoutingSearchParameters_solution_limit_set
    __swig_getmethods__["solution_limit"] = _pywrapcp.RoutingSearchParameters_solution_limit_get
    if _newclass:solution_limit = _swig_property(_pywrapcp.RoutingSearchParameters_solution_limit_get, _pywrapcp.RoutingSearchParameters_solution_limit_set)
    __swig_setmethods__["time_limit"] = _pywrapcp.RoutingSearchParameters_time_limit_set
    __swig_getmethods__["time_limit"] = _pywrapcp.RoutingSearchParameters_time_limit_get
    if _newclass:time_limit = _swig_property(_pywrapcp.RoutingSearchParameters_time_limit_get, _pywrapcp.RoutingSearchParameters_time_limit_set)
    __swig_setmethods__["lns_time_limit"] = _pywrapcp.RoutingSearchParameters_lns_time_limit_set
    __swig_getmethods__["lns_time_limit"] = _pywrapcp.RoutingSearchParameters_lns_time_limit_get
    if _newclass:lns_time_limit = _swig_property(_pywrapcp.RoutingSearchParameters_lns_time_limit_get, _pywrapcp.RoutingSearchParameters_lns_time_limit_set)
    __swig_setmethods__["guided_local_search"] = _pywrapcp.RoutingSearchParameters_guided_local_search_set
    __swig_getmethods__["guided_local_search"] = _pywrapcp.RoutingSearchParameters_guided_local_search_get
    if _newclass:guided_local_search = _swig_property(_pywrapcp.RoutingSearchParameters_guided_local_search_get, _pywrapcp.RoutingSearchParameters_guided_local_search_set)
    __swig_setmethods__["guided_local_search_lambda_coefficient"] = _pywrapcp.RoutingSearchParameters_guided_local_search_lambda_coefficient_set
    __swig_getmethods__["guided_local_search_lambda_coefficient"] = _pywrapcp.RoutingSearchParameters_guided_local_search_lambda_coefficient_get
    if _newclass:guided_local_search_lambda_coefficient = _swig_property(_pywrapcp.RoutingSearchParameters_guided_local_search_lambda_coefficient_get, _pywrapcp.RoutingSearchParameters_guided_local_search_lambda_coefficient_set)
    __swig_setmethods__["simulated_annealing"] = _pywrapcp.RoutingSearchParameters_simulated_annealing_set
    __swig_getmethods__["simulated_annealing"] = _pywrapcp.RoutingSearchParameters_simulated_annealing_get
    if _newclass:simulated_annealing = _swig_property(_pywrapcp.RoutingSearchParameters_simulated_annealing_get, _pywrapcp.RoutingSearchParameters_simulated_annealing_set)
    __swig_setmethods__["tabu_search"] = _pywrapcp.RoutingSearchParameters_tabu_search_set
    __swig_getmethods__["tabu_search"] = _pywrapcp.RoutingSearchParameters_tabu_search_get
    if _newclass:tabu_search = _swig_property(_pywrapcp.RoutingSearchParameters_tabu_search_get, _pywrapcp.RoutingSearchParameters_tabu_search_set)
    __swig_setmethods__["dfs"] = _pywrapcp.RoutingSearchParameters_dfs_set
    __swig_getmethods__["dfs"] = _pywrapcp.RoutingSearchParameters_dfs_get
    if _newclass:dfs = _swig_property(_pywrapcp.RoutingSearchParameters_dfs_get, _pywrapcp.RoutingSearchParameters_dfs_set)
    __swig_setmethods__["first_solution"] = _pywrapcp.RoutingSearchParameters_first_solution_set
    __swig_getmethods__["first_solution"] = _pywrapcp.RoutingSearchParameters_first_solution_get
    if _newclass:first_solution = _swig_property(_pywrapcp.RoutingSearchParameters_first_solution_get, _pywrapcp.RoutingSearchParameters_first_solution_set)
    __swig_setmethods__["use_first_solution_dive"] = _pywrapcp.RoutingSearchParameters_use_first_solution_dive_set
    __swig_getmethods__["use_first_solution_dive"] = _pywrapcp.RoutingSearchParameters_use_first_solution_dive_get
    if _newclass:use_first_solution_dive = _swig_property(_pywrapcp.RoutingSearchParameters_use_first_solution_dive_get, _pywrapcp.RoutingSearchParameters_use_first_solution_dive_set)
    __swig_setmethods__["optimization_step"] = _pywrapcp.RoutingSearchParameters_optimization_step_set
    __swig_getmethods__["optimization_step"] = _pywrapcp.RoutingSearchParameters_optimization_step_get
    if _newclass:optimization_step = _swig_property(_pywrapcp.RoutingSearchParameters_optimization_step_get, _pywrapcp.RoutingSearchParameters_optimization_step_set)
    __swig_setmethods__["trace"] = _pywrapcp.RoutingSearchParameters_trace_set
    __swig_getmethods__["trace"] = _pywrapcp.RoutingSearchParameters_trace_get
    if _newclass:trace = _swig_property(_pywrapcp.RoutingSearchParameters_trace_get, _pywrapcp.RoutingSearchParameters_trace_set)
    __swig_destroy__ = _pywrapcp.delete_RoutingSearchParameters
    __del__ = lambda self : None;
RoutingSearchParameters_swigregister = _pywrapcp.RoutingSearchParameters_swigregister
RoutingSearchParameters_swigregister(RoutingSearchParameters)

class RoutingModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RoutingModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RoutingModel, name)
    __repr__ = _swig_repr
    ROUTING_DEFAULT_STRATEGY = _pywrapcp.RoutingModel_ROUTING_DEFAULT_STRATEGY
    ROUTING_GLOBAL_CHEAPEST_ARC = _pywrapcp.RoutingModel_ROUTING_GLOBAL_CHEAPEST_ARC
    ROUTING_LOCAL_CHEAPEST_ARC = _pywrapcp.RoutingModel_ROUTING_LOCAL_CHEAPEST_ARC
    ROUTING_PATH_CHEAPEST_ARC = _pywrapcp.RoutingModel_ROUTING_PATH_CHEAPEST_ARC
    ROUTING_PATH_MOST_CONSTRAINED_ARC = _pywrapcp.RoutingModel_ROUTING_PATH_MOST_CONSTRAINED_ARC
    ROUTING_EVALUATOR_STRATEGY = _pywrapcp.RoutingModel_ROUTING_EVALUATOR_STRATEGY
    ROUTING_ALL_UNPERFORMED = _pywrapcp.RoutingModel_ROUTING_ALL_UNPERFORMED
    ROUTING_BEST_INSERTION = _pywrapcp.RoutingModel_ROUTING_BEST_INSERTION
    ROUTING_GLOBAL_CHEAPEST_INSERTION = _pywrapcp.RoutingModel_ROUTING_GLOBAL_CHEAPEST_INSERTION
    ROUTING_LOCAL_CHEAPEST_INSERTION = _pywrapcp.RoutingModel_ROUTING_LOCAL_CHEAPEST_INSERTION
    ROUTING_SAVINGS = _pywrapcp.RoutingModel_ROUTING_SAVINGS
    ROUTING_SWEEP = _pywrapcp.RoutingModel_ROUTING_SWEEP
    ROUTING_FIRST_SOLUTION_STRATEGY_COUNTER = _pywrapcp.RoutingModel_ROUTING_FIRST_SOLUTION_STRATEGY_COUNTER
    ROUTING_GREEDY_DESCENT = _pywrapcp.RoutingModel_ROUTING_GREEDY_DESCENT
    ROUTING_GUIDED_LOCAL_SEARCH = _pywrapcp.RoutingModel_ROUTING_GUIDED_LOCAL_SEARCH
    ROUTING_SIMULATED_ANNEALING = _pywrapcp.RoutingModel_ROUTING_SIMULATED_ANNEALING
    ROUTING_TABU_SEARCH = _pywrapcp.RoutingModel_ROUTING_TABU_SEARCH
    ROUTING_NOT_SOLVED = _pywrapcp.RoutingModel_ROUTING_NOT_SOLVED
    ROUTING_SUCCESS = _pywrapcp.RoutingModel_ROUTING_SUCCESS
    ROUTING_FAIL = _pywrapcp.RoutingModel_ROUTING_FAIL
    ROUTING_FAIL_TIMEOUT = _pywrapcp.RoutingModel_ROUTING_FAIL_TIMEOUT
    def __init__(self, *args): 
        this = _pywrapcp.new_RoutingModel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pywrapcp.delete_RoutingModel
    __del__ = lambda self : None;
    __swig_getmethods__["SetGlobalParameters"] = lambda x: _pywrapcp.RoutingModel_SetGlobalParameters
    if _newclass:SetGlobalParameters = staticmethod(_pywrapcp.RoutingModel_SetGlobalParameters)
    def AddDimension(self, *args): return _pywrapcp.RoutingModel_AddDimension(self, *args)
    def AddDimensionWithVehicleTransits(self, *args): return _pywrapcp.RoutingModel_AddDimensionWithVehicleTransits(self, *args)
    def AddDimensionWithVehicleCapacity(self, *args): return _pywrapcp.RoutingModel_AddDimensionWithVehicleCapacity(self, *args)
    def AddDimensionWithVehicleTransitAndCapacity(self, *args): return _pywrapcp.RoutingModel_AddDimensionWithVehicleTransitAndCapacity(self, *args)
    def AddConstantDimension(self, *args): return _pywrapcp.RoutingModel_AddConstantDimension(self, *args)
    def AddMatrixDimension(self, *args): return _pywrapcp.RoutingModel_AddMatrixDimension(self, *args)
    def GetAllDimensions(self, *args): return _pywrapcp.RoutingModel_GetAllDimensions(self, *args)
    def HasDimension(self, *args): return _pywrapcp.RoutingModel_HasDimension(self, *args)
    def GetDimensionOrDie(self, *args): return _pywrapcp.RoutingModel_GetDimensionOrDie(self, *args)
    def GetMutableDimension(self, *args): return _pywrapcp.RoutingModel_GetMutableDimension(self, *args)
    def SetPrimaryConstrainedDimension(self, *args): return _pywrapcp.RoutingModel_SetPrimaryConstrainedDimension(self, *args)
    def GetPrimaryConstrainedDimension(self): return _pywrapcp.RoutingModel_GetPrimaryConstrainedDimension(self)
    def AddAllActive(self): return _pywrapcp.RoutingModel_AddAllActive(self)
    def AddDisjunction(self, *args): return _pywrapcp.RoutingModel_AddDisjunction(self, *args)
    def GetDisjunctionIndexFromNode(self, *args): return _pywrapcp.RoutingModel_GetDisjunctionIndexFromNode(self, *args)
    def GetDisjunctionIndexFromVariableIndex(self, *args): return _pywrapcp.RoutingModel_GetDisjunctionIndexFromVariableIndex(self, *args)
    def GetDisjunctionIndicesFromIndex(self, *args): return _pywrapcp.RoutingModel_GetDisjunctionIndicesFromIndex(self, *args)
    def GetDisjunctionPenalty(self, *args): return _pywrapcp.RoutingModel_GetDisjunctionPenalty(self, *args)
    def GetNumberOfDisjunctions(self): return _pywrapcp.RoutingModel_GetNumberOfDisjunctions(self)
    def AddPickupAndDelivery(self, *args): return _pywrapcp.RoutingModel_AddPickupAndDelivery(self, *args)
    def UnperformedPenalty(self, *args): return _pywrapcp.RoutingModel_UnperformedPenalty(self, *args)
    def UnperformedPenaltyOrValue(self, *args): return _pywrapcp.RoutingModel_UnperformedPenaltyOrValue(self, *args)
    def GetDepot(self): return _pywrapcp.RoutingModel_GetDepot(self)
    def SetDepot(self, *args): return _pywrapcp.RoutingModel_SetDepot(self, *args)
    def SetArcCostEvaluatorOfAllVehicles(self, *args): return _pywrapcp.RoutingModel_SetArcCostEvaluatorOfAllVehicles(self, *args)
    def SetArcCostEvaluatorOfVehicle(self, *args): return _pywrapcp.RoutingModel_SetArcCostEvaluatorOfVehicle(self, *args)
    def SetFixedCostOfAllVehicles(self, *args): return _pywrapcp.RoutingModel_SetFixedCostOfAllVehicles(self, *args)
    def SetFixedCostOfVehicle(self, *args): return _pywrapcp.RoutingModel_SetFixedCostOfVehicle(self, *args)
    def GetFixedCostOfVehicle(self, *args): return _pywrapcp.RoutingModel_GetFixedCostOfVehicle(self, *args)
    def first_solution_strategy(self): return _pywrapcp.RoutingModel_first_solution_strategy(self)
    def set_first_solution_strategy(self, *args): return _pywrapcp.RoutingModel_set_first_solution_strategy(self, *args)
    def SetFirstSolutionEvaluator(self, *args): return _pywrapcp.RoutingModel_SetFirstSolutionEvaluator(self, *args)
    def GetSelectedFirstSolutionStrategy(self): return _pywrapcp.RoutingModel_GetSelectedFirstSolutionStrategy(self)
    def AddLocalSearchOperator(self, *args): return _pywrapcp.RoutingModel_AddLocalSearchOperator(self, *args)
    def metaheuristic(self): return _pywrapcp.RoutingModel_metaheuristic(self)
    def set_metaheuristic(self, *args): return _pywrapcp.RoutingModel_set_metaheuristic(self, *args)
    def GetSelectedMetaheuristic(self): return _pywrapcp.RoutingModel_GetSelectedMetaheuristic(self)
    def AddSearchMonitor(self, *args): return _pywrapcp.RoutingModel_AddSearchMonitor(self, *args)
    def AddVariableMinimizedByFinalizer(self, *args): return _pywrapcp.RoutingModel_AddVariableMinimizedByFinalizer(self, *args)
    def AddVariableMaximizedByFinalizer(self, *args): return _pywrapcp.RoutingModel_AddVariableMaximizedByFinalizer(self, *args)
    def CloseModel(self): return _pywrapcp.RoutingModel_CloseModel(self)
    def Solve(self, assignment=None): return _pywrapcp.RoutingModel_Solve(self, assignment)
    def SolveWithParameters(self, *args): return _pywrapcp.RoutingModel_SolveWithParameters(self, *args)
    def ComputeLowerBound(self): return _pywrapcp.RoutingModel_ComputeLowerBound(self)
    def status(self): return _pywrapcp.RoutingModel_status(self)
    def ApplyLocks(self, *args): return _pywrapcp.RoutingModel_ApplyLocks(self, *args)
    def ApplyLocksToAllVehicles(self, *args): return _pywrapcp.RoutingModel_ApplyLocksToAllVehicles(self, *args)
    def PreAssignment(self): return _pywrapcp.RoutingModel_PreAssignment(self)
    def WriteAssignment(self, *args): return _pywrapcp.RoutingModel_WriteAssignment(self, *args)
    def ReadAssignment(self, *args): return _pywrapcp.RoutingModel_ReadAssignment(self, *args)
    def RestoreAssignment(self, *args): return _pywrapcp.RoutingModel_RestoreAssignment(self, *args)
    def ReadAssignmentFromRoutes(self, *args): return _pywrapcp.RoutingModel_ReadAssignmentFromRoutes(self, *args)
    def RoutesToAssignment(self, *args): return _pywrapcp.RoutingModel_RoutesToAssignment(self, *args)
    def AssignmentToRoutes(self, *args): return _pywrapcp.RoutingModel_AssignmentToRoutes(self, *args)
    def CompactAssignment(self, *args): return _pywrapcp.RoutingModel_CompactAssignment(self, *args)
    def AddToAssignment(self, *args): return _pywrapcp.RoutingModel_AddToAssignment(self, *args)
    def AddIntervalToAssignment(self, *args): return _pywrapcp.RoutingModel_AddIntervalToAssignment(self, *args)
    def AddLocalSearchFilter(self, *args): return _pywrapcp.RoutingModel_AddLocalSearchFilter(self, *args)
    def Start(self, *args): return _pywrapcp.RoutingModel_Start(self, *args)
    def End(self, *args): return _pywrapcp.RoutingModel_End(self, *args)
    def IsStart(self, *args): return _pywrapcp.RoutingModel_IsStart(self, *args)
    def IsEnd(self, *args): return _pywrapcp.RoutingModel_IsEnd(self, *args)
    def Next(self, *args): return _pywrapcp.RoutingModel_Next(self, *args)
    def IsVehicleUsed(self, *args): return _pywrapcp.RoutingModel_IsVehicleUsed(self, *args)
    def NextVar(self, *args): return _pywrapcp.RoutingModel_NextVar(self, *args)
    def ActiveVar(self, *args): return _pywrapcp.RoutingModel_ActiveVar(self, *args)
    def VehicleVar(self, *args): return _pywrapcp.RoutingModel_VehicleVar(self, *args)
    def CostVar(self): return _pywrapcp.RoutingModel_CostVar(self)
    def GetArcCostForVehicle(self, *args): return _pywrapcp.RoutingModel_GetArcCostForVehicle(self, *args)
    def CostsAreHomogeneousAcrossVehicles(self): return _pywrapcp.RoutingModel_CostsAreHomogeneousAcrossVehicles(self)
    def GetHomogeneousCost(self, *args): return _pywrapcp.RoutingModel_GetHomogeneousCost(self, *args)
    def GetArcCostForFirstSolution(self, *args): return _pywrapcp.RoutingModel_GetArcCostForFirstSolution(self, *args)
    def GetArcCostForClass(self, *args): return _pywrapcp.RoutingModel_GetArcCostForClass(self, *args)
    def GetCostClassIndexOfVehicle(self, *args): return _pywrapcp.RoutingModel_GetCostClassIndexOfVehicle(self, *args)
    def GetCostClassesCount(self): return _pywrapcp.RoutingModel_GetCostClassesCount(self)
    def GetNonZeroCostClassesCount(self): return _pywrapcp.RoutingModel_GetNonZeroCostClassesCount(self)
    def GetVehicleClassIndexOfVehicle(self, *args): return _pywrapcp.RoutingModel_GetVehicleClassIndexOfVehicle(self, *args)
    def GetVehicleClassesCount(self): return _pywrapcp.RoutingModel_GetVehicleClassesCount(self)
    def ArcIsMoreConstrainedThanArc(self, *args): return _pywrapcp.RoutingModel_ArcIsMoreConstrainedThanArc(self, *args)
    def DebugOutputAssignment(self, *args): return _pywrapcp.RoutingModel_DebugOutputAssignment(self, *args)
    def solver(self): return _pywrapcp.RoutingModel_solver(self)
    def nodes(self): return _pywrapcp.RoutingModel_nodes(self)
    def vehicles(self): return _pywrapcp.RoutingModel_vehicles(self)
    def Size(self): return _pywrapcp.RoutingModel_Size(self)
    def IndexToNode(self, *args): return _pywrapcp.RoutingModel_IndexToNode(self, *args)
    def NodeToIndex(self, *args): return _pywrapcp.RoutingModel_NodeToIndex(self, *args)
    def HasIndex(self, *args): return _pywrapcp.RoutingModel_HasIndex(self, *args)
    def TimeLimit(self): return _pywrapcp.RoutingModel_TimeLimit(self)
    def UpdateTimeLimit(self, *args): return _pywrapcp.RoutingModel_UpdateTimeLimit(self, *args)
    def UpdateLNSTimeLimit(self, *args): return _pywrapcp.RoutingModel_UpdateLNSTimeLimit(self, *args)
    def GetNumberOfDecisionsInFirstSolution(self): return _pywrapcp.RoutingModel_GetNumberOfDecisionsInFirstSolution(self)
    def GetNumberofRejectsInFirstSolution(self): return _pywrapcp.RoutingModel_GetNumberofRejectsInFirstSolution(self)
    __swig_getmethods__["RoutingStrategyName"] = lambda x: _pywrapcp.RoutingModel_RoutingStrategyName
    if _newclass:RoutingStrategyName = staticmethod(_pywrapcp.RoutingModel_RoutingStrategyName)
    __swig_getmethods__["ParseRoutingStrategy"] = lambda x: _pywrapcp.RoutingModel_ParseRoutingStrategy
    if _newclass:ParseRoutingStrategy = staticmethod(_pywrapcp.RoutingModel_ParseRoutingStrategy)
    __swig_getmethods__["RoutingMetaheuristicName"] = lambda x: _pywrapcp.RoutingModel_RoutingMetaheuristicName
    if _newclass:RoutingMetaheuristicName = staticmethod(_pywrapcp.RoutingModel_RoutingMetaheuristicName)
    __swig_getmethods__["ParseRoutingMetaheuristic"] = lambda x: _pywrapcp.RoutingModel_ParseRoutingMetaheuristic
    if _newclass:ParseRoutingMetaheuristic = staticmethod(_pywrapcp.RoutingModel_ParseRoutingMetaheuristic)
    def SetCost(self, *args): return _pywrapcp.RoutingModel_SetCost(self, *args)
    def SetVehicleCost(self, *args): return _pywrapcp.RoutingModel_SetVehicleCost(self, *args)
    def GetRouteFixedCost(self): return _pywrapcp.RoutingModel_GetRouteFixedCost(self)
    def SetRouteFixedCost(self, *args): return _pywrapcp.RoutingModel_SetRouteFixedCost(self, *args)
    def GetVehicleFixedCost(self, *args): return _pywrapcp.RoutingModel_GetVehicleFixedCost(self, *args)
    def SetVehicleFixedCost(self, *args): return _pywrapcp.RoutingModel_SetVehicleFixedCost(self, *args)
    def homogeneous_costs(self): return _pywrapcp.RoutingModel_homogeneous_costs(self)
    def GetVehicleCostCount(self): return _pywrapcp.RoutingModel_GetVehicleCostCount(self)
    def GetCost(self, *args): return _pywrapcp.RoutingModel_GetCost(self, *args)
    def GetVehicleClassCost(self, *args): return _pywrapcp.RoutingModel_GetVehicleClassCost(self, *args)
    def SetDimensionTransitCost(self, *args): return _pywrapcp.RoutingModel_SetDimensionTransitCost(self, *args)
    def GetDimensionTransitCost(self, *args): return _pywrapcp.RoutingModel_GetDimensionTransitCost(self, *args)
    def SetDimensionSpanCost(self, *args): return _pywrapcp.RoutingModel_SetDimensionSpanCost(self, *args)
    def GetDimensionSpanCost(self, *args): return _pywrapcp.RoutingModel_GetDimensionSpanCost(self, *args)
    def GetTransitValue(self, *args): return _pywrapcp.RoutingModel_GetTransitValue(self, *args)
    def CumulVar(self, *args): return _pywrapcp.RoutingModel_CumulVar(self, *args)
    def TransitVar(self, *args): return _pywrapcp.RoutingModel_TransitVar(self, *args)
    def SlackVar(self, *args): return _pywrapcp.RoutingModel_SlackVar(self, *args)
    def SetCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingModel_SetCumulVarSoftUpperBound(self, *args)
    def HasCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingModel_HasCumulVarSoftUpperBound(self, *args)
    def GetCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingModel_GetCumulVarSoftUpperBound(self, *args)
    def GetCumulVarSoftUpperBoundCoefficient(self, *args): return _pywrapcp.RoutingModel_GetCumulVarSoftUpperBoundCoefficient(self, *args)
    def SetStartCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingModel_SetStartCumulVarSoftUpperBound(self, *args)
    def HasStartCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingModel_HasStartCumulVarSoftUpperBound(self, *args)
    def GetStartCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingModel_GetStartCumulVarSoftUpperBound(self, *args)
    def GetStartCumulVarSoftUpperBoundCoefficient(self, *args): return _pywrapcp.RoutingModel_GetStartCumulVarSoftUpperBoundCoefficient(self, *args)
    def SetEndCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingModel_SetEndCumulVarSoftUpperBound(self, *args)
    def HasEndCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingModel_HasEndCumulVarSoftUpperBound(self, *args)
    def GetEndCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingModel_GetEndCumulVarSoftUpperBound(self, *args)
    def GetEndCumulVarSoftUpperBoundCoefficient(self, *args): return _pywrapcp.RoutingModel_GetEndCumulVarSoftUpperBoundCoefficient(self, *args)
    def AddVectorDimension(self, *args): return _pywrapcp.RoutingModel_AddVectorDimension(self, *args)
RoutingModel_swigregister = _pywrapcp.RoutingModel_swigregister
RoutingModel_swigregister(RoutingModel)
cvar = _pywrapcp.cvar
RoutingModel.kFirstNode = _pywrapcp.cvar.RoutingModel_kFirstNode
RoutingModel.kInvalidNodeIndex = _pywrapcp.cvar.RoutingModel_kInvalidNodeIndex
RoutingModel.kNoDisjunction = _pywrapcp.cvar.RoutingModel_kNoDisjunction
RoutingModel.kNoDimension = _pywrapcp.cvar.RoutingModel_kNoDimension

def RoutingModel_SetGlobalParameters(*args):
  return _pywrapcp.RoutingModel_SetGlobalParameters(*args)
RoutingModel_SetGlobalParameters = _pywrapcp.RoutingModel_SetGlobalParameters

def RoutingModel_RoutingStrategyName(*args):
  return _pywrapcp.RoutingModel_RoutingStrategyName(*args)
RoutingModel_RoutingStrategyName = _pywrapcp.RoutingModel_RoutingStrategyName

def RoutingModel_ParseRoutingStrategy(*args):
  return _pywrapcp.RoutingModel_ParseRoutingStrategy(*args)
RoutingModel_ParseRoutingStrategy = _pywrapcp.RoutingModel_ParseRoutingStrategy

def RoutingModel_RoutingMetaheuristicName(*args):
  return _pywrapcp.RoutingModel_RoutingMetaheuristicName(*args)
RoutingModel_RoutingMetaheuristicName = _pywrapcp.RoutingModel_RoutingMetaheuristicName

def RoutingModel_ParseRoutingMetaheuristic(*args):
  return _pywrapcp.RoutingModel_ParseRoutingMetaheuristic(*args)
RoutingModel_ParseRoutingMetaheuristic = _pywrapcp.RoutingModel_ParseRoutingMetaheuristic

class RoutingDimension(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RoutingDimension, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RoutingDimension, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def GetTransitValue(self, *args): return _pywrapcp.RoutingDimension_GetTransitValue(self, *args)
    def CumulVar(self, *args): return _pywrapcp.RoutingDimension_CumulVar(self, *args)
    def TransitVar(self, *args): return _pywrapcp.RoutingDimension_TransitVar(self, *args)
    def SlackVar(self, *args): return _pywrapcp.RoutingDimension_SlackVar(self, *args)
    def SetSpanUpperBoundForVehicle(self, *args): return _pywrapcp.RoutingDimension_SetSpanUpperBoundForVehicle(self, *args)
    def SetSpanCostCoefficientForVehicle(self, *args): return _pywrapcp.RoutingDimension_SetSpanCostCoefficientForVehicle(self, *args)
    def SetSpanCostCoefficientForAllVehicles(self, *args): return _pywrapcp.RoutingDimension_SetSpanCostCoefficientForAllVehicles(self, *args)
    def SetGlobalSpanCostCoefficient(self, *args): return _pywrapcp.RoutingDimension_SetGlobalSpanCostCoefficient(self, *args)
    def SetCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingDimension_SetCumulVarSoftUpperBound(self, *args)
    def SetStartCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingDimension_SetStartCumulVarSoftUpperBound(self, *args)
    def SetEndCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingDimension_SetEndCumulVarSoftUpperBound(self, *args)
    def SetCumulVarSoftUpperBoundFromIndex(self, *args): return _pywrapcp.RoutingDimension_SetCumulVarSoftUpperBoundFromIndex(self, *args)
    def HasCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingDimension_HasCumulVarSoftUpperBound(self, *args)
    def HasStartCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingDimension_HasStartCumulVarSoftUpperBound(self, *args)
    def HasEndCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingDimension_HasEndCumulVarSoftUpperBound(self, *args)
    def HasCumulVarSoftUpperBoundFromIndex(self, *args): return _pywrapcp.RoutingDimension_HasCumulVarSoftUpperBoundFromIndex(self, *args)
    def GetCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingDimension_GetCumulVarSoftUpperBound(self, *args)
    def GetStartCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingDimension_GetStartCumulVarSoftUpperBound(self, *args)
    def GetEndCumulVarSoftUpperBound(self, *args): return _pywrapcp.RoutingDimension_GetEndCumulVarSoftUpperBound(self, *args)
    def GetCumulVarSoftUpperBoundFromIndex(self, *args): return _pywrapcp.RoutingDimension_GetCumulVarSoftUpperBoundFromIndex(self, *args)
    def GetCumulVarSoftUpperBoundCoefficient(self, *args): return _pywrapcp.RoutingDimension_GetCumulVarSoftUpperBoundCoefficient(self, *args)
    def GetStartCumulVarSoftUpperBoundCoefficient(self, *args): return _pywrapcp.RoutingDimension_GetStartCumulVarSoftUpperBoundCoefficient(self, *args)
    def GetEndCumulVarSoftUpperBoundCoefficient(self, *args): return _pywrapcp.RoutingDimension_GetEndCumulVarSoftUpperBoundCoefficient(self, *args)
    def GetCumulVarSoftUpperBoundCoefficientFromIndex(self, *args): return _pywrapcp.RoutingDimension_GetCumulVarSoftUpperBoundCoefficientFromIndex(self, *args)
    def SetCumulVarSoftLowerBound(self, *args): return _pywrapcp.RoutingDimension_SetCumulVarSoftLowerBound(self, *args)
    def SetStartCumulVarSoftLowerBound(self, *args): return _pywrapcp.RoutingDimension_SetStartCumulVarSoftLowerBound(self, *args)
    def SetEndCumulVarSoftLowerBound(self, *args): return _pywrapcp.RoutingDimension_SetEndCumulVarSoftLowerBound(self, *args)
    def SetCumulVarSoftLowerBoundFromIndex(self, *args): return _pywrapcp.RoutingDimension_SetCumulVarSoftLowerBoundFromIndex(self, *args)
    def HasCumulVarSoftLowerBound(self, *args): return _pywrapcp.RoutingDimension_HasCumulVarSoftLowerBound(self, *args)
    def HasStartCumulVarSoftLowerBound(self, *args): return _pywrapcp.RoutingDimension_HasStartCumulVarSoftLowerBound(self, *args)
    def HasEndCumulVarSoftLowerBound(self, *args): return _pywrapcp.RoutingDimension_HasEndCumulVarSoftLowerBound(self, *args)
    def HasCumulVarSoftLowerBoundFromIndex(self, *args): return _pywrapcp.RoutingDimension_HasCumulVarSoftLowerBoundFromIndex(self, *args)
    def GetCumulVarSoftLowerBound(self, *args): return _pywrapcp.RoutingDimension_GetCumulVarSoftLowerBound(self, *args)
    def GetStartCumulVarSoftLowerBound(self, *args): return _pywrapcp.RoutingDimension_GetStartCumulVarSoftLowerBound(self, *args)
    def GetEndCumulVarSoftLowerBound(self, *args): return _pywrapcp.RoutingDimension_GetEndCumulVarSoftLowerBound(self, *args)
    def GetCumulVarSoftLowerBoundFromIndex(self, *args): return _pywrapcp.RoutingDimension_GetCumulVarSoftLowerBoundFromIndex(self, *args)
    def GetCumulVarSoftLowerBoundCoefficient(self, *args): return _pywrapcp.RoutingDimension_GetCumulVarSoftLowerBoundCoefficient(self, *args)
    def GetStartCumulVarSoftLowerBoundCoefficient(self, *args): return _pywrapcp.RoutingDimension_GetStartCumulVarSoftLowerBoundCoefficient(self, *args)
    def GetEndCumulVarSoftLowerBoundCoefficient(self, *args): return _pywrapcp.RoutingDimension_GetEndCumulVarSoftLowerBoundCoefficient(self, *args)
    def GetCumulVarSoftLowerBoundCoefficientFromIndex(self, *args): return _pywrapcp.RoutingDimension_GetCumulVarSoftLowerBoundCoefficientFromIndex(self, *args)
    def name(self): return _pywrapcp.RoutingDimension_name(self)
    def GetSpanUpperBoundForVehicle(self, *args): return _pywrapcp.RoutingDimension_GetSpanUpperBoundForVehicle(self, *args)
    def GetSpanCostCoefficientForVehicle(self, *args): return _pywrapcp.RoutingDimension_GetSpanCostCoefficientForVehicle(self, *args)
    def global_span_cost_coefficient(self): return _pywrapcp.RoutingDimension_global_span_cost_coefficient(self)
    __swig_destroy__ = _pywrapcp.delete_RoutingDimension
    __del__ = lambda self : None;
RoutingDimension_swigregister = _pywrapcp.RoutingDimension_swigregister
RoutingDimension_swigregister(RoutingDimension)

class IntVarFilteredDecisionBuilder(DecisionBuilder):
    __swig_setmethods__ = {}
    for _s in [DecisionBuilder]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVarFilteredDecisionBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [DecisionBuilder]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntVarFilteredDecisionBuilder, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_IntVarFilteredDecisionBuilder
    __del__ = lambda self : None;
    def Next(self, *args): return _pywrapcp.IntVarFilteredDecisionBuilder_Next(self, *args)
    def BuildSolution(self): return _pywrapcp.IntVarFilteredDecisionBuilder_BuildSolution(self)
    def number_of_decisions(self): return _pywrapcp.IntVarFilteredDecisionBuilder_number_of_decisions(self)
    def number_of_rejects(self): return _pywrapcp.IntVarFilteredDecisionBuilder_number_of_rejects(self)
IntVarFilteredDecisionBuilder_swigregister = _pywrapcp.IntVarFilteredDecisionBuilder_swigregister
IntVarFilteredDecisionBuilder_swigregister(IntVarFilteredDecisionBuilder)

class RoutingFilteredDecisionBuilder(IntVarFilteredDecisionBuilder):
    __swig_setmethods__ = {}
    for _s in [IntVarFilteredDecisionBuilder]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RoutingFilteredDecisionBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [IntVarFilteredDecisionBuilder]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RoutingFilteredDecisionBuilder, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_RoutingFilteredDecisionBuilder
    __del__ = lambda self : None;
    def model(self): return _pywrapcp.RoutingFilteredDecisionBuilder_model(self)
    def InitializeRoutes(self): return _pywrapcp.RoutingFilteredDecisionBuilder_InitializeRoutes(self)
    def GetStartChainEnd(self, *args): return _pywrapcp.RoutingFilteredDecisionBuilder_GetStartChainEnd(self, *args)
    def MakeDisjunctionNodesUnperformed(self, *args): return _pywrapcp.RoutingFilteredDecisionBuilder_MakeDisjunctionNodesUnperformed(self, *args)
    def MakeUnassignedNodesUnperformed(self): return _pywrapcp.RoutingFilteredDecisionBuilder_MakeUnassignedNodesUnperformed(self)
RoutingFilteredDecisionBuilder_swigregister = _pywrapcp.RoutingFilteredDecisionBuilder_swigregister
RoutingFilteredDecisionBuilder_swigregister(RoutingFilteredDecisionBuilder)

class CheapestInsertionFilteredDecisionBuilder(RoutingFilteredDecisionBuilder):
    __swig_setmethods__ = {}
    for _s in [RoutingFilteredDecisionBuilder]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CheapestInsertionFilteredDecisionBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [RoutingFilteredDecisionBuilder]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CheapestInsertionFilteredDecisionBuilder, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_CheapestInsertionFilteredDecisionBuilder
    __del__ = lambda self : None;
CheapestInsertionFilteredDecisionBuilder_swigregister = _pywrapcp.CheapestInsertionFilteredDecisionBuilder_swigregister
CheapestInsertionFilteredDecisionBuilder_swigregister(CheapestInsertionFilteredDecisionBuilder)

class GlobalCheapestInsertionFilteredDecisionBuilder(CheapestInsertionFilteredDecisionBuilder):
    __swig_setmethods__ = {}
    for _s in [CheapestInsertionFilteredDecisionBuilder]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GlobalCheapestInsertionFilteredDecisionBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [CheapestInsertionFilteredDecisionBuilder]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GlobalCheapestInsertionFilteredDecisionBuilder, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_GlobalCheapestInsertionFilteredDecisionBuilder
    __del__ = lambda self : None;
    def BuildSolution(self): return _pywrapcp.GlobalCheapestInsertionFilteredDecisionBuilder_BuildSolution(self)
GlobalCheapestInsertionFilteredDecisionBuilder_swigregister = _pywrapcp.GlobalCheapestInsertionFilteredDecisionBuilder_swigregister
GlobalCheapestInsertionFilteredDecisionBuilder_swigregister(GlobalCheapestInsertionFilteredDecisionBuilder)

class LocalCheapestInsertionFilteredDecisionBuilder(CheapestInsertionFilteredDecisionBuilder):
    __swig_setmethods__ = {}
    for _s in [CheapestInsertionFilteredDecisionBuilder]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalCheapestInsertionFilteredDecisionBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [CheapestInsertionFilteredDecisionBuilder]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LocalCheapestInsertionFilteredDecisionBuilder, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_LocalCheapestInsertionFilteredDecisionBuilder
    __del__ = lambda self : None;
    def BuildSolution(self): return _pywrapcp.LocalCheapestInsertionFilteredDecisionBuilder_BuildSolution(self)
LocalCheapestInsertionFilteredDecisionBuilder_swigregister = _pywrapcp.LocalCheapestInsertionFilteredDecisionBuilder_swigregister
LocalCheapestInsertionFilteredDecisionBuilder_swigregister(LocalCheapestInsertionFilteredDecisionBuilder)

class CheapestAdditionFilteredDecisionBuilder(RoutingFilteredDecisionBuilder):
    __swig_setmethods__ = {}
    for _s in [RoutingFilteredDecisionBuilder]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CheapestAdditionFilteredDecisionBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [RoutingFilteredDecisionBuilder]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CheapestAdditionFilteredDecisionBuilder, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_CheapestAdditionFilteredDecisionBuilder
    __del__ = lambda self : None;
    def BuildSolution(self): return _pywrapcp.CheapestAdditionFilteredDecisionBuilder_BuildSolution(self)
CheapestAdditionFilteredDecisionBuilder_swigregister = _pywrapcp.CheapestAdditionFilteredDecisionBuilder_swigregister
CheapestAdditionFilteredDecisionBuilder_swigregister(CheapestAdditionFilteredDecisionBuilder)

class EvaluatorCheapestAdditionFilteredDecisionBuilder(CheapestAdditionFilteredDecisionBuilder):
    __swig_setmethods__ = {}
    for _s in [CheapestAdditionFilteredDecisionBuilder]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EvaluatorCheapestAdditionFilteredDecisionBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [CheapestAdditionFilteredDecisionBuilder]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EvaluatorCheapestAdditionFilteredDecisionBuilder, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_EvaluatorCheapestAdditionFilteredDecisionBuilder
    __del__ = lambda self : None;
EvaluatorCheapestAdditionFilteredDecisionBuilder_swigregister = _pywrapcp.EvaluatorCheapestAdditionFilteredDecisionBuilder_swigregister
EvaluatorCheapestAdditionFilteredDecisionBuilder_swigregister(EvaluatorCheapestAdditionFilteredDecisionBuilder)

class ComparatorCheapestAdditionFilteredDecisionBuilder(CheapestAdditionFilteredDecisionBuilder):
    __swig_setmethods__ = {}
    for _s in [CheapestAdditionFilteredDecisionBuilder]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComparatorCheapestAdditionFilteredDecisionBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [CheapestAdditionFilteredDecisionBuilder]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ComparatorCheapestAdditionFilteredDecisionBuilder, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_ComparatorCheapestAdditionFilteredDecisionBuilder
    __del__ = lambda self : None;
ComparatorCheapestAdditionFilteredDecisionBuilder_swigregister = _pywrapcp.ComparatorCheapestAdditionFilteredDecisionBuilder_swigregister
ComparatorCheapestAdditionFilteredDecisionBuilder_swigregister(ComparatorCheapestAdditionFilteredDecisionBuilder)

class SavingsFilteredDecisionBuilder(RoutingFilteredDecisionBuilder):
    __swig_setmethods__ = {}
    for _s in [RoutingFilteredDecisionBuilder]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SavingsFilteredDecisionBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [RoutingFilteredDecisionBuilder]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SavingsFilteredDecisionBuilder, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_SavingsFilteredDecisionBuilder
    __del__ = lambda self : None;
    def BuildSolution(self): return _pywrapcp.SavingsFilteredDecisionBuilder_BuildSolution(self)
SavingsFilteredDecisionBuilder_swigregister = _pywrapcp.SavingsFilteredDecisionBuilder_swigregister
SavingsFilteredDecisionBuilder_swigregister(SavingsFilteredDecisionBuilder)

class RoutingLocalSearchFilter(IntVarLocalSearchFilter):
    __swig_setmethods__ = {}
    for _s in [IntVarLocalSearchFilter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RoutingLocalSearchFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [IntVarLocalSearchFilter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RoutingLocalSearchFilter, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_RoutingLocalSearchFilter
    __del__ = lambda self : None;
    def InjectObjectiveValue(self, *args): return _pywrapcp.RoutingLocalSearchFilter_InjectObjectiveValue(self, *args)
RoutingLocalSearchFilter_swigregister = _pywrapcp.RoutingLocalSearchFilter_swigregister
RoutingLocalSearchFilter_swigregister(RoutingLocalSearchFilter)

class BasePathFilter(RoutingLocalSearchFilter):
    __swig_setmethods__ = {}
    for _s in [RoutingLocalSearchFilter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BasePathFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [RoutingLocalSearchFilter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BasePathFilter, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_BasePathFilter
    __del__ = lambda self : None;
    def Accept(self, *args): return _pywrapcp.BasePathFilter_Accept(self, *args)
    def OnSynchronize(self, *args): return _pywrapcp.BasePathFilter_OnSynchronize(self, *args)
BasePathFilter_swigregister = _pywrapcp.BasePathFilter_swigregister
BasePathFilter_swigregister(BasePathFilter)


def MakeNodeDisjunctionFilter(*args):
  return _pywrapcp.MakeNodeDisjunctionFilter(*args)
MakeNodeDisjunctionFilter = _pywrapcp.MakeNodeDisjunctionFilter

def MakePathCumulFilter(*args):
  return _pywrapcp.MakePathCumulFilter(*args)
MakePathCumulFilter = _pywrapcp.MakePathCumulFilter

def MakeNodePrecedenceFilter(*args):
  return _pywrapcp.MakeNodePrecedenceFilter(*args)
MakeNodePrecedenceFilter = _pywrapcp.MakeNodePrecedenceFilter

def MakeVehicleVarFilter(*args):
  return _pywrapcp.MakeVehicleVarFilter(*args)
MakeVehicleVarFilter = _pywrapcp.MakeVehicleVarFilter
# This file is compatible with both classic and new-style classes.


