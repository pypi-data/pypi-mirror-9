Mind 0.2.4 Tutorial
=================================
.. note::
   This tutorial covers using each module one by one but it doesn't cover making game with entire library.

Mind.Knowledge
-----------------------------------------------------
Knowledge is part of Mind for saving data (with *.knw* extension)

.. note::

   This module currently isn't *very* useful (mostly because of bugs) but it might be soon.

For beginning import Knowledge:

>>> from Mind import Knowledge

Then initialize *basic class for saving data*:

>>> data = Knowledge.Knowledge("test")

Then try this few lines (these adds data to data class):

>>> data['player'] = 5
>>> data[25] = 8
>>> data[21.753] = 'exit'
>>> data["something"] = [1, "X", [12.3, "Y"], 3]
>>> data
21.753 : exit
player : 5
something : [1, 'X', [12.3, 'Y'], 3]
25 : 8
>>> data[25]
8

Now try to save data and load:

>>> data.save_data()
>>> data = Knowledge.load("test")
>>> data
something : [1, 'X', [12.32, 'Y'], 3]
25 : 8
21.793000000000006 : exit
player : 5

.. warning::

   Saving decimal numbers isn't very correct and maximum is 3 decimals!

.. seealso::
   Mind.Test.

Mind.Orientation
--------------------------------------------
Orientation is part of library for maps.

At begining:

>>> from Mind import Orientation

We could first create map:

>>> Map = Orientation.MAP(1000, 1000)

Then we could add few points:

>>> A = Orientation.point(100, 100, Map, "A")
>>> B = Orientation.point(200, 200, Map, "B")
>>> C = Orientation.point(300, 200, Map, "C")

.. Note::
   If point is placed out of Map (here 1000 *width* and 1000 *height*) it will cause **MapError**!

When point is created it automatically goes to map. Test it:

>>> print(Map)
Map 1000x1000:
1. A @ 100, 100
2. B @ 200, 200
3. C @ 300, 200

We could add some group of points:

>>> Group1 = Orientation.group_of_points(Map, "Some", B, C)

And try to print Map now:

>>> print(Map)
Map 1000x1000:
1. A @ 100, 100
2. B @ 200, 200
3. C @ 300, 200
4. Some group [B @ 200, 200; C @ 300, 200]

If we want for points (or any other map object) to not add to Map, we should set quiet to True (*e.g.:* ``point(400, 300, Map, quiet=True)``).

Now it's time for some rects:

>>> Rect1 = Orientation.rect(100, 100, 100, 100, Map)
>>> print(Map)
1. A @ 100, 100
2. Some group [B @ 200, 200; C @ 300, 200]
3. B @ 200, 200
4. C @ 300, 200
5. Unknown rect 100X100 @ 100, 100

Rects support some interesting things:

>>> A in Rect1
True
>>> B in Rect1
True
>>> C in Rect1
False
>>> Group1 in Rect1
False
>>> Orientation.group_of_points(Map, "Some", A, B) in Rect1
True
>>> Rect1 in Rect1
True
>>> Orientation.rect(150, 100, 100, 100, Map) in Rect1
False

I think you got the point but in case you didn't:
    - If point is in inside rect **or** on edges of rect then ``point in rect`` is ``True``.
    - If ``point in rect`` is True for **all** points in group_of_points then ``group_of_points in rect`` is ``True``.
    - If **all** parts of rect1 are in rect2 then ``rect1 in rect2`` is ``True``.
    - In all examples if it isn't ``True`` it's ``False``.

Library for now also has ``line``, ``line-seg``, ``ray``, and ``direction`` classes but they still don't have support in Tiled maps loading, so this tutorial doesn't cover them.

Important thing is ``ext_obj`` class. It's any Map object but with some additional properties:

>>> p1 = Orientation.ext_obj(point(10, 10, Map, "some", quiet=True), "weird", "very strange", type="non-normal")

Now you may ask why do you need all that? You maybe think: "*It would probably be better if I do my map exactly for my game, only map loading is problem.*"

Because of that I will now start explaining using *Tiled* map (*.tmx* extension).

.. Note::
   For following examples you need to have `tiledtmxloader`_ if you don't have it some classes won't initialize

.. _tiledtmxloader: http://www.pygame.org/project-map+loader+for+%27tiled%27-1158-.html

We probably need to set the map:

>>> Map = Orientation.tiled_map("first_level")
<tiledtmxloader.tmxreader.TileSet object at 0x01C9B3D0>
SpriteLayer: Sprite Cache hits: 0

Now we could print map (I will show just beginning of output because it have 103 lines):

>>> print(Map)
1. Unknown rect 20X500 @ 0, 0; {type: None}
2. Unknown rect 1980X20 @ 20, 0; {type: None}
3. Unknown rect 1980X20 @ 20, 480; {type: None}

You may notice that print output looks like Map print output and all objects are converted to ``ext_obj``.

I think it's best to **not** work in python shell.

We should first create main pygame loop (It doesn't use Mind but we'll need it), something like this:

.. literalinclude:: pro_1-p.py

I asume that you understand everything in that code.

Next we should add Map initialization and Map blitting:

.. literalinclude:: pro_1-1.py
   :linenos:
   :emphasize-lines: 8,10,20

Line 8: We loaded map from file *first_level.tmx* ( *.tmx* extension automatically added by programm).

Line 10: We seted our screen from line 6 to the Map

Line 20: Programm blits Map.

Now we have camera with center on point (0, 0) of the map (uper left corner).

But what if we want to have camera somewhere else? Then we should set map *position*:

.. literalinclude:: pro_1-2.py
   :linenos:
   :emphasize-lines: 12

Line 12: We set center position of camera to *200, 200*.

If you edge is ``True`` in ``Map.set_camera_pos`` (which is by default) then map won't be blitted outside the edges.

If we want to have map which will move when we press arrows we need to use *moving_map*:

.. literalinclude:: pro_1-3.py
   :linenos:
   :emphasize-lines: 8

Line 15: We changed Map class to ``moving_map``

For moving map we need ``Map.move(x, y)``:

.. literalinclude:: pro_1-4.py
   :linenos:
   :emphasize-lines: 16-24

Besides we added title in line 6, we seted that when pressing *UP* map *y* decreases for 10 and so on.

Now try to move map.

Left and right works but up doesn't.
That's because in begining Map center is in point (500, 500) and when you press key up it's in point (500, 490) but it looks same because in both situations map would be blitted out of Map but it automatically blits on edge.

We should use ``set_position()`` and ``get_camera_pos()`` methods for fixing that:

.. literalinclude:: pro_1-5.py
   :linenos:
   :emphasize-lines: 10, 27

Line 10: We define that center of map is center of map inside the edges.

Line 26: Like in line 9, but this line executes while game is running.

Now it's time for some object to appear. We'll define it as letter 'A':

.. literalinclude:: pro_1-6.py
   :linenos:
   :emphasize-lines: 13-15, 24, 26, 28, 30, 32, 37

Lines 13-15: Initialization of object.

Lines 24, 26, 28, 30: Instead of moving map we move object.

Line 32: Sets player pos as map center position.

Line 37: Blits player onto screen.

.. note::
   We don't need :py:class:`Mind.Orientation.moving_map` anymore and in further examples it will be replaced with :py:class:`Mind.Orientation.tiled_map`.

Map initialization has got some more advenced options but I'm not going to show them because they aren't necessary.

.. note::
   I might extend this tutorial (for Mind.Orientation), but feel free to extend this tutorial (and send me source) or create completely new tutorial.

Mind.Imagination
--------------------------------------------------------
Imagination is part of library for Main Menu.

.. note::
   Because this all classes need pygame initialization, it would be pointless to do this in shell.

I supose you have code similiar to this (and understand it):

.. literalinclude:: pro_2-p.py

Next step would be code like this:

.. literalinclude:: pro_2-1.py
   :emphasize-lines: 11-18,21,22,26
   :linenos:

Line 11: We create Main Menu which is on active place (but that place doesn't matter because it's only one) and has 150 pixels between each option (but it currently doesn't have options).

Lines 12-13: We get keyboard from Main Menu and then add ``(pygame.K_ESCAPE, "quit")`` to it. So basically if we press *esc* ``keyboard["quit"]`` would be ``True`` .

Lines 15-17: We add option to Main Menu which uses font from line 9, have text "Start", is red, it's Main Menu is one from line 11 and is option on which index is. And we also add two similar options with some different attributes.

Line 18: We finish our options defining. You don't have to know what this does but it must be on end of options defining.

Lines 21-22: If keyboard *quit* is on (so if we pressed esc) then game will stop running.

Line 26: Main Menu blits on screen.

When you run it and hit space/enter one option will disappear. If you press *ecs* game quits.

If we want options to become black when index come to option we could do this:

.. literalinclude:: pro_2-2.py
   :emphasize-lines: 15-17
   :linenos:

Basically when index come to option its color changes to *0, 0, 0* (black).

But when index is not on option it's still black, so we should define what happens when we go away from option.
To do this we need *anti_pos_do* attribute:

.. literalinclude:: pro_2-3.py
   :emphasize-lines: 15-17
   :linenos:

Now it's time to add Game object. It is object can change which menu will be blitted.

.. literalinclude:: pro_2-4.py
   :emphasize-lines: 10-12, 23, 25, 27, 31
   :linenos:

Line 10: Now we need that place multiple times.

Line 12: We initialize game object with default place to ``Places[0]``. We also use ``Places[0]`` for Main menu in line 14.

Line 23: We set Game`` as Main_menu game.

Lines 25 and 27: We use Game running instead of our.

Now we will add that game exits when we press quit:

.. literalinclude:: pro_2-5.py
   :emphasize-lines: 20
   :linenos:

We define on line 20 that when we press quit game quits. Note that it's not same as ``Game.kill()`` on line 27 because of way of execution (it's complicated, but just don't use ``Game.kill()`` in option or ``Imagination.Quit`` outside option). Also for this ability you need to have lines: 12, 23 and 25.

We will now add option menu. If we have two menues we should have places and second place should be off.

.. literalinclude:: pro_2-6.py
   :emphasize-lines: 10, 25-30
   :linenos:

Line 10: Now we need two places.

Line 25: We create Options menu just like Main Menu, but this is on second place and have keyboard from Main Menu.

Lines 26-30: Just like in Main Menu, Back option have link to first place.

For now this turtorial ended, next version will probably have some new things.

.. note::
   Althrought I will continue writting this tutorial, you may expand it or create completely new tutorial (your will probably be way better) and send me link (*jakov.manjkas@gmail.com*).