% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{SpectralToolbox Documentation}
\date{December 16, 2014}
\release{0.1a}
\author{Daniele Bigoni}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:
\phantomsection\label{index:module-SpectralToolbox}\index{SpectralToolbox (module)}

\bigskip\hrule{}\bigskip


Created on Thu Mar 29 11:33:32 2012

@author: Daniele Bigoni (\href{mailto:dabi@imm.dtu.dk}{dabi@imm.dtu.dk})


\chapter{Description}
\label{index:description}\label{index:welcome-to-spectraltoolbox-s-documentation}
Implementation of Spectral Methods in 1 dimension.
\begin{description}
\item[{Available polynomials:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[index:ref-jacobi]{\emph{Jacobi Polynomials}}} or \code{Spectral1D.JACOBI}

\item {} 
Hermite Physicist or \code{Spectral1D.HERMITEP}

\item {} 
Hermite Function or \code{Spectral1D.HERMITEF}

\item {} 
Hermite Probabilistic or \code{Spectral1D.HERMITEP\_PROB}

\item {} 
Laguerre Polynomial or \code{Spectral1D.LAGUERREP}

\item {} 
Laguerre Function or \code{Spectral1D.LAGUERREF}

\item {} 
ORTHPOL package (generation of recursion coefficients using \footnote{\begin{enumerate}
\setcounter{enumi}{22}
\item {} 
Gautschi, ``Algorithm 726: ORTHPOL -- a package of routines for generating orthogonal polynomials and Gauss-type quadrature rules''. ACM Trans. Math. Softw., vol. 20, issue 1, pp. 21-62, 1994

\end{enumerate}
})  or \code{Spectral1D.ORTHPOL}

\end{itemize}

\item[{Available quadrature rules (related to selected polynomials):}] \leavevmode\begin{itemize}
\item {} 
Gauss or \code{Spectral1D.GAUSS}

\item {} 
Gauss-Lobatto or \code{Spectral1D.GAUSSLOBATTO}

\item {} 
Gauss-Radau or \code{Spectral1D.GAUSSRADAU}

\end{itemize}

\item[{Available quadrature rules (without polynomial selection):}] \leavevmode\begin{itemize}
\item {} 
Kronrod-Patterson on the real line or \code{Spectral1D.KPN} (function \code{Spectral1D.kpn(n)})

\item {} 
Kronrod-Patterson uniform or \code{Spectral1D.KPU} (function \code{Spectral1D.kpu(n)})

\item {} 
Clenshaw-Curtis or \code{Spectral1D.CC} (function \code{Spectral1D.cc(n)})

\item {} 
Fejer's or \code{Spectral1D.FEJ} (function \code{Spectral1D.fej(n)})

\end{itemize}

\end{description}


\section{Jacobi Polynomials}
\label{index:jacobi-polynomials}\label{index:ref-jacobi}
Jacobi polynomials are defined on the domain \(\Omega=[-1,1]\) by the recurrence relation
\begin{gather}
\begin{split}xP^{(\alpha,\beta)}_n(x) =    & \frac{2(n+1)(n+\alpha+\beta+1)}{(2n+\alpha+\beta+1)(2n+\alpha+\beta+2)} P^{(\alpha,\beta)}_{n+1}(x) \
                                & + \frac{\beta^2 - \alpha^2}{(2n+\alpha+\beta)(2n+\alpha+\beta+2)} P^{(\alpha,\beta)}_{n}(x) \
                                & + \frac{2(n+\alpha)(n+\beta)}{(2n+\alpha+\beta)(2n+\alpha+\beta+1)} P^{(\alpha,\beta)}_{n-1}(x)\end{split}\notag
\end{gather}
with weight function
\begin{gather}
\begin{split}w(x;\alpha,\beta) = \frac{\Gamma(\alpha+\beta+2)}{2^{\alpha+\beta+1}\Gamma(\alpha+1)\Gamma(\beta+1)}(1-x)^\alpha (1+x)^\beta\end{split}\notag
\end{gather}
\begin{notice}{note}{Note:}
In probability theory, the Beta distribution is defined on \(\Psi=[0,1]\) and its the Probability Distribution Function is
\begin{gather}
\begin{split}\rho_B(x;\alpha,\beta) = \frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)} x^{\alpha-1} (1-x)**(\beta-1)\end{split}\notag
\end{gather}
The relation betwen \(w(x;\alpha,\beta)\) and \(\rho_B(x;\alpha,\beta)\) for \(x \in \Psi\) is
\begin{gather}
\begin{split}\rho_B(x;\alpha,\beta) = 2 * w(2*x-1;\beta-1,\alpha-1)\end{split}\notag
\end{gather}
For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{stats}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xp}\PYG{p}{,}\PYG{n}{stats}\PYG{o}{.}\PYG{n}{beta}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pdf}\PYG{p}{(}\PYG{n}{xp}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xp}\PYG{p}{,}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{Bx}\PYG{p}{(}\PYG{n}{xx}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xp}\PYG{p}{,}\PYG{n}{stats}\PYG{o}{.}\PYG{n}{beta}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pdf}\PYG{p}{(}\PYG{n}{xp}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xp}\PYG{p}{,}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{Bx}\PYG{p}{(}\PYG{n}{xx}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}
\end{notice}


\chapter{References}
\label{index:references}

\chapter{Examples}
\label{index:examples}\index{Poly1D (class in SpectralToolbox.Spectral1D)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D}\pysiglinewithargsret{\strong{class }\code{SpectralToolbox.Spectral1D.}\bfcode{Poly1D}}{\emph{poly}, \emph{params}, \emph{sdout=\textless{}open file `\textless{}stderr\textgreater{}'}, \emph{mode `w' at 0x2b18a359b270\textgreater{}}}{}
Initialization of the Polynomial instance.
\begin{description}
\item[{Syntax:}] \leavevmode
\code{p = Poly1D(poly,params)}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{poly} = The orthogonal polynomial type desired

\item {} 
\code{params} = The parameters needed by the selected polynomial

\item {} 
\code{sdout} = (optional,default=sys.stderr) output stream for logging

\end{itemize}

\item[{Description:}] \leavevmode
This method generates an instance of the Poly1D class, to be used in order to generate
orthogonal basis of the polynomial type selected. Avaliable polynomial types can be
selected using their string name or by predefined attributes
\begin{itemize}
\item {} 
`Jacobi' or \code{Spectral1D.JACOBI}

\item {} 
`HermiteP' or \code{Spectral1D.HERMITEP}

\item {} 
`HermiteF' or \code{Spectral1D.HERMITEF}

\item {} 
`HermitePprob' or \code{Spectral1D.HERMITEP\_PROB}

\item {} 
`LaguerreP' or \code{Spectral1D.LAGUERREP}

\item {} 
`LaguerreF' or \code{Spectral1D.LAGUERREF}

\item {} 
`ORTHPOL' or \code{Spectral1D.ORTHPOL}

\end{itemize}

Additional parameters are required for some polynomials.

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Polynomial
} & \textsf{\relax 
Parameters
}\\
\hline
Jacobi
 & 
(alpha,beta)
\\

HermiteP
 & 
None
\\

HermiteF
 & 
None
\\

HermitePprob
 & 
None
\\

LaguerreP
 & 
alpha
\\

LaguerreF
 & 
alpha
\\

ORTHPOL
 & 
see notes
\\
\hline\end{tabulary}


\end{description}

\begin{notice}{note}{Note:}
The ORTHPOL polynomials are built up using the ``Multiple-Component Discretization Procedure'' described in \footnotemark[4]. The following parameters describing the measure function are required in order to use the procedure for finding the recursion coefficients (alpha,beta) and have to be provided at construction time:
\begin{itemize}
\item {} 
\code{ncapm}: (int) maximum integer N0 (default = 500)

\item {} 
\code{mc}: (int) number of component intervals in the continuous part of the spectrum

\item {} 
\code{mp}: (int) number of points in the discrete part of the spectrum. If the measure has no discrete part, set mp=0

\item {} 
\code{xp}, \code{yp}: (Numpy 1d-array) of dimension mp, containing the abscissas and the jumps of the point spectrum

\item {} 
\code{mu}: (function) measure function that returns the mass (float) with arguments: \code{x} (float) absissa, \code{i} (int) interval number in the continuous part

\item {} 
\code{irout}: (int) selects the routine for generating the recursion coefficients from the discrete inner product; \code{irout=1} selects the routine \code{sti}, \code{irout!=1} selects the routine \code{lancz}

\item {} 
\code{finl}, \code{finr}: (bool) specify whether the extreme left/right interval is finite (false for infinite)

\item {} 
\code{endl}, \code{endr}: (Numpy 1d-array) of dimension \code{mc} containing the left and right endpoints of the component intervals. If the first of these extends to -infinity, endl{[}0{]} is not being used by the routine.

\end{itemize}

Parameters \code{iq}, \code{quad}, \code{idelta} in \footnotemark[4] are suppressed. Instead the routine \code{qgp} of ORTHPOL \footnotemark[4] is used by default (\code{iq=0} and \code{idelta=2})
\end{notice}
\index{AssemblyDerivativeMatrix() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.AssemblyDerivativeMatrix}\pysiglinewithargsret{\bfcode{AssemblyDerivativeMatrix}}{\emph{x}, \emph{N}, \emph{k}}{}
AssemblyDerivativeMatrix(): Assemble the k-th derivative matrix using polynomials of order N.
\begin{description}
\item[{Syntax:}] \leavevmode
\code{Dk = AssemblyDerivativeMatrix(x,N,k)}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
x = (1d-array,float) Set of points on which to evaluate the polynomials

\item {} 
N = (int) maximum order in the vanermonde matrix

\item {} 
k = (int) derivative order

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
Dk = Derivative matrix

\end{itemize}

\item[{Description:}] \leavevmode
This function performs \code{D = linalg.solve(V.T, Vx.T)} where \code{V} and \code{Vx} are a Generalized Vandermonde Matrix and its derivative respectively.

\item[{Notes:}] \leavevmode
For Chebyshev Polynomial, this function refers to the recursion form implemented in \code{PolynomialDerivativeMatrix}

\end{description}

\end{fulllineitems}

\index{ChebyshevDerivativeCoefficients() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.ChebyshevDerivativeCoefficients}\pysiglinewithargsret{\bfcode{ChebyshevDerivativeCoefficients}}{\emph{fhat}}{}
ChebyshevDerivativeCoefficients(): computes the Chebyshev coefficients of the derivative of a function
\begin{description}
\item[{Syntax:}] \leavevmode
\code{dfhat = ChebyshevDerivativeCoefficients(fhat)}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{fhat} = (1d-array,float) list of Chebyshev coefficients of the original function

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{dfhat} = (1d-array,float) list of Chebyshev coefficients of the derivative of the original function

\end{itemize}

\item[{Notes:}] \leavevmode
Algorithm (5) from \footnote{
``Implemenenting Spectral Methods for Partial Differential Equations'' by David A. Kopriva, Springer, 2009
}

\end{description}

\end{fulllineitems}

\index{DiscretePolynomialTransform() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.DiscretePolynomialTransform}\pysiglinewithargsret{\bfcode{DiscretePolynomialTransform}}{\emph{r}, \emph{f}, \emph{N}}{}
DiscretePolynomialTransform(): computes the Discrete Polynomial Transform of function values f
\begin{description}
\item[{Syntax:}] \leavevmode
\code{fhat = DiscretePolynomialTransform(r, f, N)}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{r} = (1d-array,float) set of points on which to the polynomials are evaluated

\item {} 
\code{f} = (1d-array,float) function values

\item {} 
\code{N} = (int) maximum order in the generalized vanermonde matrix

\end{itemize}

\item[{Output: one of the two following output is given, depending on the length of r}] \leavevmode\begin{itemize}
\item {} 
\code{(fhat, residues, rank,s)} = list of Polynomial coefficients and additional ouputs from function \code{numpy.linalg.lstsq} (if len(r) \textgreater{} N+1)

\end{itemize}

\item[{Description:}] \leavevmode
If the Chebyshev polynomials are chosen and \code{r} contains Chebyshev-Gauss-Lobatto points, the Fast Chebyshev Transform is used. Otherwise uses the Generalized Vandermonde Matrix in order to transform from physical space to transform space.

\end{description}


\strong{See also:}


FastChebyshevTransform



\end{fulllineitems}

\index{FastChebyshevTransform() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.FastChebyshevTransform}\pysiglinewithargsret{\bfcode{FastChebyshevTransform}}{\emph{f}}{}
FastChebyshevTransform(): Returns the coefficients of the Fast Chebyshev Transform.
\begin{description}
\item[{Syntax:}] \leavevmode
\code{fhat = FastChebyshevTransform(f)}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{f} = (1d-array,float) function values

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{fhat} = (1d-array,float) list of Polynomial coefficients

\end{itemize}

\end{description}

\begin{notice}{warning}{Warning:}
It is assumed that the values f are computed at Chebyshev-Gauss-Lobatto points.
\end{notice}

\begin{notice}{note}{Note:}
If f is odd, the vector is interpolated to even Chebyshev-Gauss-Lobatto points.
\end{notice}

\begin{notice}{note}{Note:}
Modification of algorithm (29) from \footnotemark[1]
\end{notice}

\end{fulllineitems}

\index{Gamma() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.Gamma}\pysiglinewithargsret{\bfcode{Gamma}}{\emph{N}}{}
Gamma(): returns the normalization constant for the N-th polynomial
\begin{description}
\item[{Syntax:}] \leavevmode
\code{g = Gamma(N)}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{N} = polynomial order

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{g} = normalization constant

\end{itemize}

\end{description}

\end{fulllineitems}

\index{GaussLobattoQuadrature() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.GaussLobattoQuadrature}\pysiglinewithargsret{\bfcode{GaussLobattoQuadrature}}{\emph{N}, \emph{normed=False}, \emph{left=None}, \emph{right=None}}{}
GaussLobattoQuadrature(): Generates list of nodes for the Gauss-Lobatto quadrature rule using selected Polynomial basis
\begin{description}
\item[{Syntax:}] \leavevmode
\code{x = GaussLobattoQuadrature(N,{[}normed=False{]},{[}left=None{]},{[}right=None{]})}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{N} = (int) accuracy level required

\item {} 
\code{normed} = (optional,bool) whether the weights will be normalized or not

\item {} 
\code{left} = (optional,float) containing the left endpoint (used by ORTHPOL)

\item {} 
\code{right} = (optional,float) containing the right endpoint (used by ORTHPOL)

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{x} = (1d-array,float) containing the nodes

\item {} 
\code{w} = (1d-array,float) containing the weights

\end{itemize}

\end{description}

\begin{notice}{note}{Note:}
Available only for Jacobi Polynomials and ORTHPOL
\end{notice}

\end{fulllineitems}

\index{GaussQuadrature() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.GaussQuadrature}\pysiglinewithargsret{\bfcode{GaussQuadrature}}{\emph{N}, \emph{normed=False}}{}
GaussQuadrature(): Generates list of nodes and weights for the Gauss quadrature rule using the selected Polynomial basis
\begin{description}
\item[{Syntax:}] \leavevmode
\code{(x,w) = GaussQuadrature(N,{[}normed=False{]})}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{N} = (int) accuracy level required

\item {} 
\code{normed} = (optional,bool) whether the weights will be normalized or not

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{x} = (1d-array,float) containing the nodes

\item {} 
\code{w} = (1d-array,float) containing the weights

\end{itemize}

\end{description}

\end{fulllineitems}

\index{GaussRadauQuadrature() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.GaussRadauQuadrature}\pysiglinewithargsret{\bfcode{GaussRadauQuadrature}}{\emph{N}, \emph{normed=False}, \emph{end=None}}{}
GaussRadauQuadrature(): Generates list of nodes for the Gauss-Radau quadrature rule using selected Polynomial basis
\begin{description}
\item[{Syntax:}] \leavevmode
{\color{red}\bfseries{}{}`{}`}x = GaussRadauQuadrature(N,{[}normed=False{]},{[}end=None{]})'`

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
{\color{red}\bfseries{}{}`{}`}N'' = (int) accuracy level required

\item {} 
\code{normed} = (optional,bool) whether the weights will be normalized or not

\item {} 
\code{end} = (optional,float) containing the endpoint (used by ORTHPOL)

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
{\color{red}\bfseries{}{}`{}`}x'' = (1d-array,float) containing the nodes

\item {} 
{\color{red}\bfseries{}{}`{}`}w'' = (1d-array,float) weights

\end{itemize}

\end{description}

\begin{notice}{note}{Note:}
Available only for Laguerre Polynomials/Functions and ORTHPOL
\end{notice}

\end{fulllineitems}

\index{GradEvaluate() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.GradEvaluate}\pysiglinewithargsret{\bfcode{GradEvaluate}}{\emph{r}, \emph{N}, \emph{k}, \emph{norm=True}}{}
GradEvaluate(): evaluate the \code{k}-th derivative of the \code{N}-th order polynomial at points \code{r}
\begin{description}
\item[{Syntax:}] \leavevmode
\code{P = GradEvaluate(r,N,k{[},norm=True{]})}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{r} = (1d-array,float) set of points on which to evaluate the polynomial

\item {} 
\code{N} = (int) order of the polynomial

\item {} 
\code{k} = (int) order of the derivative

\item {} 
\code{norm} = (bool) whether to return normalized (True) or non normalized (False) polynomials

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{P} = Polynomial evaluated on \code{r}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{GradVandermonde1D() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.GradVandermonde1D}\pysiglinewithargsret{\bfcode{GradVandermonde1D}}{\emph{r}, \emph{N}, \emph{k}, \emph{norm=True}}{}
GradVandermonde1D(): Initialize the \code{k}-th gradient of the modal basis \code{N} at \code{r}
\begin{description}
\item[{Syntax:}] \leavevmode
\code{V = GradVandermonde1D(r,N,k,{[}norm{]})}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{r} = (1d-array,float) set of \code{M} points on which to evaluate the polynomials

\item {} 
\code{N} = (int) maximum order in the vanermonde matrix

\item {} 
\code{k} = (int) derivative order

\item {} 
\code{norm} = (optional,boolean) True -\textgreater{} orthonormal polynomials, False -\textgreater{} non orthonormal polynomials

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{V} = (2d-array(\code{MxN}),float) Generalized Vandermonde matrix

\end{itemize}

\end{description}

\end{fulllineitems}

\index{GramSchmidt() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.GramSchmidt}\pysiglinewithargsret{\bfcode{GramSchmidt}}{\emph{p}, \emph{N}, \emph{w}}{}
GramSchmidt(): creates a Generalized Vandermonde Matrix of orthonormal polynomials with respect to the weights \code{w}
\begin{description}
\item[{Syntax:}] \leavevmode
\code{V = GramSchmidt(p, N, w)}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{p} = (1d-array,float) points at which to evaluate the new polynomials

\item {} 
\code{N} = (int) the maximum order of the polynomials

\item {} 
\code{w} = (1d-array,float) weights to be used for the orthogonoalization

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{V} = Generalized Vandermonde Matrix containing the new orthogonalized polynomials

\end{itemize}

\item[{Description:}] \leavevmode
Takes the points where the polynomials have to be evaluated and computes a Generalized Gram Schmidth procedure, where a weighted projection is used. If \code{w==1} then the usual inner product is used for the orthogonal projection.

\end{description}

\end{fulllineitems}

\index{InverseDiscretePolynomialTransform() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.InverseDiscretePolynomialTransform}\pysiglinewithargsret{\bfcode{InverseDiscretePolynomialTransform}}{\emph{r}, \emph{fhat}, \emph{N}}{}
InverseDiscretePolynomialTransform(): computes the nodal values from the modal form fhat.
\begin{description}
\item[{Syntax:}] \leavevmode
\code{f = InverseDiscretePolynomialTransform(r, fhat, alpha, beta, N)}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{x} = (1d-array,float) set of points on which to the polynomials are evaluated

\item {} 
\code{fhat} = (1d-array,float) list of Polynomial coefficients

\item {} 
\code{N} = (int) maximum order in the generalized vanermonde matrix

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{f} = (1d-array,float) function values

\end{itemize}

\item[{Description:}] \leavevmode
If the Chebyshev polynomials are chosen and r contains Chebyshev-Gauss-Lobatto points, the Inverse Fast Chebyshev Transform is used. Otherwise uses the Generalized Vandermonde Matrix in order to transform from transform space to physical space.

\end{description}


\strong{See also:}


InverseFastChebyshevTransform



\end{fulllineitems}

\index{InverseFastChebyshevTransform() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.InverseFastChebyshevTransform}\pysiglinewithargsret{\bfcode{InverseFastChebyshevTransform}}{\emph{fhat}}{}
InverseFastChebyshevTransform(): Returns the coefficients of the Inverse Fast Chebyshev Transform.
\begin{description}
\item[{Syntax:}] \leavevmode
\code{f = InverseFastChebyshevTransform(fhat)}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{fhat} = (1d-array,float) list of Polynomial coefficients

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{f} = (1d-array,float) function values

\end{itemize}

\end{description}

\begin{notice}{note}{Note:}
If f is odd, the vector is padded with a zero value (highest freq.)
\end{notice}

\begin{notice}{note}{Note:}
Modification of algorithm (29) from \footnotemark[1]
\end{notice}

\end{fulllineitems}

\index{LegendreDerivativeCoefficients() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.LegendreDerivativeCoefficients}\pysiglinewithargsret{\bfcode{LegendreDerivativeCoefficients}}{\emph{fhat}}{}
LegendreDerivativeCoefficients(): computes the Legendre coefficients of the derivative of a function
\begin{description}
\item[{Syntax:}] \leavevmode
\code{dfhat = LegendreDerivativeCoefficients(fhat)}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{fhat} = (1d-array,float) list of Legendre coefficients of the original function

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{dfhat} = (1d-array,float) list of Legendre coefficients of the derivative of the original function

\end{itemize}

\item[{Notes:}] \leavevmode
Algorithm (4) from \footnotemark[1]

\end{description}

\end{fulllineitems}

\index{PolyInterp() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.PolyInterp}\pysiglinewithargsret{\bfcode{PolyInterp}}{\emph{x}, \emph{f}, \emph{xi}, \emph{order}}{}
PolyInterp(): Interpolate function values \code{f} from points \code{x} to points \code{xi} using Forward and Backward Polynomial Transform
\begin{description}
\item[{Syntax:}] \leavevmode
\code{fi = PolyInterp(x, f, xi)}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{x} = (1d-array,float) set of \code{N} original points where \code{f} is evaluated

\item {} 
\code{f} = (1d-array,float) set of \code{N} function values

\item {} 
\code{xi} = (1d-array,float) set of \code{M} points where the function is interpolated

\item {} 
\code{order} = (integer) order of polynomial interpolation

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{fi} = (1d-array,float) set of \code{M} function values

\end{itemize}

\end{description}

Notes:

\end{fulllineitems}

\index{Quadrature() (SpectralToolbox.Spectral1D.Poly1D method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Spectral1D.Poly1D.Quadrature}\pysiglinewithargsret{\bfcode{Quadrature}}{\emph{N}, \emph{quadType=None}, \emph{normed=False}, \emph{left=None}, \emph{right=None}, \emph{end=None}}{}
Quadrature(): Generates list of nodes and weights for the \code{quadType} quadrature rule using the selected Polynomial basis
\begin{description}
\item[{Syntax:}] \leavevmode
\code{(x,w) = Quadrature(N, {[}quadType=None{]}, {[}normed=False{]}, {[}left=None{]}, {[}right=None{]}, {[}end=None{]})}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{N} = (int) accuracy level required

\item {} 
\code{quadType} = (\code{AVAIL\_POLYS}) type of quadrature to be used. Default is Gauss quadrature rule.

\item {} 
\code{normed} = (optional,bool) whether the weights will be normalized or not

\item {} 
\code{left} = (optional,float) containing the left endpoint (used by ORTHPOL Gauss-Lobatto rules)

\item {} 
\code{right} = (optional,float) containing the right endpoint (used by ORTHPOL Gauss-Lobatto rules)

\item {} 
\code{end} = (optional,float) containing the endpoint (used by ORTHPOL Gauss-Radau rules)

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{x} = (1d-array,float) containing the nodes

\item {} 
\code{w} = (1d-array,float) containing the weights

\end{itemize}

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{index:module-SpectralToolbox.SpectralND}\index{SpectralToolbox.SpectralND (module)}

\chapter{Spectral ND}
\label{index:spectral-nd}
Created on Mon Jul  9 11:35:12 2012

@author: Daniele Bigoni (\href{mailto:dabi@imm.dtu.dk}{dabi@imm.dtu.dk})

Implementation of Spectral Methods in n dimension.

It uses the package \code{Spectral1D} as basic polynomials in order to construct higher dimensional rules by tensor product.
\index{PolyND (class in SpectralToolbox.SpectralND)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.SpectralND.PolyND}\pysiglinewithargsret{\strong{class }\code{SpectralToolbox.SpectralND.}\bfcode{PolyND}}{\emph{polys}}{}
Initialization of the N-dimensional Polynomial instance
\begin{description}
\item[{Syntax:}] \leavevmode
\code{p = PolyND(polys)}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{polys} = (list,Spectral1D.Poly1D) list of polynomial instances of the class \code{Spectral1D.Poly1D}

\end{itemize}

\end{description}


\strong{See also:}


Spectral1D.Poly1D


\index{GaussLobattoQuadrature() (SpectralToolbox.SpectralND.PolyND method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.SpectralND.PolyND.GaussLobattoQuadrature}\pysiglinewithargsret{\bfcode{GaussLobattoQuadrature}}{\emph{Ns}, \emph{normed=False}, \emph{warnings=True}}{}
GaussLobattoQuadrature(): computes the tensor product of the Guass Lobatto Points and weights
\begin{description}
\item[{Syntax:}] \leavevmode
\code{(x,w) = GaussLobattoQuadrature(Ns,{[}normed=False{]},{[}warnings=True{]})}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{Ns} = (list,int) n-dimensional list with the order of approximation of each polynomial

\item {} 
\code{normed} = (optional,boolean) whether the weights will be normalized or not

\item {} 
\code{warnings} = (optional,boolean) set whether to ask for confirmation when it is required to allocate more then 100Mb of memory

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{x} = tensor product of the collocation points

\item {} 
\code{w} = tensor product of the weights

\end{itemize}

\end{description}

\begin{notice}{warning}{Warning:}
The lengths of \code{Ns} has to be conform to the number of polynomials with which you have instantiated \code{PolyND}
\end{notice}

\end{fulllineitems}

\index{GaussQuadrature() (SpectralToolbox.SpectralND.PolyND method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.SpectralND.PolyND.GaussQuadrature}\pysiglinewithargsret{\bfcode{GaussQuadrature}}{\emph{Ns}, \emph{normed=False}, \emph{warnings=True}}{}
GaussQuadrature(): computes the tensor product of the Guass Points and weights
\begin{description}
\item[{Syntax:}] \leavevmode
\code{(x,w) = GaussQuadrature(Ns, {[}normed=False{]},{[}warnings=True{]})}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{Ns} = (list,int) n-dimensional list with the order of approximation of each polynomial

\item {} 
\code{normed} = (optional,boolean) whether the weights will be normalized or not

\item {} 
\code{warnings} = (optional,boolean) set whether to ask for confirmation when it is required to allocate more then 100Mb of memory

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{x} = tensor product of the collocation points

\item {} 
\code{w} = tensor product of the weights

\end{itemize}

\end{description}

\begin{notice}{warning}{Warning:}
The lengths of \code{Ns} has to be conform to the number of polynomials with which you have instantiated \code{PolyND}
\end{notice}

\end{fulllineitems}

\index{GradVandermonde() (SpectralToolbox.SpectralND.PolyND method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.SpectralND.PolyND.GradVandermonde}\pysiglinewithargsret{\bfcode{GradVandermonde}}{\emph{rs}, \emph{Ns}, \emph{ks}, \emph{norms=None}, \emph{usekron=True}, \emph{output=True}, \emph{warnings=True}}{}
GradVandermonde(): initialize the tensor product of the k-th gradient of the modal basis.
\begin{description}
\item[{Syntax:}] \leavevmode
\code{V = GradVandermonde(r,N,k,{[}norms=None{]},{[}usekron=True{]},{[}output=True{]},{[}warnings=True{]})}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{rs} = (list of 1d-array,float) \code{n}-dimensional list of set of points on which to evaluate the polynomials (by default they are not the kron product of the points. See \code{usekron} option)

\item {} 
\code{Ns} = (list,int) n-dimensional list with the maximum orders of approximation of each polynomial

\item {} 
\code{ks} = (list,int) n-dimensional list with derivative orders

\item {} 
\code{norms} = (default=None,list,boolean) n-dimensional list of boolean, True -\textgreater{} orthonormal, False -\textgreater{} orthogonal, None -\textgreater{} all orthonormal

\item {} 
\code{usekron} = (optional,boolean) set whether to apply the kron product of the single dimensional Vandermonde matrices or to multiply column-wise. kron(rs) and usekron==False is equal to rs and usekron==True

\item {} 
\code{output} = (optional,boolean) set whether to print out information about memory allocation

\item {} 
\code{warnings} = (optional,boolean) set whether to ask for confirmation when it is required to allocate more then 100Mb of memory

\end{itemize}

\item[{OUTPUT:}] \leavevmode\begin{itemize}
\item {} 
\code{V} = Tensor product of the Generalized Vandermonde matrices

\end{itemize}

\end{description}

\begin{notice}{warning}{Warning:}
The lengths of \code{Ns} , \code{rs} , \code{ks} , \code{norms} has to be conform to the number of polynomials with which you have instantiated \code{PolyND}
\end{notice}

\end{fulllineitems}

\index{GradVandermondePascalSimplex() (SpectralToolbox.SpectralND.PolyND method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.SpectralND.PolyND.GradVandermondePascalSimplex}\pysiglinewithargsret{\bfcode{GradVandermondePascalSimplex}}{\emph{rs}, \emph{N}, \emph{ks}, \emph{norms=None}, \emph{usekron=True}, \emph{output=True}, \emph{warnings=True}}{}
GradVandermondePascalSimplex(): initialize k-th gradient of the modal basis up to the total order N
\begin{description}
\item[{Syntax:}] \leavevmode
\code{V = GradVandermonde(r,N,k,{[}norms=None{]},{[}output=True{]},{[}warnings=True{]})}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{rs} = (list of 1d-array,float) \code{n}-dimensional list of set of points on which to evaluate the polynomials (by default they are not the kron product of the points. See \code{usekron} option)

\item {} 
\code{N} = (int) the maximum orders of the polynomial basis

\item {} 
\code{ks} = (list,int) n-dimensional list with derivative orders

\item {} 
\code{norms} = (default=None,list,boolean) n-dimensional list of boolean, True -\textgreater{} orthonormal, False -\textgreater{} orthogonal, None -\textgreater{} all orthonormal

\item {} 
\code{usekron} = (optional,boolean) set whether to apply the kron product of the single dimensional Vandermonde matrices or to multiply column-wise. kron(rs) and usekron==False is equal to rs and usekron==True

\item {} 
\code{output} = (optional,boolean) set whether to print out information about memory allocation

\item {} 
\code{warnings} = (optional,boolean) set whether to ask for confirmation when it is required to allocate more then 100Mb of memory

\end{itemize}

\item[{OUTPUT:}] \leavevmode\begin{itemize}
\item {} 
\code{V} = Generalized Vandermonde matrix up to the N-th order

\end{itemize}

\end{description}

\begin{notice}{warning}{Warning:}
The lengths of \code{rs} , \code{ks} , \code{norms} has to be conform to the number of polynomials with which you have instantiated \code{PolyND}
\end{notice}

\end{fulllineitems}

\index{Quadrature() (SpectralToolbox.SpectralND.PolyND method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.SpectralND.PolyND.Quadrature}\pysiglinewithargsret{\bfcode{Quadrature}}{\emph{Ns}, \emph{quadTypes=None}, \emph{left=None}, \emph{right=None}, \emph{end=None}, \emph{normed=False}, \emph{warnings=True}}{}
GaussQuadrature(): computes the tensor product of the Guass Points and weights
\begin{description}
\item[{Syntax:}] \leavevmode
\code{(x,w) = GaussQuadrature(Ns, {[}quadTypes=None{]}, {[}normed=False{]},{[}warnings=True{]})}

\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
\code{Ns} = (list,int) n-dimensional list with the order of approximation of each polynomial

\item {} 
\code{quadTypes} = (list,{}`{}`Spectral1D.AVAIL\_QUADPOINTS{}`{}`) n-dimensional list of quadrature point types chosen among Gauss, Gauss-Radau, Gauss-Lobatto (using the definition in \code{Spectral1D}). If None, Gauss points will be generated by default

\item {} 
\code{left}: (list,float) list of left values used by ORTHPOL for Gauss-Lobatto rules (the dimensions where the value is not used can be set to anything)

\item {} 
\code{right}: (list,float) list of left values used by ORTHPOL for Gauss-Lobatto rules (the dimensions where the value is not used can be set to anything)

\item {} 
\code{end}: (list,float) list of left values used by ORTHPOL for Gauss-Radau rules (the dimensions where the value is not used can be set to anything)

\item {} 
\code{normed} = (optional,boolean) whether the weights will be normalized or not

\item {} 
\code{warnings} = (optional,boolean) set whether to ask for confirmation when it is required to allocate more then 100Mb of memory

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
\code{x} = tensor product of the collocation points

\item {} 
\code{w} = tensor product of the weights

\end{itemize}

\end{description}

\begin{notice}{warning}{Warning:}
The lengths of \code{Ns} has to be conform to the number of polynomials with which you have instantiated \code{PolyND}
\end{notice}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{index:module-SpectralToolbox.SparseGrids}\index{SpectralToolbox.SparseGrids (module)}

\chapter{Sparse Grids}
\label{index:sparse-grids}
Created on Mon Jul  9 14:08:30 2012

@author: Daniele Bigoni (\href{mailto:dabi@imm.dtu.dk}{dabi@imm.dtu.dk})

Implementation of Sparse Grid (Smolyak) methods for numerical integration.

This implementation is a porting of the Sparse-Grid package developped in MatLab(R) at \href{http://www.sparse-grids.de}{http://www.sparse-grids.de}
The code is extended with Clenshaw-Curtis and Fejer quadrature rules {[}1{]}

@copyright: 2007 Florian Heiss, Viktor Winschel

@copyright: 2012-2014 Daniele Bigoni
\index{SparseGrid (class in SpectralToolbox.SparseGrids)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.SparseGrids.SparseGrid}\pysiglinewithargsret{\strong{class }\code{SpectralToolbox.SparseGrids.}\bfcode{SparseGrid}}{\emph{qrule}, \emph{dim}, \emph{k}, \emph{sym}}{}
Initialization of the Sparse Grid instance.
\begin{description}
\item[{Syntax:}] \leavevmode
sg = SparseGrid(qrule, dim, k, sym)

\item[{Input: }] \leavevmode\begin{itemize}
\item {} 
qrule = Function of 1D integration rule

\item {} 
dim  = dimension of the integration problem

\item {} 
k    = Accuracy level. The rule will be exact for polynomial up to total order 2k-1

\item {} 
sym  = (optional) only used for own 1D quadrature rule (type not ``KPU'',...). If sym is supplied and not=0, the code will run faster but will produce incorrect results if 1D quadrature rule is asymmetric.

\end{itemize}

\item[{Description:}] \leavevmode
Several 1D integration rules are available to be chosen for the \code{qrule} input parameter
\begin{itemize}
\item {} 
KPU = Nested rule for unweighted integral over {[}0,1{]}

\item {} 
KPN = Nested rule for integral with Gaussian weight

\item {} 
GQU = Gaussian quadrature for unweighted integral over {[}0,1{]} (Gauss-Legendre)

\item {} 
GQN = Gaussian quadrature for integral with Gaussian weight (Gauss-Hermite)

\item {} 
CC  = Clenshaw-Curtis quadrature for unweighted integral over {[}-1,1{]}

\item {} 
FEJ = Fejer's quadrature for unweighted integral over {[}-1,1{]}

\item {} 
func =  any function provided by the user that accept level l and returns nodes n and weights w for univariate quadrature rule with polynomial exactness 2l-1 as {[}n w{]} = feval(func,level)

\end{itemize}

\end{description}
\index{sparseGrid() (SpectralToolbox.SparseGrids.SparseGrid method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.SparseGrids.SparseGrid.sparseGrid}\pysiglinewithargsret{\bfcode{sparseGrid}}{}{}
sparseGrid(): main function for generating nodes \& weights for sparse grids intergration
\begin{description}
\item[{Syntax: }] \leavevmode
(n,w) = sparseGrid()

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
n    = matrix of nodes with dim columns

\item {} 
w    = row vector of corresponding weights

\end{itemize}

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{GQU() (in module SpectralToolbox.SparseGrids)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.SparseGrids.GQU}\pysiglinewithargsret{\code{SpectralToolbox.SparseGrids.}\bfcode{GQU}}{\emph{): function for generating 1D Gaussian quadrature rules for unweighted integral over {[}0}, \emph{1{]} (Gauss-Legendre}}{}~\begin{description}
\item[{Syntax:}] \leavevmode
(n,w) = GQU(l)

\item[{Input:}] \leavevmode
l = level of accuracy of the quadrature rule

\item[{Output:}] \leavevmode
n = nodes
w = weights

\end{description}

\end{fulllineitems}

\index{GQN() (in module SpectralToolbox.SparseGrids)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.SparseGrids.GQN}\pysiglinewithargsret{\code{SpectralToolbox.SparseGrids.}\bfcode{GQN}}{\emph{): function for generating 1D Gaussian quadrature for integral with Gaussian weight (Gauss-Hermite}}{}~\begin{description}
\item[{Syntax:}] \leavevmode
(n,w) = GQU(l)

\item[{Input:}] \leavevmode
l = level of accuracy of the quadrature rule

\item[{Output:}] \leavevmode
n = nodes
w = weights

\end{description}

\end{fulllineitems}

\index{KPU() (in module SpectralToolbox.SparseGrids)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.SparseGrids.KPU}\pysiglinewithargsret{\code{SpectralToolbox.SparseGrids.}\bfcode{KPU}}{\emph{l}}{}
KPU(): function for generating 1D Nested rule for unweighted integral over {[}0,1{]}
Syntax:
\begin{quote}

(n,w) = GQU(l)
\end{quote}
\begin{description}
\item[{Input:}] \leavevmode
l = level of accuracy of the quadrature rule

\item[{Output:}] \leavevmode
n = nodes
w = weights

\end{description}

\end{fulllineitems}

\index{KPN() (in module SpectralToolbox.SparseGrids)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.SparseGrids.KPN}\pysiglinewithargsret{\code{SpectralToolbox.SparseGrids.}\bfcode{KPN}}{\emph{l}}{}
KPN(): function for generating 1D Nested rule for integral with Gaussian weight
Syntax:
\begin{quote}

(n,w) = GQU(l)
\end{quote}
\begin{description}
\item[{Input:}] \leavevmode
l = level of accuracy of the quadrature rule

\item[{Output:}] \leavevmode
n = nodes
w = weights

\end{description}

\end{fulllineitems}

\phantomsection\label{index:module-SpectralToolbox.Misc}\index{SpectralToolbox.Misc (module)}

\chapter{Miscellaneous}
\label{index:miscellaneous}
Created on Wed Feb 27

@author: Daniele Bigoni (\href{mailto:dabi@dtu.dk}{dabi@dtu.dk})

Collection of miscellaneous functions used in the SpectralToolbox
\index{ExpandingArray (class in SpectralToolbox.Misc)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.ExpandingArray}\pysiglinewithargsret{\strong{class }\code{SpectralToolbox.Misc.}\bfcode{ExpandingArray}}{\emph{initData}, \emph{allocInitDim=None}, \emph{dtype=\textless{}type `numpy.float64'\textgreater{}}, \emph{maxIncrement=None}}{}
ExpandingArray is used for the dynamic allocation of memory in applications where the total allocated memory needed cannot be predicted. Memory is preallocated with increases of 50\% all the time data exceed the allocated memory.

Initialization of the Expanding Array.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA} \PYG{o}{=} \PYG{n}{ExpandingArray}\PYG{p}{(}\PYG{n}{initData}\PYG{p}{,}\PYG{p}{[}\PYG{n}{allocInitDim}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,}\PYG{p}{[}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{,}\PYG{p}{[}\PYG{n}{maxIncrement}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{initData} (\emph{ndarray}) -- InitialData with which to be initially filled. This must provide the number of dimensions of the array

\item {} 
\textbf{allocInitDim} (\emph{1darray-integer}) -- Initial allocated dimension (optional)

\item {} 
\textbf{dtype} (\emph{dtype}) -- type for the data that will be contained in \code{EA} (optional,default=np.float64)

\item {} 
\textbf{maxIncrement} (\emph{integer}) -- upper limit for the allocation increment

\end{itemize}

\end{description}\end{quote}
\index{concatenate() (SpectralToolbox.Misc.ExpandingArray method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.ExpandingArray.concatenate}\pysiglinewithargsret{\bfcode{concatenate}}{\emph{X}, \emph{axis=0}}{}
Concatenate data to the existing array. If needed the array is resized in the \code{axis} direction by a factor of 50\%.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{X} (\emph{ndarray}) -- data to be concatenated to the array. Note that \code{X.shape{[}i{]}==EA.shape(){[}i{]}} is required for all i!=axis

\item {} 
\textbf{axis} (\emph{integer}) -- axis along which to concatenate the additional data (optional)

\end{itemize}

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA} \PYG{o}{=} \PYG{n}{Misc}\PYG{o}{.}\PYG{n}{ExpandingArray}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{(25, 4)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{getAllocArray}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(25, 4)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{(38, 4)}
\end{Verbatim}

\end{fulllineitems}

\index{getAllocArray() (SpectralToolbox.Misc.ExpandingArray method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.ExpandingArray.getAllocArray}\pysiglinewithargsret{\bfcode{getAllocArray}}{}{}
Return the allocated array.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
allocated array

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA} \PYG{o}{=} \PYG{n}{Misc}\PYG{o}{.}\PYG{n}{ExpandingArray}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{(25, 4)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{getAllocArray}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(25, 4)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{(38, 4)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{getAllocArray}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(45, 4)}
\end{Verbatim}

\end{fulllineitems}

\index{getDataArray() (SpectralToolbox.Misc.ExpandingArray method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.ExpandingArray.getDataArray}\pysiglinewithargsret{\bfcode{getDataArray}}{}{}
Get the view of the array with data.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
allocated array

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{(38, 4)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{getAllocArray}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(45, 4)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{getDataArray}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(38, 4)}
\end{Verbatim}

\end{fulllineitems}

\index{shape() (SpectralToolbox.Misc.ExpandingArray method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.ExpandingArray.shape}\pysiglinewithargsret{\bfcode{shape}}{}{}
Returns the shape of the data inside the array. Note that the allocated memory is always bigger or equal to \code{shape()}.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
shape of the data

\item[{Return type}] \leavevmode
tuple of integer

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA} \PYG{o}{=} \PYG{n}{Misc}\PYG{o}{.}\PYG{n}{ExpandingArray}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{(25, 4)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{getAllocArray}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(25, 4)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{(38, 4)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{getAllocArray}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(45, 4)}
\end{Verbatim}

\end{fulllineitems}

\index{trim() (SpectralToolbox.Misc.ExpandingArray method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.ExpandingArray.trim}\pysiglinewithargsret{\bfcode{trim}}{\emph{N}, \emph{axis=0}}{}
Trim the axis dimension of N elements. The allocated data is not reinitialized or deallocated. Only the dimensions of the view are redefined.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{N} (\emph{integer}) -- number of elements to be removed along the \code{axis} dimension

\item {} 
\textbf{axis} (\emph{integer}) -- axis along which to remove elements (optional)

\end{itemize}

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA} \PYG{o}{=} \PYG{n}{Misc}\PYG{o}{.}\PYG{n}{ExpandingArray}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{getDataArray}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{array([[ 0.42129746,  0.76220921],}
\PYG{g+go}{       [ 0.9238783 ,  0.11256142],}
\PYG{g+go}{       [ 0.42031437,  0.87349243],}
\PYG{g+go}{       [ 0.83187297,  0.555708  ]])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{trim}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{getDataArray}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{array([[ 0.42129746,  0.76220921],}
\PYG{g+go}{       [ 0.9238783 ,  0.11256142]])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EA}\PYG{o}{.}\PYG{n}{getAllocArray}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{array([[ 0.42129746,  0.76220921],}
\PYG{g+go}{       [ 0.9238783 ,  0.11256142],}
\PYG{g+go}{       [ 0.42031437,  0.87349243],}
\PYG{g+go}{       [ 0.83187297,  0.555708  ]])}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}

\index{MultiIndex() (in module SpectralToolbox.Misc)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.MultiIndex}\pysiglinewithargsret{\code{SpectralToolbox.Misc.}\bfcode{MultiIndex}}{\emph{d}, \emph{N}}{}
Generates the multi index ordering for the construction of multidimensional Generalized Vandermonde matrices
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{d} (\emph{integer}) -- dimension of the simplex

\item {} 
\textbf{N} (\emph{integer}) -- maximum value of the sum of the indices

\end{itemize}

\item[{Returns}] \leavevmode
array containing the ordered multi-indices

\item[{Return type}] \leavevmode
2d-array of integer

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Misc}\PYG{o}{.}\PYG{n}{MultiIndex}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+go}{array([[0, 0],}
\PYG{g+go}{       [1, 0],}
\PYG{g+go}{       [0, 1],}
\PYG{g+go}{       [2, 0],}
\PYG{g+go}{       [1, 1],}
\PYG{g+go}{       [0, 2],}
\PYG{g+go}{       [3, 0],}
\PYG{g+go}{       [2, 1],}
\PYG{g+go}{       [1, 2],}
\PYG{g+go}{       [0, 3]])}
\end{Verbatim}

\end{fulllineitems}

\index{almostEqual() (in module SpectralToolbox.Misc)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.almostEqual}\pysiglinewithargsret{\code{SpectralToolbox.Misc.}\bfcode{almostEqual}}{\emph{x}, \emph{y}, \emph{tol}}{}
Check equality of two arrays objects up to a certain tolerance
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{x,y} (\emph{numpy.ndarray objects of floats}) -- values to be compared

\item {} 
\textbf{tol} (\emph{float}) -- tolerance to be used

\end{itemize}

\item[{Returns}] \leavevmode
\code{true} if equal, \code{false} otherwise

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eps2} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{Misc}\PYG{o}{.}\PYG{n}{machineEpsilon}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Misc}\PYG{o}{.}\PYG{n}{almostEqual}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{eps2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{eps2}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Misc}\PYG{o}{.}\PYG{n}{almostEqual}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{o}{+}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{eps2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{eps2}\PYG{p}{)}
\PYG{g+go}{False}
\end{Verbatim}

\end{fulllineitems}

\index{almostEqualList() (in module SpectralToolbox.Misc)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.almostEqualList}\pysiglinewithargsret{\code{SpectralToolbox.Misc.}\bfcode{almostEqualList}}{\emph{xArray}, \emph{y}, \emph{tol}}{}
Check equality of a list of floats against an iterable value up to certain tolerance
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{xArray} (\emph{2d-array of floats}) -- values to be compared to \code{y}

\item {} 
\textbf{y} (\emph{iterable objects of floats}) -- values to be compared to

\item {} 
\textbf{tol} (\emph{float}) -- tolerance to be used

\end{itemize}

\item[{Returns}] \leavevmode
array of booleans containing true where equal, false elsewhere.

\item[{Return type}] \leavevmode
1d-array of bool

\end{description}\end{quote}
\begin{description}
\item[{Syntax:}] \leavevmode
\code{b = almostEqualList(xArray,y,tol)}

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eps2} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{Misc}\PYG{o}{.}\PYG{n}{machineEpsilon}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{X} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Misc}\PYG{o}{.}\PYG{n}{almostEqualList}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{X}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{,}\PYG{n}{eps2}\PYG{p}{)}
\PYG{g+go}{array([False,  True, False, False], dtype=bool)}
\end{Verbatim}

\end{fulllineitems}

\index{argsort\_insertion() (in module SpectralToolbox.Misc)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.argsort_insertion}\pysiglinewithargsret{\code{SpectralToolbox.Misc.}\bfcode{argsort\_insertion}}{\emph{X}, \emph{tol}, \emph{start\_idx=1}, \emph{end\_idx=None}}{}
Implements the insertion sort with \code{binary\_search}. Returns permutation indices.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{X} (\emph{2d-array of floats}) -- values ordered by row according to the \code{compare} function

\item {} 
\textbf{tol} (\emph{float}) -- tolerance to be used

\item {} 
\textbf{start\_idx,end\_idx} (\emph{int}) -- starting and ending indices for the ordering (optional)

\end{itemize}

\item[{Returns}] \leavevmode
permutation indices

\item[{Return type}] \leavevmode
1d-array of integers

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{X} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{X}
\PYG{g+go}{array([[ 0.56865133,  0.18490129],}
\PYG{g+go}{       [ 0.01411459,  0.46076606],}
\PYG{g+go}{       [ 0.64384365,  0.24998971],}
\PYG{g+go}{       [ 0.47840414,  0.32554137],}
\PYG{g+go}{       [ 0.12961966,  0.43712056]])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{perm} \PYG{o}{=} \PYG{n}{Misc}\PYG{o}{.}\PYG{n}{argsort\PYGZus{}insertion}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{eps2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{X}\PYG{p}{[}\PYG{n}{perm}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}
\PYG{g+go}{array([[ 0.01411459,  0.46076606],}
\PYG{g+go}{       [ 0.12961966,  0.43712056],}
\PYG{g+go}{       [ 0.47840414,  0.32554137],}
\PYG{g+go}{       [ 0.56865133,  0.18490129],}
\PYG{g+go}{       [ 0.64384365,  0.24998971]])}
\end{Verbatim}

\end{fulllineitems}

\index{binary\_search() (in module SpectralToolbox.Misc)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.binary_search}\pysiglinewithargsret{\code{SpectralToolbox.Misc.}\bfcode{binary\_search}}{\emph{X}, \emph{val}, \emph{lo}, \emph{hi}, \emph{tol}, \emph{perm=None}}{}
Search for the minimum X bigger than val
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{X} (\emph{2d-array of floats}) -- values ordered by row according to the \code{compare} function

\item {} 
\textbf{val} (\emph{1d-array of floats}) -- value to be compared to

\item {} 
\textbf{lo,hi} (\emph{integer}) -- staring and ending indices

\item {} 
\textbf{tol} (\emph{float}) -- tolerance to be used

\item {} 
\textbf{perm} (\emph{1d-array of integers}) -- possible permutation to be used prior to the search (optional)

\end{itemize}

\item[{Returns}] \leavevmode
index pointing to the maximum X smaller than val. If \code{perm} is provided, \code{perm{[}idx{]}} points to the maximum X smaller than val

\item[{Return type}] \leavevmode
integer

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{X} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{X}
\PYG{g+go}{array([[1],}
\PYG{g+go}{       [2],}
\PYG{g+go}{       [3],}
\PYG{g+go}{       [4]])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Misc}\PYG{o}{.}\PYG{n}{binary\PYGZus{}search}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{eps2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{idx} \PYG{o}{=} \PYG{n}{Misc}\PYG{o}{.}\PYG{n}{binary\PYGZus{}search}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{eps2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{idx}
\PYG{g+go}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{X}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}
\PYG{g+go}{array([3])}
\end{Verbatim}

\end{fulllineitems}

\index{compare() (in module SpectralToolbox.Misc)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.compare}\pysiglinewithargsret{\code{SpectralToolbox.Misc.}\bfcode{compare}}{\emph{x}, \emph{y}, \emph{tol}}{}
Compares two iterable objects up to a certain tolerance
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{x,y} (\emph{iterable objects of floats}) -- values to be compared

\item {} 
\textbf{tol} (\emph{float}) -- tolerance to be used

\end{itemize}

\item[{Returns}] \leavevmode
-1 if \code{(x-y) \textless{} tol}, 1 if \code{(x-y) \textgreater{} tol}, 0 otherwise

\item[{Return type}] \leavevmode
integer

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eps2} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{Misc}\PYG{o}{.}\PYG{n}{machineEpsilon}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Misc}\PYG{o}{.}\PYG{n}{compare}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{eps2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{eps2}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Misc}\PYG{o}{.}\PYG{n}{compare}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{o}{+}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{eps2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{eps2}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}1}
\end{Verbatim}

\end{fulllineitems}

\index{findOverlapping() (in module SpectralToolbox.Misc)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.findOverlapping}\pysiglinewithargsret{\code{SpectralToolbox.Misc.}\bfcode{findOverlapping}}{\emph{XF}, \emph{X}, \emph{tol}}{}
Finds overlapping points of \code{XF} on \code{X} grids of points. The two grids are ordered with respect to \code{Misc.compare()}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{XF,X} (\emph{2d-array of floats}) -- values ordered by row according to the \code{Misc.compare()}.

\item {} 
\textbf{tol} (\emph{float}) -- tolerance to be used

\end{itemize}

\item[{Returns}] \leavevmode
true values for overlapping points of \code{XF} on \code{X}, false for not overlapping points. Note: the overlapping return argument is a true-false indexing for \code{XF}.

\item[{Return type}] \leavevmode
1d-array of bool

\end{description}\end{quote}

\textbf{Example}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{XF}
\PYG{g+go}{array([[ \PYGZhy{}1.73205081e+00,   0.00000000e+00],}
\PYG{g+go}{       [ \PYGZhy{}1.00000000e+00,  \PYGZhy{}1.00000000e+00],}
\PYG{g+go}{       [ \PYGZhy{}1.00000000e+00,   0.00000000e+00],}
\PYG{g+go}{       [ \PYGZhy{}1.00000000e+00,   1.00000000e+00],}
\PYG{g+go}{       [  0.00000000e+00,  \PYGZhy{}1.73205081e+00],}
\PYG{g+go}{       [  0.00000000e+00,  \PYGZhy{}1.00000000e+00],}
\PYG{g+go}{       [  0.00000000e+00,   2.16406754e\PYGZhy{}16],}
\PYG{g+go}{       [  0.00000000e+00,   1.00000000e+00],}
\PYG{g+go}{       [  0.00000000e+00,   1.73205081e+00],}
\PYG{g+go}{       [  1.00000000e+00,  \PYGZhy{}1.00000000e+00],}
\PYG{g+go}{       [  1.00000000e+00,   0.00000000e+00],}
\PYG{g+go}{       [  1.00000000e+00,   1.00000000e+00],}
\PYG{g+go}{       [  1.73205081e+00,   0.00000000e+00]])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{X}
\PYG{g+go}{array([[ \PYGZhy{}1.73205081e+00,   0.00000000e+00],}
\PYG{g+go}{       [ \PYGZhy{}1.00000000e+00,  \PYGZhy{}1.00000000e+00],}
\PYG{g+go}{       [ \PYGZhy{}1.00000000e+00,   0.00000000e+00],}
\PYG{g+go}{       [ \PYGZhy{}1.00000000e+00,   1.00000000e+00],}
\PYG{g+go}{       [  0.00000000e+00,  \PYGZhy{}1.00000000e+00],}
\PYG{g+go}{       [  2.16406754e\PYGZhy{}16,   0.00000000e+00],}
\PYG{g+go}{       [  0.00000000e+00,   1.00000000e+00],}
\PYG{g+go}{       [  1.00000000e+00,  \PYGZhy{}1.00000000e+00],}
\PYG{g+go}{       [  1.00000000e+00,   0.00000000e+00],}
\PYG{g+go}{       [  1.00000000e+00,   1.00000000e+00],}
\PYG{g+go}{       [  1.73205081e+00,   0.00000000e+00]])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tol} \PYG{o}{=} \PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{n}{Misc}\PYG{o}{.}\PYG{n}{machineEpsilon}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{bool\PYGZus{}idx\PYGZus{}over} \PYG{o}{=} \PYG{n}{Misc}\PYG{o}{.}\PYG{n}{findOverlapping}\PYG{p}{(}\PYG{n}{XF}\PYG{p}{,}\PYG{n}{X}\PYG{p}{,}\PYG{n}{tol}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{XF}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{logical\PYGZus{}not}\PYG{p}{(}\PYG{n}{bool\PYGZus{}idx\PYGZus{}over}\PYG{p}{)}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}
\PYG{g+go}{array([[ 0.        , \PYGZhy{}1.73205081],}
\PYG{g+go}{       [ 0.        ,  1.73205081]])}
\end{Verbatim}

\end{fulllineitems}

\index{machineEpsilon() (in module SpectralToolbox.Misc)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.machineEpsilon}\pysiglinewithargsret{\code{SpectralToolbox.Misc.}\bfcode{machineEpsilon}}{\emph{func=\textless{}type `float'\textgreater{}}}{}
Returns the abolute machine precision for the type passed as argument
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{func} (\emph{dtype}) -- type

\item[{Returns}] \leavevmode
absolute machine precision

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Misc}\PYG{o}{.}\PYG{n}{machineEpsilon}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}
\PYG{g+go}{2.2204460492503131e\PYGZhy{}16}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Misc}\PYG{o}{.}\PYG{n}{machineEpsilon}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float128}\PYG{p}{)}
\PYG{g+go}{1.084202172485504434e\PYGZhy{}19}
\end{Verbatim}

\end{fulllineitems}

\index{powerset() (in module SpectralToolbox.Misc)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.powerset}\pysiglinewithargsret{\code{SpectralToolbox.Misc.}\bfcode{powerset}}{\emph{iterable}}{}
Compute the power set of an iterable object.

\end{fulllineitems}

\index{unique\_cuts() (in module SpectralToolbox.Misc)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.Misc.unique_cuts}\pysiglinewithargsret{\code{SpectralToolbox.Misc.}\bfcode{unique\_cuts}}{\emph{X}, \emph{tol}, \emph{retIdxs=False}}{}
Returns the unique values and a list of arrays of boolean indicating the positions of the unique values.
If retIdx is true, then it returns the group of indices with the same values as a indicator function (true-false array)

\end{fulllineitems}



\bigskip\hrule{}\bigskip


Created on Wed Feb 27

@author: Daniele Bigoni (\href{mailto:dabi@dtu.dk}{dabi@dtu.dk})


\chapter{Description}
\label{index:id22}\begin{description}
\item[{This module is used to construct Heterogeneous Sparse Grids. These are integration rules based on Smolyak's Sparse Grids \footnote{\begin{enumerate}
\setcounter{enumi}{18}
\item {} \begin{enumerate}
\item {} 
Smolyak, ``Quadrature and interpolation formulas for tensor products of certain classes of functions''. Soviet Math. Dokl., 4:240243, 1963

\end{enumerate}

\end{enumerate}
} built up in order to provide flexibility for both:}] \leavevmode\begin{enumerate}
\item {} 
the types of polynomials to be used per direction

\item {} 
the accuracy to be used per direction

\end{enumerate}

\end{description}

The types of polynomials available are all the ones included in the module \code{Spectral1D}. The rules don't need to be symmetric and the accuracy per each direction can vary.

For rules with Heterogeneous accuracy, two sparse grids will be construced: one partial sparse grid and one full sparse grid (up to the maximum accuracy). The values computed for the partial sparse grid can then be used to interpolate on the points of the full sparse grid. This latter rule can then be used to compute the integral.


\chapter{References}
\label{index:id24}

\chapter{Examples}
\label{index:id26}
Let's consider the following space \(\Omega = [-\infty,\infty]     imes[0,1]\) with the associated measures \(\mu_1(x)=\frac{1}{\sqrt{2\pi}} e^{-\frac{x^2}{2}}\) and  \(\mu_2(x)=1\) for each dimension. The product measure is given by \(\mu(\bar{x})=\prod_{i=1}^n \mu_i(x_i)\). We will consider the function
\begin{gather}
\begin{split}f(\bar{x}) = x_1^{p_1} \cdot x_2^{p_2}\end{split}\notag
\end{gather}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f\PYGZus{}mult} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{xp}\PYG{p}{,}\PYG{n}{yp}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{n}{xp} \PYG{o}{*} \PYG{n}{y}\PYG{o}{*}\PYG{o}{*}\PYG{n}{yp}
\end{Verbatim}

with exact value of the integral given by
\begin{gather}
\begin{split}\int_\Omega f(\bar{x}) \mu(\bar{x}) = \frac{2^{-1+p_2} \left( 1+(-1)^{p_2} \right) \Gamma\left( \frac{1+p_2}{2} \right)}{(1+p_1)\sqrt{\pi}}\end{split}\notag
\end{gather}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{I\PYGZus{}mult}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,}\PYG{n}{p}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{return} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{o}{.}\PYG{l+m+mi}{5}\PYG{o}{+}\PYG{o}{.}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)} \PYG{o}{*} \PYG{n}{scipy}\PYG{o}{.}\PYG{n}{special}\PYG{o}{.}\PYG{n}{gamma}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{2.}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{n}{p}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Let \(p_1=2\) and \(p_2=4\). We can obtain a sparse grid composed using Hermite basis (\code{Spectral1D.HERMITEP\_PROB}) and Legendre basis (\code{Spectral1D.JACOBI}) with orders 2 and 4 respectively.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{SpectralToolbox} \PYG{k+kn}{import} \PYG{n}{HeterogeneousSparseGrids} \PYG{k}{as} \PYG{n}{HSG}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pH} \PYG{o}{=} \PYG{n}{Spectral1D}\PYG{o}{.}\PYG{n}{Poly1D}\PYG{p}{(}\PYG{n}{Spectral1D}\PYG{o}{.}\PYG{n}{HERMITEP\PYGZus{}PROB}\PYG{p}{,}\PYG{n+nb+bp}{None}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pL} \PYG{o}{=} \PYG{n}{Spectral1D}\PYG{o}{.}\PYG{n}{Poly1D}\PYG{p}{(}\PYG{n}{Spectral1D}\PYG{o}{.}\PYG{n}{JACOBI}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{polys} \PYG{o}{=} \PYG{p}{[}\PYG{n}{pH}\PYG{p}{,}\PYG{n}{pL}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Ns} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sg} \PYG{o}{=} \PYG{n}{HSG}\PYG{o}{.}\PYG{n}{HSparseGrid}\PYG{p}{(}\PYG{n}{polys}\PYG{p}{,}\PYG{n}{Ns}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{(}\PYG{n}{XF}\PYG{p}{,}\PYG{n}{W}\PYG{p}{,}\PYG{n}{X}\PYG{p}{)} \PYG{o}{=} \PYG{n}{sg}\PYG{o}{.}\PYG{n}{sparseGrid}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[SG] Sparse Grid Generation [============================================] 100\PYGZpc{}}
\PYG{g+go}{[SG] Sparse Grid Generation: 0.01s}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{XF}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{XF}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{2.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{X}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{2.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{XF}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{XF}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{o}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{X}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{or}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

The resulting partial and full sparse grids are shown in the following figure.
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{_static/Figures/HeterSparseGrids-GridExample.png}
\caption{Partial (red) and full (blue) sparse grid. The full sparse grid is overlapping over the partial sparse grid.}\label{index:gridexample}\end{figure}

The values on the partial grid can be computed and then the interpolation is taken over the full sparse grid.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fX} \PYG{o}{=} \PYG{n}{f\PYGZus{}mult}\PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{X}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{Q}\PYG{p}{,}\PYG{n}{P}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fXF} \PYG{o}{=} \PYG{n}{sg}\PYG{o}{.}\PYG{n}{sparseGridInterp}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{fX}\PYG{p}{,}\PYG{n}{XF}\PYG{p}{)}
\PYG{g+go}{[SG] Sparse Grid Interpolation [=========================================] 100\PYGZpc{}}
\PYG{g+go}{[SG] Sparse Grid Interpolation: 0.00s}
\end{Verbatim}

Finally the error of the quadrature rule is

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{IErr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{fXF}\PYG{p}{,}\PYG{n}{W}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{I\PYGZus{}mult}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{,}\PYG{n}{P}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{IErr}
\PYG{g+go}{3.33066907388e\PYGZhy{}16}
\end{Verbatim}
\index{HSparseGrid (class in SpectralToolbox.HeterogeneousSparseGrids)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid}\pysiglinewithargsret{\strong{class }\code{SpectralToolbox.HeterogeneousSparseGrids.}\bfcode{HSparseGrid}}{\emph{polys}, \emph{Ns}, \emph{tol=None}, \emph{sdout=\textless{}open file `\textless{}stderr\textgreater{}'}, \emph{mode `w' at 0x2b18a359b270\textgreater{}}}{}
Heterogeneous Sparse Grid class

Constructor of Heterogeneous Sparse Grid object (this does not allocate the sparse grid)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{polys} (list of \code{Spectral1D.Poly1D}) -- orthogonal polynomials to be used as basis functions

\item {} 
\textbf{Ns} (\emph{list of integers}) -- accuracy for each dimension. It can be a list of accuracies or a single accuracy, in which case uniform accuracy is assumed

\item {} 
\textbf{tol} (\emph{float}) -- tolerance to be used when comparing points of the grid (optional, default=:py:func:\emph{Misc.machineEpsilon()})

\item {} 
\textbf{sdout} (\emph{stream}) -- default output stream for the class (optional,default={}`{}`sys.stderr{}`{}`)

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
one of the following must hold: len(polys)==len(Ns) or len(Ns)==1, in which case the same order is used for all the directions.
\end{notice}

\textbf{Example}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{SpectralToolbox} \PYG{k+kn}{import} \PYG{n}{HeterogeneousSparseGrids} \PYG{k}{as} \PYG{n}{HSG}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pH} \PYG{o}{=} \PYG{n}{Spectral1D}\PYG{o}{.}\PYG{n}{Poly1D}\PYG{p}{(}\PYG{n}{Spectral1D}\PYG{o}{.}\PYG{n}{HERMITEP\PYGZus{}PROB}\PYG{p}{,}\PYG{n+nb+bp}{None}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pL} \PYG{o}{=} \PYG{n}{Spectral1D}\PYG{o}{.}\PYG{n}{Poly1D}\PYG{p}{(}\PYG{n}{Spectral1D}\PYG{o}{.}\PYG{n}{JACOBI}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{polys} \PYG{o}{=} \PYG{p}{[}\PYG{n}{pH}\PYG{p}{,}\PYG{n}{pL}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Ns} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sg} \PYG{o}{=} \PYG{n}{HSG}\PYG{o}{.}\PYG{n}{HSparseGrid}\PYG{p}{(}\PYG{n}{polys}\PYG{p}{,}\PYG{n}{Ns}\PYG{p}{)}
\end{Verbatim}
\index{sparseGrid() (SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid.sparseGrid}\pysiglinewithargsret{\bfcode{sparseGrid}}{\emph{heter=False}}{}
Generates the full and partial sparse grids
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{heter} (\emph{bool}) -- if \code{Ns} is homogeneous, this parameter will force the output of the partial sparse grid as well

\item[{Returns}] \leavevmode

tuple \code{(XF,WF,X)} containing:
\begin{itemize}
\item {} 
\code{XF}: full grid points

\item {} 
\code{WF}: full grid weights

\item {} 
\code{X}: partial grid points

\end{itemize}


\end{description}\end{quote}

\textbf{Example}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{(}\PYG{n}{XF}\PYG{p}{,}\PYG{n}{W}\PYG{p}{,}\PYG{n}{X}\PYG{p}{)} \PYG{o}{=} \PYG{n}{sg}\PYG{o}{.}\PYG{n}{sparseGrid}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[SG] Sparse Grid Generation [============================================] 100\PYGZpc{}}
\PYG{g+go}{[SG] Sparse Grid Generation: 0.01s}
\end{Verbatim}

\end{fulllineitems}

\index{sparseGridInterp() (SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid method)}

\begin{fulllineitems}
\phantomsection\label{index:SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid.sparseGridInterp}\pysiglinewithargsret{\bfcode{sparseGridInterp}}{\emph{X}, \emph{fX}, \emph{XF}}{}
Interpolate values of the Sparse Grid using 1D Polynomial interpolation along cuts.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{X} (\emph{2d-array of floats}) -- partial grid on which a function has been evaluated

\item {} 
\textbf{fX} (\emph{1d-array of floats}) -- values for the points in the partial grid

\item {} 
\textbf{XF} (\emph{2d-array of floats}) -- full grid on which to interpolate

\end{itemize}

\item[{Returns}] \leavevmode
\code{fXF} the interpolated values on the full grid

\item[{Return type}] \leavevmode
1d-array of floats

\end{description}\end{quote}

..note:: The partial and full grid must be overlapping

\textbf{Example}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fXF} \PYG{o}{=} \PYG{n}{sg}\PYG{o}{.}\PYG{n}{sparseGridInterp}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{fX}\PYG{p}{,}\PYG{n}{XF}\PYG{p}{)}
\PYG{g+go}{[SG] Sparse Grid Interpolation [=========================================] 100\PYGZpc{}}
\PYG{g+go}{[SG] Sparse Grid Interpolation: 0.00s}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{s}
\item {\texttt{SpectralToolbox}}, \pageref{index:module-SpectralToolbox}
\item {\texttt{SpectralToolbox.Misc}}, \pageref{index:module-SpectralToolbox.Misc}
\item {\texttt{SpectralToolbox.SparseGrids}}, \pageref{index:module-SpectralToolbox.SparseGrids}
\item {\texttt{SpectralToolbox.SpectralND}}, \pageref{index:module-SpectralToolbox.SpectralND}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
