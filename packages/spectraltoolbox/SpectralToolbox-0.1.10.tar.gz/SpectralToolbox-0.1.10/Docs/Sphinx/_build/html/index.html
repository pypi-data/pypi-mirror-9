<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to SpectralToolbox’s documentation! &mdash; SpectralToolbox 0.1a documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="SpectralToolbox 0.1a documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">SpectralToolbox 0.1a documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="welcome-to-spectraltoolbox-s-documentation">
<h1>Welcome to SpectralToolbox&#8217;s documentation!<a class="headerlink" href="#welcome-to-spectraltoolbox-s-documentation" title="Permalink to this headline">¶</a></h1>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<span class="target" id="module-SpectralToolbox"></span><hr class="docutils" />
<p>Created on Thu Mar 29 11:33:32 2012</p>
<p>&#64;author: Daniele Bigoni (<a class="reference external" href="mailto:dabi&#37;&#52;&#48;imm&#46;dtu&#46;dk">dabi<span>&#64;</span>imm<span>&#46;</span>dtu<span>&#46;</span>dk</a>)</p>
<div class="section" id="description">
<h2>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p>Implementation of Spectral Methods in 1 dimension.</p>
<dl class="docutils">
<dt>Available polynomials:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#ref-jacobi"><em>Jacobi Polynomials</em></a> or <tt class="docutils literal"><span class="pre">Spectral1D.JACOBI</span></tt></li>
<li>Hermite Physicist or <tt class="docutils literal"><span class="pre">Spectral1D.HERMITEP</span></tt></li>
<li>Hermite Function or <tt class="docutils literal"><span class="pre">Spectral1D.HERMITEF</span></tt></li>
<li>Hermite Probabilistic or <tt class="docutils literal"><span class="pre">Spectral1D.HERMITEP_PROB</span></tt></li>
<li>Laguerre Polynomial or <tt class="docutils literal"><span class="pre">Spectral1D.LAGUERREP</span></tt></li>
<li>Laguerre Function or <tt class="docutils literal"><span class="pre">Spectral1D.LAGUERREF</span></tt></li>
<li>ORTHPOL package (generation of recursion coefficients using <a class="footnote-reference" href="#id5" id="id1">[4]</a>)  or <tt class="docutils literal"><span class="pre">Spectral1D.ORTHPOL</span></tt></li>
</ul>
</dd>
<dt>Available quadrature rules (related to selected polynomials):</dt>
<dd><ul class="first last simple">
<li>Gauss or <tt class="docutils literal"><span class="pre">Spectral1D.GAUSS</span></tt></li>
<li>Gauss-Lobatto or <tt class="docutils literal"><span class="pre">Spectral1D.GAUSSLOBATTO</span></tt></li>
<li>Gauss-Radau or <tt class="docutils literal"><span class="pre">Spectral1D.GAUSSRADAU</span></tt></li>
</ul>
</dd>
<dt>Available quadrature rules (without polynomial selection):</dt>
<dd><ul class="first last simple">
<li>Kronrod-Patterson on the real line or <tt class="docutils literal"><span class="pre">Spectral1D.KPN</span></tt> (function <tt class="docutils literal"><span class="pre">Spectral1D.kpn(n)</span></tt>)</li>
<li>Kronrod-Patterson uniform or <tt class="docutils literal"><span class="pre">Spectral1D.KPU</span></tt> (function <tt class="docutils literal"><span class="pre">Spectral1D.kpu(n)</span></tt>)</li>
<li>Clenshaw-Curtis or <tt class="docutils literal"><span class="pre">Spectral1D.CC</span></tt> (function <tt class="docutils literal"><span class="pre">Spectral1D.cc(n)</span></tt>)</li>
<li>Fejer&#8217;s or <tt class="docutils literal"><span class="pre">Spectral1D.FEJ</span></tt> (function <tt class="docutils literal"><span class="pre">Spectral1D.fej(n)</span></tt>)</li>
</ul>
</dd>
</dl>
<div class="section" id="jacobi-polynomials">
<span id="ref-jacobi"></span><h3>Jacobi Polynomials<a class="headerlink" href="#jacobi-polynomials" title="Permalink to this headline">¶</a></h3>
<p>Jacobi polynomials are defined on the domain <span class="math">\(\Omega=[-1,1]\)</span> by the recurrence relation</p>
<div class="math">
\[\begin{split}xP^{(\alpha,\beta)}_n(x) =    &amp; \frac{2(n+1)(n+\alpha+\beta+1)}{(2n+\alpha+\beta+1)(2n+\alpha+\beta+2)} P^{(\alpha,\beta)}_{n+1}(x) \
                                &amp; + \frac{\beta^2 - \alpha^2}{(2n+\alpha+\beta)(2n+\alpha+\beta+2)} P^{(\alpha,\beta)}_{n}(x) \
                                &amp; + \frac{2(n+\alpha)(n+\beta)}{(2n+\alpha+\beta)(2n+\alpha+\beta+1)} P^{(\alpha,\beta)}_{n-1}(x)\end{split}\]</div>
<p>with weight function</p>
<div class="math">
\[w(x;\alpha,\beta) = \frac{\Gamma(\alpha+\beta+2)}{2^{\alpha+\beta+1}\Gamma(\alpha+1)\Gamma(\beta+1)}(1-x)^\alpha (1+x)^\beta\]</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In probability theory, the Beta distribution is defined on <span class="math">\(\Psi=[0,1]\)</span> and its the Probability Distribution Function is</p>
<div class="math">
\[\rho_B(x;\alpha,\beta) = \frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)} x^{\alpha-1} (1-x)**(\beta-1)\]</div>
<p>The relation betwen <span class="math">\(w(x;\alpha,\beta)\)</span> and <span class="math">\(\rho_B(x;\alpha,\beta)\)</span> for <span class="math">\(x \in \Psi\)</span> is</p>
<div class="math">
\[\rho_B(x;\alpha,\beta) = 2 * w(2*x-1;\beta-1,\alpha-1)\]</div>
<p>For example:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span><span class="n">stats</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">xp</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span><span class="mf">2.</span><span class="o">*</span><span class="n">Bx</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="s">&#39;--&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span><span class="n">stats</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">xp</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span><span class="mf">2.</span><span class="o">*</span><span class="n">Bx</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="s">&#39;--&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id11">2</a>, <a class="fn-backref" href="#id20">3</a>, <a class="fn-backref" href="#id21">4</a>)</em> &#8220;Implemenenting Spectral Methods for Partial Differential Equations&#8221; by David A. Kopriva, Springer, 2009</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><ol class="first last upperalpha simple" start="10">
<li>Shen and L.L. Wang, “Some recent advances on spectral methods for unbounded domains”. Communications in Computational Physics, vol. 5, no. 2–4, pp. 195–241, 2009</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>W.H. Press, Numerical Recipes: &#8220;The Art of Scientific Computing&#8221;. Cambridge University Press, 2007</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id7">2</a>, <a class="fn-backref" href="#id8">3</a>, <a class="fn-backref" href="#id9">4</a>)</em> <ol class="last upperalpha simple" start="23">
<li>Gautschi, &#8220;Algorithm 726: ORTHPOL &#8211; a package of routines for generating orthogonal polynomials and Gauss-type quadrature rules&#8221;. ACM Trans. Math. Softw., vol. 20, issue 1, pp. 21-62, 1994</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td>Y.Shi-jun, &#8220;Gauss-Radau and Gauss-Lobatto formulae for the Jacobi weight and Gori-Micchelli weight functions&#8221;. Journal of Zhejiang University Science, vol. 3, issue 4, pp. 455-460</td></tr>
</tbody>
</table>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="SpectralToolbox.Spectral1D.Poly1D">
<em class="property">class </em><tt class="descclassname">SpectralToolbox.Spectral1D.</tt><tt class="descname">Poly1D</tt><big>(</big><em>poly</em>, <em>params</em>, <em>sdout=&lt;open file '&lt;stderr&gt;'</em>, <em>mode 'w' at 0x2b81fc700270&gt;</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization of the Polynomial instance.</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">Poly1D(poly,params)</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">poly</span></tt> = The orthogonal polynomial type desired</li>
<li><tt class="docutils literal"><span class="pre">params</span></tt> = The parameters needed by the selected polynomial</li>
<li><tt class="docutils literal"><span class="pre">sdout</span></tt> = (optional,default=sys.stderr) output stream for logging</li>
</ul>
</dd>
<dt>Description:</dt>
<dd><p class="first">This method generates an instance of the Poly1D class, to be used in order to generate
orthogonal basis of the polynomial type selected. Avaliable polynomial types can be
selected using their string name or by predefined attributes</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;Jacobi&#8217; or <tt class="docutils literal"><span class="pre">Spectral1D.JACOBI</span></tt></li>
<li>&#8216;HermiteP&#8217; or <tt class="docutils literal"><span class="pre">Spectral1D.HERMITEP</span></tt></li>
<li>&#8216;HermiteF&#8217; or <tt class="docutils literal"><span class="pre">Spectral1D.HERMITEF</span></tt></li>
<li>&#8216;HermitePprob&#8217; or <tt class="docutils literal"><span class="pre">Spectral1D.HERMITEP_PROB</span></tt></li>
<li>&#8216;LaguerreP&#8217; or <tt class="docutils literal"><span class="pre">Spectral1D.LAGUERREP</span></tt></li>
<li>&#8216;LaguerreF&#8217; or <tt class="docutils literal"><span class="pre">Spectral1D.LAGUERREF</span></tt></li>
<li>&#8216;ORTHPOL&#8217; or <tt class="docutils literal"><span class="pre">Spectral1D.ORTHPOL</span></tt></li>
</ul>
</div></blockquote>
<p>Additional parameters are required for some polynomials.</p>
<table border="1" class="last docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Polynomial</th>
<th class="head">Parameters</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Jacobi</td>
<td>(alpha,beta)</td>
</tr>
<tr class="row-odd"><td>HermiteP</td>
<td>None</td>
</tr>
<tr class="row-even"><td>HermiteF</td>
<td>None</td>
</tr>
<tr class="row-odd"><td>HermitePprob</td>
<td>None</td>
</tr>
<tr class="row-even"><td>LaguerreP</td>
<td>alpha</td>
</tr>
<tr class="row-odd"><td>LaguerreF</td>
<td>alpha</td>
</tr>
<tr class="row-even"><td>ORTHPOL</td>
<td>see notes</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The ORTHPOL polynomials are built up using the &#8220;Multiple-Component Discretization Procedure&#8221; described in <a class="footnote-reference" href="#id5" id="id7">[4]</a>. The following parameters describing the measure function are required in order to use the procedure for finding the recursion coefficients (alpha,beta) and have to be provided at construction time:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">ncapm</span></tt>: (int) maximum integer N0 (default = 500)</li>
<li><tt class="docutils literal"><span class="pre">mc</span></tt>: (int) number of component intervals in the continuous part of the spectrum</li>
<li><tt class="docutils literal"><span class="pre">mp</span></tt>: (int) number of points in the discrete part of the spectrum. If the measure has no discrete part, set mp=0</li>
<li><tt class="docutils literal"><span class="pre">xp</span></tt>, <tt class="docutils literal"><span class="pre">yp</span></tt>: (Numpy 1d-array) of dimension mp, containing the abscissas and the jumps of the point spectrum</li>
<li><tt class="docutils literal"><span class="pre">mu</span></tt>: (function) measure function that returns the mass (float) with arguments: <tt class="docutils literal"><span class="pre">x</span></tt> (float) absissa, <tt class="docutils literal"><span class="pre">i</span></tt> (int) interval number in the continuous part</li>
<li><tt class="docutils literal"><span class="pre">irout</span></tt>: (int) selects the routine for generating the recursion coefficients from the discrete inner product; <tt class="docutils literal"><span class="pre">irout=1</span></tt> selects the routine <tt class="docutils literal"><span class="pre">sti</span></tt>, <tt class="docutils literal"><span class="pre">irout!=1</span></tt> selects the routine <tt class="docutils literal"><span class="pre">lancz</span></tt></li>
<li><tt class="docutils literal"><span class="pre">finl</span></tt>, <tt class="docutils literal"><span class="pre">finr</span></tt>: (bool) specify whether the extreme left/right interval is finite (false for infinite)</li>
<li><tt class="docutils literal"><span class="pre">endl</span></tt>, <tt class="docutils literal"><span class="pre">endr</span></tt>: (Numpy 1d-array) of dimension <tt class="docutils literal"><span class="pre">mc</span></tt> containing the left and right endpoints of the component intervals. If the first of these extends to -infinity, endl[0] is not being used by the routine.</li>
</ul>
</div></blockquote>
<p class="last">Parameters <tt class="docutils literal"><span class="pre">iq</span></tt>, <tt class="docutils literal"><span class="pre">quad</span></tt>, <tt class="docutils literal"><span class="pre">idelta</span></tt> in <a class="footnote-reference" href="#id5" id="id8">[4]</a> are suppressed. Instead the routine <tt class="docutils literal"><span class="pre">qgp</span></tt> of ORTHPOL <a class="footnote-reference" href="#id5" id="id9">[4]</a> is used by default (<tt class="docutils literal"><span class="pre">iq=0</span></tt> and <tt class="docutils literal"><span class="pre">idelta=2</span></tt>)</p>
</div>
<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.AssemblyDerivativeMatrix">
<tt class="descname">AssemblyDerivativeMatrix</tt><big>(</big><em>x</em>, <em>N</em>, <em>k</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.AssemblyDerivativeMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>AssemblyDerivativeMatrix(): Assemble the k-th derivative matrix using polynomials of order N.</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">Dk</span> <span class="pre">=</span> <span class="pre">AssemblyDerivativeMatrix(x,N,k)</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li>x = (1d-array,float) Set of points on which to evaluate the polynomials</li>
<li>N = (int) maximum order in the vanermonde matrix</li>
<li>k = (int) derivative order</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li>Dk = Derivative matrix</li>
</ul>
</dd>
<dt>Description:</dt>
<dd>This function performs <tt class="docutils literal"><span class="pre">D</span> <span class="pre">=</span> <span class="pre">linalg.solve(V.T,</span> <span class="pre">Vx.T)</span></tt> where <tt class="docutils literal"><span class="pre">V</span></tt> and <tt class="docutils literal"><span class="pre">Vx</span></tt> are a Generalized Vandermonde Matrix and its derivative respectively.</dd>
<dt>Notes:</dt>
<dd>For Chebyshev Polynomial, this function refers to the recursion form implemented in <tt class="docutils literal"><span class="pre">PolynomialDerivativeMatrix</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.ChebyshevDerivativeCoefficients">
<tt class="descname">ChebyshevDerivativeCoefficients</tt><big>(</big><em>fhat</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.ChebyshevDerivativeCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>ChebyshevDerivativeCoefficients(): computes the Chebyshev coefficients of the derivative of a function</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">dfhat</span> <span class="pre">=</span> <span class="pre">ChebyshevDerivativeCoefficients(fhat)</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">fhat</span></tt> = (1d-array,float) list of Chebyshev coefficients of the original function</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">dfhat</span></tt> = (1d-array,float) list of Chebyshev coefficients of the derivative of the original function</li>
</ul>
</dd>
<dt>Notes:</dt>
<dd>Algorithm (5) from <a class="footnote-reference" href="#id2" id="id10">[1]</a></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.DiscretePolynomialTransform">
<tt class="descname">DiscretePolynomialTransform</tt><big>(</big><em>r</em>, <em>f</em>, <em>N</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.DiscretePolynomialTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>DiscretePolynomialTransform(): computes the Discrete Polynomial Transform of function values f</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">fhat</span> <span class="pre">=</span> <span class="pre">DiscretePolynomialTransform(r,</span> <span class="pre">f,</span> <span class="pre">N)</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">r</span></tt> = (1d-array,float) set of points on which to the polynomials are evaluated</li>
<li><tt class="docutils literal"><span class="pre">f</span></tt> = (1d-array,float) function values</li>
<li><tt class="docutils literal"><span class="pre">N</span></tt> = (int) maximum order in the generalized vanermonde matrix</li>
</ul>
</dd>
<dt>Output: one of the two following output is given, depending on the length of r</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">(fhat,</span> <span class="pre">residues,</span> <span class="pre">rank,s)</span></tt> = list of Polynomial coefficients and additional ouputs from function <tt class="docutils literal"><span class="pre">numpy.linalg.lstsq</span></tt> (if len(r) &gt; N+1)</li>
</ul>
</dd>
<dt>Description:</dt>
<dd>If the Chebyshev polynomials are chosen and <tt class="docutils literal"><span class="pre">r</span></tt> contains Chebyshev-Gauss-Lobatto points, the Fast Chebyshev Transform is used. Otherwise uses the Generalized Vandermonde Matrix in order to transform from physical space to transform space.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">FastChebyshevTransform</p>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.FastChebyshevTransform">
<tt class="descname">FastChebyshevTransform</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.FastChebyshevTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>FastChebyshevTransform(): Returns the coefficients of the Fast Chebyshev Transform.</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">fhat</span> <span class="pre">=</span> <span class="pre">FastChebyshevTransform(f)</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> = (1d-array,float) function values</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">fhat</span></tt> = (1d-array,float) list of Polynomial coefficients</li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is assumed that the values f are computed at Chebyshev-Gauss-Lobatto points.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If f is odd, the vector is interpolated to even Chebyshev-Gauss-Lobatto points.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Modification of algorithm (29) from <a class="footnote-reference" href="#id2" id="id11">[1]</a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.Gamma">
<tt class="descname">Gamma</tt><big>(</big><em>N</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.Gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Gamma(): returns the normalization constant for the N-th polynomial</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">g</span> <span class="pre">=</span> <span class="pre">Gamma(N)</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">N</span></tt> = polynomial order</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">g</span></tt> = normalization constant</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.GaussLobattoQuadrature">
<tt class="descname">GaussLobattoQuadrature</tt><big>(</big><em>N</em>, <em>normed=False</em>, <em>left=None</em>, <em>right=None</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.GaussLobattoQuadrature" title="Permalink to this definition">¶</a></dt>
<dd><p>GaussLobattoQuadrature(): Generates list of nodes for the Gauss-Lobatto quadrature rule using selected Polynomial basis</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">GaussLobattoQuadrature(N,[normed=False],[left=None],[right=None])</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">N</span></tt> = (int) accuracy level required</li>
<li><tt class="docutils literal"><span class="pre">normed</span></tt> = (optional,bool) whether the weights will be normalized or not</li>
<li><tt class="docutils literal"><span class="pre">left</span></tt> = (optional,float) containing the left endpoint (used by ORTHPOL)</li>
<li><tt class="docutils literal"><span class="pre">right</span></tt> = (optional,float) containing the right endpoint (used by ORTHPOL)</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> = (1d-array,float) containing the nodes</li>
<li><tt class="docutils literal"><span class="pre">w</span></tt> = (1d-array,float) containing the weights</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Available only for Jacobi Polynomials and ORTHPOL</p>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.GaussQuadrature">
<tt class="descname">GaussQuadrature</tt><big>(</big><em>N</em>, <em>normed=False</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.GaussQuadrature" title="Permalink to this definition">¶</a></dt>
<dd><p>GaussQuadrature(): Generates list of nodes and weights for the Gauss quadrature rule using the selected Polynomial basis</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">(x,w)</span> <span class="pre">=</span> <span class="pre">GaussQuadrature(N,[normed=False])</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">N</span></tt> = (int) accuracy level required</li>
<li><tt class="docutils literal"><span class="pre">normed</span></tt> = (optional,bool) whether the weights will be normalized or not</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> = (1d-array,float) containing the nodes</li>
<li><tt class="docutils literal"><span class="pre">w</span></tt> = (1d-array,float) containing the weights</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.GaussRadauQuadrature">
<tt class="descname">GaussRadauQuadrature</tt><big>(</big><em>N</em>, <em>normed=False</em>, <em>end=None</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.GaussRadauQuadrature" title="Permalink to this definition">¶</a></dt>
<dd><p>GaussRadauQuadrature(): Generates list of nodes for the Gauss-Radau quadrature rule using selected Polynomial basis</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><a href="#id12"><span class="problematic" id="id13">``</span></a>x = GaussRadauQuadrature(N,[normed=False],[end=None])&#8217;&#8216;</dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><a href="#id14"><span class="problematic" id="id15">``</span></a>N&#8217;&#8217; = (int) accuracy level required</li>
<li><tt class="docutils literal"><span class="pre">normed</span></tt> = (optional,bool) whether the weights will be normalized or not</li>
<li><tt class="docutils literal"><span class="pre">end</span></tt> = (optional,float) containing the endpoint (used by ORTHPOL)</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><a href="#id16"><span class="problematic" id="id17">``</span></a>x&#8217;&#8217; = (1d-array,float) containing the nodes</li>
<li><a href="#id18"><span class="problematic" id="id19">``</span></a>w&#8217;&#8217; = (1d-array,float) weights</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Available only for Laguerre Polynomials/Functions and ORTHPOL</p>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.GradEvaluate">
<tt class="descname">GradEvaluate</tt><big>(</big><em>r</em>, <em>N</em>, <em>k</em>, <em>norm=True</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.GradEvaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>GradEvaluate(): evaluate the <tt class="docutils literal"><span class="pre">k</span></tt>-th derivative of the <tt class="docutils literal"><span class="pre">N</span></tt>-th order polynomial at points <tt class="docutils literal"><span class="pre">r</span></tt></p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">GradEvaluate(r,N,k[,norm=True])</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">r</span></tt> = (1d-array,float) set of points on which to evaluate the polynomial</li>
<li><tt class="docutils literal"><span class="pre">N</span></tt> = (int) order of the polynomial</li>
<li><tt class="docutils literal"><span class="pre">k</span></tt> = (int) order of the derivative</li>
<li><tt class="docutils literal"><span class="pre">norm</span></tt> = (bool) whether to return normalized (True) or non normalized (False) polynomials</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">P</span></tt> = Polynomial evaluated on <tt class="docutils literal"><span class="pre">r</span></tt></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.GradVandermonde1D">
<tt class="descname">GradVandermonde1D</tt><big>(</big><em>r</em>, <em>N</em>, <em>k</em>, <em>norm=True</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.GradVandermonde1D" title="Permalink to this definition">¶</a></dt>
<dd><p>GradVandermonde1D(): Initialize the <tt class="docutils literal"><span class="pre">k</span></tt>-th gradient of the modal basis <tt class="docutils literal"><span class="pre">N</span></tt> at <tt class="docutils literal"><span class="pre">r</span></tt></p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">V</span> <span class="pre">=</span> <span class="pre">GradVandermonde1D(r,N,k,[norm])</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">r</span></tt> = (1d-array,float) set of <tt class="docutils literal"><span class="pre">M</span></tt> points on which to evaluate the polynomials</li>
<li><tt class="docutils literal"><span class="pre">N</span></tt> = (int) maximum order in the vanermonde matrix</li>
<li><tt class="docutils literal"><span class="pre">k</span></tt> = (int) derivative order</li>
<li><tt class="docutils literal"><span class="pre">norm</span></tt> = (optional,boolean) True -&gt; orthonormal polynomials, False -&gt; non orthonormal polynomials</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">V</span></tt> = (2d-array(<tt class="docutils literal"><span class="pre">MxN</span></tt>),float) Generalized Vandermonde matrix</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.GramSchmidt">
<tt class="descname">GramSchmidt</tt><big>(</big><em>p</em>, <em>N</em>, <em>w</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.GramSchmidt" title="Permalink to this definition">¶</a></dt>
<dd><p>GramSchmidt(): creates a Generalized Vandermonde Matrix of orthonormal polynomials with respect to the weights <tt class="docutils literal"><span class="pre">w</span></tt></p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">V</span> <span class="pre">=</span> <span class="pre">GramSchmidt(p,</span> <span class="pre">N,</span> <span class="pre">w)</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">p</span></tt> = (1d-array,float) points at which to evaluate the new polynomials</li>
<li><tt class="docutils literal"><span class="pre">N</span></tt> = (int) the maximum order of the polynomials</li>
<li><tt class="docutils literal"><span class="pre">w</span></tt> = (1d-array,float) weights to be used for the orthogonoalization</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">V</span></tt> = Generalized Vandermonde Matrix containing the new orthogonalized polynomials</li>
</ul>
</dd>
<dt>Description:</dt>
<dd>Takes the points where the polynomials have to be evaluated and computes a Generalized Gram Schmidth procedure, where a weighted projection is used. If <tt class="docutils literal"><span class="pre">w==1</span></tt> then the usual inner product is used for the orthogonal projection.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.InverseDiscretePolynomialTransform">
<tt class="descname">InverseDiscretePolynomialTransform</tt><big>(</big><em>r</em>, <em>fhat</em>, <em>N</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.InverseDiscretePolynomialTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>InverseDiscretePolynomialTransform(): computes the nodal values from the modal form fhat.</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">InverseDiscretePolynomialTransform(r,</span> <span class="pre">fhat,</span> <span class="pre">alpha,</span> <span class="pre">beta,</span> <span class="pre">N)</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> = (1d-array,float) set of points on which to the polynomials are evaluated</li>
<li><tt class="docutils literal"><span class="pre">fhat</span></tt> = (1d-array,float) list of Polynomial coefficients</li>
<li><tt class="docutils literal"><span class="pre">N</span></tt> = (int) maximum order in the generalized vanermonde matrix</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> = (1d-array,float) function values</li>
</ul>
</dd>
<dt>Description:</dt>
<dd>If the Chebyshev polynomials are chosen and r contains Chebyshev-Gauss-Lobatto points, the Inverse Fast Chebyshev Transform is used. Otherwise uses the Generalized Vandermonde Matrix in order to transform from transform space to physical space.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">InverseFastChebyshevTransform</p>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.InverseFastChebyshevTransform">
<tt class="descname">InverseFastChebyshevTransform</tt><big>(</big><em>fhat</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.InverseFastChebyshevTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>InverseFastChebyshevTransform(): Returns the coefficients of the Inverse Fast Chebyshev Transform.</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">InverseFastChebyshevTransform(fhat)</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">fhat</span></tt> = (1d-array,float) list of Polynomial coefficients</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> = (1d-array,float) function values</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If f is odd, the vector is padded with a zero value (highest freq.)</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Modification of algorithm (29) from <a class="footnote-reference" href="#id2" id="id20">[1]</a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.LegendreDerivativeCoefficients">
<tt class="descname">LegendreDerivativeCoefficients</tt><big>(</big><em>fhat</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.LegendreDerivativeCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>LegendreDerivativeCoefficients(): computes the Legendre coefficients of the derivative of a function</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">dfhat</span> <span class="pre">=</span> <span class="pre">LegendreDerivativeCoefficients(fhat)</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">fhat</span></tt> = (1d-array,float) list of Legendre coefficients of the original function</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">dfhat</span></tt> = (1d-array,float) list of Legendre coefficients of the derivative of the original function</li>
</ul>
</dd>
<dt>Notes:</dt>
<dd>Algorithm (4) from <a class="footnote-reference" href="#id2" id="id21">[1]</a></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.PolyInterp">
<tt class="descname">PolyInterp</tt><big>(</big><em>x</em>, <em>f</em>, <em>xi</em>, <em>order</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.PolyInterp" title="Permalink to this definition">¶</a></dt>
<dd><p>PolyInterp(): Interpolate function values <tt class="docutils literal"><span class="pre">f</span></tt> from points <tt class="docutils literal"><span class="pre">x</span></tt> to points <tt class="docutils literal"><span class="pre">xi</span></tt> using Forward and Backward Polynomial Transform</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">fi</span> <span class="pre">=</span> <span class="pre">PolyInterp(x,</span> <span class="pre">f,</span> <span class="pre">xi)</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> = (1d-array,float) set of <tt class="docutils literal"><span class="pre">N</span></tt> original points where <tt class="docutils literal"><span class="pre">f</span></tt> is evaluated</li>
<li><tt class="docutils literal"><span class="pre">f</span></tt> = (1d-array,float) set of <tt class="docutils literal"><span class="pre">N</span></tt> function values</li>
<li><tt class="docutils literal"><span class="pre">xi</span></tt> = (1d-array,float) set of <tt class="docutils literal"><span class="pre">M</span></tt> points where the function is interpolated</li>
<li><tt class="docutils literal"><span class="pre">order</span></tt> = (integer) order of polynomial interpolation</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">fi</span></tt> = (1d-array,float) set of <tt class="docutils literal"><span class="pre">M</span></tt> function values</li>
</ul>
</dd>
</dl>
<p>Notes:</p>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Spectral1D.Poly1D.Quadrature">
<tt class="descname">Quadrature</tt><big>(</big><em>N</em>, <em>quadType=None</em>, <em>normed=False</em>, <em>left=None</em>, <em>right=None</em>, <em>end=None</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Spectral1D.Poly1D.Quadrature" title="Permalink to this definition">¶</a></dt>
<dd><p>Quadrature(): Generates list of nodes and weights for the <tt class="docutils literal"><span class="pre">quadType</span></tt> quadrature rule using the selected Polynomial basis</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">(x,w)</span> <span class="pre">=</span> <span class="pre">Quadrature(N,</span> <span class="pre">[quadType=None],</span> <span class="pre">[normed=False],</span> <span class="pre">[left=None],</span> <span class="pre">[right=None],</span> <span class="pre">[end=None])</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">N</span></tt> = (int) accuracy level required</li>
<li><tt class="docutils literal"><span class="pre">quadType</span></tt> = (<tt class="docutils literal"><span class="pre">AVAIL_POLYS</span></tt>) type of quadrature to be used. Default is Gauss quadrature rule.</li>
<li><tt class="docutils literal"><span class="pre">normed</span></tt> = (optional,bool) whether the weights will be normalized or not</li>
<li><tt class="docutils literal"><span class="pre">left</span></tt> = (optional,float) containing the left endpoint (used by ORTHPOL Gauss-Lobatto rules)</li>
<li><tt class="docutils literal"><span class="pre">right</span></tt> = (optional,float) containing the right endpoint (used by ORTHPOL Gauss-Lobatto rules)</li>
<li><tt class="docutils literal"><span class="pre">end</span></tt> = (optional,float) containing the endpoint (used by ORTHPOL Gauss-Radau rules)</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> = (1d-array,float) containing the nodes</li>
<li><tt class="docutils literal"><span class="pre">w</span></tt> = (1d-array,float) containing the weights</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-SpectralToolbox.SpectralND"></span><div class="section" id="spectral-nd">
<h2>Spectral ND<a class="headerlink" href="#spectral-nd" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Jul  9 11:35:12 2012</p>
<p>&#64;author: Daniele Bigoni (<a class="reference external" href="mailto:dabi&#37;&#52;&#48;imm&#46;dtu&#46;dk">dabi<span>&#64;</span>imm<span>&#46;</span>dtu<span>&#46;</span>dk</a>)</p>
<p>Implementation of Spectral Methods in n dimension.</p>
<p>It uses the package <tt class="docutils literal"><span class="pre">Spectral1D</span></tt> as basic polynomials in order to construct higher dimensional rules by tensor product.</p>
<dl class="class">
<dt id="SpectralToolbox.SpectralND.PolyND">
<em class="property">class </em><tt class="descclassname">SpectralToolbox.SpectralND.</tt><tt class="descname">PolyND</tt><big>(</big><em>polys</em><big>)</big><a class="headerlink" href="#SpectralToolbox.SpectralND.PolyND" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization of the N-dimensional Polynomial instance</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">PolyND(polys)</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">polys</span></tt> = (list,Spectral1D.Poly1D) list of polynomial instances of the class <tt class="docutils literal"><span class="pre">Spectral1D.Poly1D</span></tt></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Spectral1D.Poly1D</p>
</div>
<dl class="method">
<dt id="SpectralToolbox.SpectralND.PolyND.GaussLobattoQuadrature">
<tt class="descname">GaussLobattoQuadrature</tt><big>(</big><em>Ns</em>, <em>normed=False</em>, <em>warnings=True</em><big>)</big><a class="headerlink" href="#SpectralToolbox.SpectralND.PolyND.GaussLobattoQuadrature" title="Permalink to this definition">¶</a></dt>
<dd><p>GaussLobattoQuadrature(): computes the tensor product of the Guass Lobatto Points and weights</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">(x,w)</span> <span class="pre">=</span> <span class="pre">GaussLobattoQuadrature(Ns,[normed=False],[warnings=True])</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">Ns</span></tt> = (list,int) n-dimensional list with the order of approximation of each polynomial</li>
<li><tt class="docutils literal"><span class="pre">normed</span></tt> = (optional,boolean) whether the weights will be normalized or not</li>
<li><tt class="docutils literal"><span class="pre">warnings</span></tt> = (optional,boolean) set whether to ask for confirmation when it is required to allocate more then 100Mb of memory</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> = tensor product of the collocation points</li>
<li><tt class="docutils literal"><span class="pre">w</span></tt> = tensor product of the weights</li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The lengths of <tt class="docutils literal"><span class="pre">Ns</span></tt> has to be conform to the number of polynomials with which you have instantiated <tt class="docutils literal"><span class="pre">PolyND</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.SpectralND.PolyND.GaussQuadrature">
<tt class="descname">GaussQuadrature</tt><big>(</big><em>Ns</em>, <em>normed=False</em>, <em>warnings=True</em><big>)</big><a class="headerlink" href="#SpectralToolbox.SpectralND.PolyND.GaussQuadrature" title="Permalink to this definition">¶</a></dt>
<dd><p>GaussQuadrature(): computes the tensor product of the Guass Points and weights</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">(x,w)</span> <span class="pre">=</span> <span class="pre">GaussQuadrature(Ns,</span> <span class="pre">[normed=False],[warnings=True])</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">Ns</span></tt> = (list,int) n-dimensional list with the order of approximation of each polynomial</li>
<li><tt class="docutils literal"><span class="pre">normed</span></tt> = (optional,boolean) whether the weights will be normalized or not</li>
<li><tt class="docutils literal"><span class="pre">warnings</span></tt> = (optional,boolean) set whether to ask for confirmation when it is required to allocate more then 100Mb of memory</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> = tensor product of the collocation points</li>
<li><tt class="docutils literal"><span class="pre">w</span></tt> = tensor product of the weights</li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The lengths of <tt class="docutils literal"><span class="pre">Ns</span></tt> has to be conform to the number of polynomials with which you have instantiated <tt class="docutils literal"><span class="pre">PolyND</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.SpectralND.PolyND.GradVandermonde">
<tt class="descname">GradVandermonde</tt><big>(</big><em>rs</em>, <em>Ns</em>, <em>ks</em>, <em>norms=None</em>, <em>usekron=True</em>, <em>output=True</em>, <em>warnings=True</em><big>)</big><a class="headerlink" href="#SpectralToolbox.SpectralND.PolyND.GradVandermonde" title="Permalink to this definition">¶</a></dt>
<dd><p>GradVandermonde(): initialize the tensor product of the k-th gradient of the modal basis.</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">V</span> <span class="pre">=</span> <span class="pre">GradVandermonde(r,N,k,[norms=None],[usekron=True],[output=True],[warnings=True])</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">rs</span></tt> = (list of 1d-array,float) <tt class="docutils literal"><span class="pre">n</span></tt>-dimensional list of set of points on which to evaluate the polynomials (by default they are not the kron product of the points. See <tt class="docutils literal"><span class="pre">usekron</span></tt> option)</li>
<li><tt class="docutils literal"><span class="pre">Ns</span></tt> = (list,int) n-dimensional list with the maximum orders of approximation of each polynomial</li>
<li><tt class="docutils literal"><span class="pre">ks</span></tt> = (list,int) n-dimensional list with derivative orders</li>
<li><tt class="docutils literal"><span class="pre">norms</span></tt> = (default=None,list,boolean) n-dimensional list of boolean, True -&gt; orthonormal, False -&gt; orthogonal, None -&gt; all orthonormal</li>
<li><tt class="docutils literal"><span class="pre">usekron</span></tt> = (optional,boolean) set whether to apply the kron product of the single dimensional Vandermonde matrices or to multiply column-wise. kron(rs) and usekron==False is equal to rs and usekron==True</li>
<li><tt class="docutils literal"><span class="pre">output</span></tt> = (optional,boolean) set whether to print out information about memory allocation</li>
<li><tt class="docutils literal"><span class="pre">warnings</span></tt> = (optional,boolean) set whether to ask for confirmation when it is required to allocate more then 100Mb of memory</li>
</ul>
</dd>
<dt>OUTPUT:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">V</span></tt> = Tensor product of the Generalized Vandermonde matrices</li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The lengths of <tt class="docutils literal"><span class="pre">Ns</span></tt> , <tt class="docutils literal"><span class="pre">rs</span></tt> , <tt class="docutils literal"><span class="pre">ks</span></tt> , <tt class="docutils literal"><span class="pre">norms</span></tt> has to be conform to the number of polynomials with which you have instantiated <tt class="docutils literal"><span class="pre">PolyND</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.SpectralND.PolyND.GradVandermondePascalSimplex">
<tt class="descname">GradVandermondePascalSimplex</tt><big>(</big><em>rs</em>, <em>N</em>, <em>ks</em>, <em>norms=None</em>, <em>usekron=True</em>, <em>output=True</em>, <em>warnings=True</em><big>)</big><a class="headerlink" href="#SpectralToolbox.SpectralND.PolyND.GradVandermondePascalSimplex" title="Permalink to this definition">¶</a></dt>
<dd><p>GradVandermondePascalSimplex(): initialize k-th gradient of the modal basis up to the total order N</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">V</span> <span class="pre">=</span> <span class="pre">GradVandermonde(r,N,k,[norms=None],[output=True],[warnings=True])</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">rs</span></tt> = (list of 1d-array,float) <tt class="docutils literal"><span class="pre">n</span></tt>-dimensional list of set of points on which to evaluate the polynomials (by default they are not the kron product of the points. See <tt class="docutils literal"><span class="pre">usekron</span></tt> option)</li>
<li><tt class="docutils literal"><span class="pre">N</span></tt> = (int) the maximum orders of the polynomial basis</li>
<li><tt class="docutils literal"><span class="pre">ks</span></tt> = (list,int) n-dimensional list with derivative orders</li>
<li><tt class="docutils literal"><span class="pre">norms</span></tt> = (default=None,list,boolean) n-dimensional list of boolean, True -&gt; orthonormal, False -&gt; orthogonal, None -&gt; all orthonormal</li>
<li><tt class="docutils literal"><span class="pre">usekron</span></tt> = (optional,boolean) set whether to apply the kron product of the single dimensional Vandermonde matrices or to multiply column-wise. kron(rs) and usekron==False is equal to rs and usekron==True</li>
<li><tt class="docutils literal"><span class="pre">output</span></tt> = (optional,boolean) set whether to print out information about memory allocation</li>
<li><tt class="docutils literal"><span class="pre">warnings</span></tt> = (optional,boolean) set whether to ask for confirmation when it is required to allocate more then 100Mb of memory</li>
</ul>
</dd>
<dt>OUTPUT:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">V</span></tt> = Generalized Vandermonde matrix up to the N-th order</li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The lengths of <tt class="docutils literal"><span class="pre">rs</span></tt> , <tt class="docutils literal"><span class="pre">ks</span></tt> , <tt class="docutils literal"><span class="pre">norms</span></tt> has to be conform to the number of polynomials with which you have instantiated <tt class="docutils literal"><span class="pre">PolyND</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.SpectralND.PolyND.Quadrature">
<tt class="descname">Quadrature</tt><big>(</big><em>Ns</em>, <em>quadTypes=None</em>, <em>left=None</em>, <em>right=None</em>, <em>end=None</em>, <em>normed=False</em>, <em>warnings=True</em><big>)</big><a class="headerlink" href="#SpectralToolbox.SpectralND.PolyND.Quadrature" title="Permalink to this definition">¶</a></dt>
<dd><p>GaussQuadrature(): computes the tensor product of the Guass Points and weights</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">(x,w)</span> <span class="pre">=</span> <span class="pre">GaussQuadrature(Ns,</span> <span class="pre">[quadTypes=None],</span> <span class="pre">[normed=False],[warnings=True])</span></tt></dd>
<dt>Input:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">Ns</span></tt> = (list,int) n-dimensional list with the order of approximation of each polynomial</li>
<li><tt class="docutils literal"><span class="pre">quadTypes</span></tt> = (list,``Spectral1D.AVAIL_QUADPOINTS``) n-dimensional list of quadrature point types chosen among Gauss, Gauss-Radau, Gauss-Lobatto (using the definition in <tt class="docutils literal"><span class="pre">Spectral1D</span></tt>). If None, Gauss points will be generated by default</li>
<li><tt class="docutils literal"><span class="pre">left</span></tt>: (list,float) list of left values used by ORTHPOL for Gauss-Lobatto rules (the dimensions where the value is not used can be set to anything)</li>
<li><tt class="docutils literal"><span class="pre">right</span></tt>: (list,float) list of left values used by ORTHPOL for Gauss-Lobatto rules (the dimensions where the value is not used can be set to anything)</li>
<li><tt class="docutils literal"><span class="pre">end</span></tt>: (list,float) list of left values used by ORTHPOL for Gauss-Radau rules (the dimensions where the value is not used can be set to anything)</li>
<li><tt class="docutils literal"><span class="pre">normed</span></tt> = (optional,boolean) whether the weights will be normalized or not</li>
<li><tt class="docutils literal"><span class="pre">warnings</span></tt> = (optional,boolean) set whether to ask for confirmation when it is required to allocate more then 100Mb of memory</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">x</span></tt> = tensor product of the collocation points</li>
<li><tt class="docutils literal"><span class="pre">w</span></tt> = tensor product of the weights</li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The lengths of <tt class="docutils literal"><span class="pre">Ns</span></tt> has to be conform to the number of polynomials with which you have instantiated <tt class="docutils literal"><span class="pre">PolyND</span></tt></p>
</div>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-SpectralToolbox.SparseGrids"></span><div class="section" id="sparse-grids">
<h2>Sparse Grids<a class="headerlink" href="#sparse-grids" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Jul  9 14:08:30 2012</p>
<p>&#64;author: Daniele Bigoni (<a class="reference external" href="mailto:dabi&#37;&#52;&#48;imm&#46;dtu&#46;dk">dabi<span>&#64;</span>imm<span>&#46;</span>dtu<span>&#46;</span>dk</a>)</p>
<p>Implementation of Sparse Grid (Smolyak) methods for numerical integration.</p>
<p>This implementation is a porting of the Sparse-Grid package developped in MatLab(R) at <a class="reference external" href="http://www.sparse-grids.de">http://www.sparse-grids.de</a>
The code is extended with Clenshaw-Curtis and Fejer quadrature rules [1]</p>
<p>&#64;copyright: 2007 Florian Heiss, Viktor Winschel</p>
<p>&#64;copyright: 2012-2014 Daniele Bigoni</p>
<dl class="class">
<dt id="SpectralToolbox.SparseGrids.SparseGrid">
<em class="property">class </em><tt class="descclassname">SpectralToolbox.SparseGrids.</tt><tt class="descname">SparseGrid</tt><big>(</big><em>qrule</em>, <em>dim</em>, <em>k</em>, <em>sym</em><big>)</big><a class="headerlink" href="#SpectralToolbox.SparseGrids.SparseGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization of the Sparse Grid instance.</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd>sg = SparseGrid(qrule, dim, k, sym)</dd>
<dt>Input: </dt>
<dd><ul class="first last simple">
<li>qrule = Function of 1D integration rule</li>
<li>dim  = dimension of the integration problem</li>
<li>k    = Accuracy level. The rule will be exact for polynomial up to total order 2k-1</li>
<li>sym  = (optional) only used for own 1D quadrature rule (type not &#8220;KPU&#8221;,...). If sym is supplied and not=0, the code will run faster but will produce incorrect results if 1D quadrature rule is asymmetric.</li>
</ul>
</dd>
<dt>Description:</dt>
<dd><p class="first">Several 1D integration rules are available to be chosen for the <tt class="docutils literal"><span class="pre">qrule</span></tt> input parameter</p>
<ul class="last simple">
<li>KPU = Nested rule for unweighted integral over [0,1]</li>
<li>KPN = Nested rule for integral with Gaussian weight</li>
<li>GQU = Gaussian quadrature for unweighted integral over [0,1] (Gauss-Legendre)</li>
<li>GQN = Gaussian quadrature for integral with Gaussian weight (Gauss-Hermite)</li>
<li>CC  = Clenshaw-Curtis quadrature for unweighted integral over [-1,1]</li>
<li>FEJ = Fejer&#8217;s quadrature for unweighted integral over [-1,1]</li>
<li>func =  any function provided by the user that accept level l and returns nodes n and weights w for univariate quadrature rule with polynomial exactness 2l-1 as [n w] = feval(func,level)</li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="SpectralToolbox.SparseGrids.SparseGrid.sparseGrid">
<tt class="descname">sparseGrid</tt><big>(</big><big>)</big><a class="headerlink" href="#SpectralToolbox.SparseGrids.SparseGrid.sparseGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>sparseGrid(): main function for generating nodes &amp; weights for sparse grids intergration</p>
<dl class="docutils">
<dt>Syntax: </dt>
<dd>(n,w) = sparseGrid()</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li>n    = matrix of nodes with dim columns</li>
<li>w    = row vector of corresponding weights</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.SparseGrids.GQU">
<tt class="descclassname">SpectralToolbox.SparseGrids.</tt><tt class="descname">GQU</tt><big>(</big><em>): function for generating 1D Gaussian quadrature rules for unweighted integral over [0</em>, <em>1] (Gauss-Legendre</em><big>)</big><a class="headerlink" href="#SpectralToolbox.SparseGrids.GQU" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Syntax:</dt>
<dd>(n,w) = GQU(l)</dd>
<dt>Input:</dt>
<dd>l = level of accuracy of the quadrature rule</dd>
<dt>Output:</dt>
<dd>n = nodes
w = weights</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.SparseGrids.GQN">
<tt class="descclassname">SpectralToolbox.SparseGrids.</tt><tt class="descname">GQN</tt><big>(</big><em>): function for generating 1D Gaussian quadrature for integral with Gaussian weight (Gauss-Hermite</em><big>)</big><a class="headerlink" href="#SpectralToolbox.SparseGrids.GQN" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Syntax:</dt>
<dd>(n,w) = GQU(l)</dd>
<dt>Input:</dt>
<dd>l = level of accuracy of the quadrature rule</dd>
<dt>Output:</dt>
<dd>n = nodes
w = weights</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.SparseGrids.KPU">
<tt class="descclassname">SpectralToolbox.SparseGrids.</tt><tt class="descname">KPU</tt><big>(</big><em>l</em><big>)</big><a class="headerlink" href="#SpectralToolbox.SparseGrids.KPU" title="Permalink to this definition">¶</a></dt>
<dd><p>KPU(): function for generating 1D Nested rule for unweighted integral over [0,1]
Syntax:</p>
<blockquote>
<div>(n,w) = GQU(l)</div></blockquote>
<dl class="docutils">
<dt>Input:</dt>
<dd>l = level of accuracy of the quadrature rule</dd>
<dt>Output:</dt>
<dd>n = nodes
w = weights</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.SparseGrids.KPN">
<tt class="descclassname">SpectralToolbox.SparseGrids.</tt><tt class="descname">KPN</tt><big>(</big><em>l</em><big>)</big><a class="headerlink" href="#SpectralToolbox.SparseGrids.KPN" title="Permalink to this definition">¶</a></dt>
<dd><p>KPN(): function for generating 1D Nested rule for integral with Gaussian weight
Syntax:</p>
<blockquote>
<div>(n,w) = GQU(l)</div></blockquote>
<dl class="docutils">
<dt>Input:</dt>
<dd>l = level of accuracy of the quadrature rule</dd>
<dt>Output:</dt>
<dd>n = nodes
w = weights</dd>
</dl>
</dd></dl>

</div>
<span class="target" id="module-SpectralToolbox.Misc"></span><div class="section" id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h2>
<p>Created on Wed Feb 27</p>
<p>&#64;author: Daniele Bigoni (<a class="reference external" href="mailto:dabi&#37;&#52;&#48;dtu&#46;dk">dabi<span>&#64;</span>dtu<span>&#46;</span>dk</a>)</p>
<p>Collection of miscellaneous functions used in the SpectralToolbox</p>
<dl class="class">
<dt id="SpectralToolbox.Misc.ExpandingArray">
<em class="property">class </em><tt class="descclassname">SpectralToolbox.Misc.</tt><tt class="descname">ExpandingArray</tt><big>(</big><em>initData</em>, <em>allocInitDim=None</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>maxIncrement=None</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.ExpandingArray" title="Permalink to this definition">¶</a></dt>
<dd><p>ExpandingArray is used for the dynamic allocation of memory in applications where the total allocated memory needed cannot be predicted. Memory is preallocated with increases of 50% all the time data exceed the allocated memory.</p>
<p>Initialization of the Expanding Array.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span> <span class="o">=</span> <span class="n">ExpandingArray</span><span class="p">(</span><span class="n">initData</span><span class="p">,[</span><span class="n">allocInitDim</span><span class="o">=</span><span class="bp">None</span><span class="p">,[</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,[</span><span class="n">maxIncrement</span><span class="o">=</span><span class="bp">None</span><span class="p">]]])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>initData</strong> (<em>ndarray</em>) &#8211; InitialData with which to be initially filled. This must provide the number of dimensions of the array</li>
<li><strong>allocInitDim</strong> (<em>1darray-integer</em>) &#8211; Initial allocated dimension (optional)</li>
<li><strong>dtype</strong> (<em>dtype</em>) &#8211; type for the data that will be contained in <tt class="docutils literal"><span class="pre">EA</span></tt> (optional,default=np.float64)</li>
<li><strong>maxIncrement</strong> (<em>integer</em>) &#8211; upper limit for the allocation increment</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="SpectralToolbox.Misc.ExpandingArray.concatenate">
<tt class="descname">concatenate</tt><big>(</big><em>X</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.ExpandingArray.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate data to the existing array. If needed the array is resized in the <tt class="docutils literal"><span class="pre">axis</span></tt> direction by a factor of 50%.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>X</strong> (<em>ndarray</em>) &#8211; data to be concatenated to the array. Note that <tt class="docutils literal"><span class="pre">X.shape[i]==EA.shape()[i]</span></tt> is required for all i!=axis</li>
<li><strong>axis</strong> (<em>integer</em>) &#8211; axis along which to concatenate the additional data (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">ExpandingArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>
<span class="go">(25, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(25, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>
<span class="go">(38, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Misc.ExpandingArray.getAllocArray">
<tt class="descname">getAllocArray</tt><big>(</big><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.ExpandingArray.getAllocArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the allocated array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">allocated array</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">ExpandingArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>
<span class="go">(25, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(25, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>
<span class="go">(38, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(45, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Misc.ExpandingArray.getDataArray">
<tt class="descname">getDataArray</tt><big>(</big><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.ExpandingArray.getDataArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the view of the array with data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">allocated array</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>
<span class="go">(38, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(45, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">getDataArray</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(38, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Misc.ExpandingArray.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.ExpandingArray.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the shape of the data inside the array. Note that the allocated memory is always bigger or equal to <tt class="docutils literal"><span class="pre">shape()</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">shape of the data</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">tuple of integer</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">ExpandingArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>
<span class="go">(25, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(25, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>
<span class="go">(38, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(45, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.Misc.ExpandingArray.trim">
<tt class="descname">trim</tt><big>(</big><em>N</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.ExpandingArray.trim" title="Permalink to this definition">¶</a></dt>
<dd><p>Trim the axis dimension of N elements. The allocated data is not reinitialized or deallocated. Only the dimensions of the view are redefined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>N</strong> (<em>integer</em>) &#8211; number of elements to be removed along the <tt class="docutils literal"><span class="pre">axis</span></tt> dimension</li>
<li><strong>axis</strong> (<em>integer</em>) &#8211; axis along which to remove elements (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">ExpandingArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">getDataArray</span><span class="p">()</span>
<span class="go">array([[ 0.42129746,  0.76220921],</span>
<span class="go">       [ 0.9238783 ,  0.11256142],</span>
<span class="go">       [ 0.42031437,  0.87349243],</span>
<span class="go">       [ 0.83187297,  0.555708  ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">getDataArray</span><span class="p">()</span>
<span class="go">array([[ 0.42129746,  0.76220921],</span>
<span class="go">       [ 0.9238783 ,  0.11256142]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EA</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()</span>
<span class="go">array([[ 0.42129746,  0.76220921],</span>
<span class="go">       [ 0.9238783 ,  0.11256142],</span>
<span class="go">       [ 0.42031437,  0.87349243],</span>
<span class="go">       [ 0.83187297,  0.555708  ]])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.Misc.MultiIndex">
<tt class="descclassname">SpectralToolbox.Misc.</tt><tt class="descname">MultiIndex</tt><big>(</big><em>d</em>, <em>N</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.MultiIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the multi index ordering for the construction of multidimensional Generalized Vandermonde matrices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d</strong> (<em>integer</em>) &#8211; dimension of the simplex</li>
<li><strong>N</strong> (<em>integer</em>) &#8211; maximum value of the sum of the indices</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">array containing the ordered multi-indices</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2d-array of integer</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Misc</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([[0, 0],</span>
<span class="go">       [1, 0],</span>
<span class="go">       [0, 1],</span>
<span class="go">       [2, 0],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [0, 2],</span>
<span class="go">       [3, 0],</span>
<span class="go">       [2, 1],</span>
<span class="go">       [1, 2],</span>
<span class="go">       [0, 3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.Misc.almostEqual">
<tt class="descclassname">SpectralToolbox.Misc.</tt><tt class="descname">almostEqual</tt><big>(</big><em>x</em>, <em>y</em>, <em>tol</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.almostEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Check equality of two arrays objects up to a certain tolerance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x,y</strong> (<em>numpy.ndarray objects of floats</em>) &#8211; values to be compared</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; tolerance to be used</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><tt class="docutils literal"><span class="pre">true</span></tt> if equal, <tt class="docutils literal"><span class="pre">false</span></tt> otherwise</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">bool</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eps2</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">Misc</span><span class="o">.</span><span class="n">machineEpsilon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Misc</span><span class="o">.</span><span class="n">almostEqual</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">eps2</span><span class="p">]),</span><span class="n">eps2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Misc</span><span class="o">.</span><span class="n">almostEqual</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">eps2</span><span class="p">]),</span><span class="n">eps2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.Misc.almostEqualList">
<tt class="descclassname">SpectralToolbox.Misc.</tt><tt class="descname">almostEqualList</tt><big>(</big><em>xArray</em>, <em>y</em>, <em>tol</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.almostEqualList" title="Permalink to this definition">¶</a></dt>
<dd><p>Check equality of a list of floats against an iterable value up to certain tolerance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xArray</strong> (<em>2d-array of floats</em>) &#8211; values to be compared to <tt class="docutils literal"><span class="pre">y</span></tt></li>
<li><strong>y</strong> (<em>iterable objects of floats</em>) &#8211; values to be compared to</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; tolerance to be used</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">array of booleans containing true where equal, false elsewhere.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">1d-array of bool</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">almostEqualList(xArray,y,tol)</span></tt></dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eps2</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">Misc</span><span class="o">.</span><span class="n">machineEpsilon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Misc</span><span class="o">.</span><span class="n">almostEqualList</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span><span class="n">eps2</span><span class="p">)</span>
<span class="go">array([False,  True, False, False], dtype=bool)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.Misc.argsort_insertion">
<tt class="descclassname">SpectralToolbox.Misc.</tt><tt class="descname">argsort_insertion</tt><big>(</big><em>X</em>, <em>tol</em>, <em>start_idx=1</em>, <em>end_idx=None</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.argsort_insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the insertion sort with <tt class="docutils literal"><span class="pre">binary_search</span></tt>. Returns permutation indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> (<em>2d-array of floats</em>) &#8211; values ordered by row according to the <tt class="docutils literal"><span class="pre">compare</span></tt> function</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; tolerance to be used</li>
<li><strong>start_idx,end_idx</strong> (<em>int</em>) &#8211; starting and ending indices for the ordering (optional)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">permutation indices</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">1d-array of integers</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">array([[ 0.56865133,  0.18490129],</span>
<span class="go">       [ 0.01411459,  0.46076606],</span>
<span class="go">       [ 0.64384365,  0.24998971],</span>
<span class="go">       [ 0.47840414,  0.32554137],</span>
<span class="go">       [ 0.12961966,  0.43712056]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perm</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">argsort_insertion</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">eps2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[</span><span class="n">perm</span><span class="p">,:]</span>
<span class="go">array([[ 0.01411459,  0.46076606],</span>
<span class="go">       [ 0.12961966,  0.43712056],</span>
<span class="go">       [ 0.47840414,  0.32554137],</span>
<span class="go">       [ 0.56865133,  0.18490129],</span>
<span class="go">       [ 0.64384365,  0.24998971]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.Misc.binary_search">
<tt class="descclassname">SpectralToolbox.Misc.</tt><tt class="descname">binary_search</tt><big>(</big><em>X</em>, <em>val</em>, <em>lo</em>, <em>hi</em>, <em>tol</em>, <em>perm=None</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.binary_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for the minimum X bigger than val</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> (<em>2d-array of floats</em>) &#8211; values ordered by row according to the <tt class="docutils literal"><span class="pre">compare</span></tt> function</li>
<li><strong>val</strong> (<em>1d-array of floats</em>) &#8211; value to be compared to</li>
<li><strong>lo,hi</strong> (<em>integer</em>) &#8211; staring and ending indices</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; tolerance to be used</li>
<li><strong>perm</strong> (<em>1d-array of integers</em>) &#8211; possible permutation to be used prior to the search (optional)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">index pointing to the maximum X smaller than val. If <tt class="docutils literal"><span class="pre">perm</span></tt> is provided, <tt class="docutils literal"><span class="pre">perm[idx]</span></tt> points to the maximum X smaller than val</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">integer</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">array([[1],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Misc</span><span class="o">.</span><span class="n">binary_search</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.5</span><span class="p">]),</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">eps2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">binary_search</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.5</span><span class="p">]),</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">eps2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">,:]</span>
<span class="go">array([3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.Misc.compare">
<tt class="descclassname">SpectralToolbox.Misc.</tt><tt class="descname">compare</tt><big>(</big><em>x</em>, <em>y</em>, <em>tol</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two iterable objects up to a certain tolerance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x,y</strong> (<em>iterable objects of floats</em>) &#8211; values to be compared</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; tolerance to be used</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">-1 if <tt class="docutils literal"><span class="pre">(x-y)</span> <span class="pre">&lt;</span> <span class="pre">tol</span></tt>, 1 if <tt class="docutils literal"><span class="pre">(x-y)</span> <span class="pre">&gt;</span> <span class="pre">tol</span></tt>, 0 otherwise</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">integer</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eps2</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">Misc</span><span class="o">.</span><span class="n">machineEpsilon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Misc</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">eps2</span><span class="p">]),</span><span class="n">eps2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Misc</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">eps2</span><span class="p">]),</span><span class="n">eps2</span><span class="p">)</span>
<span class="go">-1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.Misc.findOverlapping">
<tt class="descclassname">SpectralToolbox.Misc.</tt><tt class="descname">findOverlapping</tt><big>(</big><em>XF</em>, <em>X</em>, <em>tol</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.findOverlapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds overlapping points of <tt class="docutils literal"><span class="pre">XF</span></tt> on <tt class="docutils literal"><span class="pre">X</span></tt> grids of points. The two grids are ordered with respect to <tt class="xref py py-func docutils literal"><span class="pre">Misc.compare()</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>XF,X</strong> (<em>2d-array of floats</em>) &#8211; values ordered by row according to the <tt class="xref py py-func docutils literal"><span class="pre">Misc.compare()</span></tt>.</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; tolerance to be used</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">true values for overlapping points of <tt class="docutils literal"><span class="pre">XF</span></tt> on <tt class="docutils literal"><span class="pre">X</span></tt>, false for not overlapping points. Note: the overlapping return argument is a true-false indexing for <tt class="docutils literal"><span class="pre">XF</span></tt>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">1d-array of bool</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Example</strong></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">XF</span>
<span class="go">array([[ -1.73205081e+00,   0.00000000e+00],</span>
<span class="go">       [ -1.00000000e+00,  -1.00000000e+00],</span>
<span class="go">       [ -1.00000000e+00,   0.00000000e+00],</span>
<span class="go">       [ -1.00000000e+00,   1.00000000e+00],</span>
<span class="go">       [  0.00000000e+00,  -1.73205081e+00],</span>
<span class="go">       [  0.00000000e+00,  -1.00000000e+00],</span>
<span class="go">       [  0.00000000e+00,   2.16406754e-16],</span>
<span class="go">       [  0.00000000e+00,   1.00000000e+00],</span>
<span class="go">       [  0.00000000e+00,   1.73205081e+00],</span>
<span class="go">       [  1.00000000e+00,  -1.00000000e+00],</span>
<span class="go">       [  1.00000000e+00,   0.00000000e+00],</span>
<span class="go">       [  1.00000000e+00,   1.00000000e+00],</span>
<span class="go">       [  1.73205081e+00,   0.00000000e+00]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">array([[ -1.73205081e+00,   0.00000000e+00],</span>
<span class="go">       [ -1.00000000e+00,  -1.00000000e+00],</span>
<span class="go">       [ -1.00000000e+00,   0.00000000e+00],</span>
<span class="go">       [ -1.00000000e+00,   1.00000000e+00],</span>
<span class="go">       [  0.00000000e+00,  -1.00000000e+00],</span>
<span class="go">       [  2.16406754e-16,   0.00000000e+00],</span>
<span class="go">       [  0.00000000e+00,   1.00000000e+00],</span>
<span class="go">       [  1.00000000e+00,  -1.00000000e+00],</span>
<span class="go">       [  1.00000000e+00,   0.00000000e+00],</span>
<span class="go">       [  1.00000000e+00,   1.00000000e+00],</span>
<span class="go">       [  1.73205081e+00,   0.00000000e+00]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tol</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">Misc</span><span class="o">.</span><span class="n">machineEpsilon</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_idx_over</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">findOverlapping</span><span class="p">(</span><span class="n">XF</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">tol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">XF</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">bool_idx_over</span><span class="p">),:]</span>
<span class="go">array([[ 0.        , -1.73205081],</span>
<span class="go">       [ 0.        ,  1.73205081]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.Misc.machineEpsilon">
<tt class="descclassname">SpectralToolbox.Misc.</tt><tt class="descname">machineEpsilon</tt><big>(</big><em>func=&lt;type 'float'&gt;</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.machineEpsilon" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the abolute machine precision for the type passed as argument</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>func</strong> (<em>dtype</em>) &#8211; type</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">absolute machine precision</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Misc</span><span class="o">.</span><span class="n">machineEpsilon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">2.2204460492503131e-16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Misc</span><span class="o">.</span><span class="n">machineEpsilon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float128</span><span class="p">)</span>
<span class="go">1.084202172485504434e-19</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.Misc.powerset">
<tt class="descclassname">SpectralToolbox.Misc.</tt><tt class="descname">powerset</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.powerset" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the power set of an iterable object.</p>
</dd></dl>

<dl class="function">
<dt id="SpectralToolbox.Misc.unique_cuts">
<tt class="descclassname">SpectralToolbox.Misc.</tt><tt class="descname">unique_cuts</tt><big>(</big><em>X</em>, <em>tol</em>, <em>retIdxs=False</em><big>)</big><a class="headerlink" href="#SpectralToolbox.Misc.unique_cuts" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unique values and a list of arrays of boolean indicating the positions of the unique values.
If retIdx is true, then it returns the group of indices with the same values as a indicator function (true-false array)</p>
</dd></dl>

</div>
<hr class="docutils" />
<p>Created on Wed Feb 27</p>
<p>&#64;author: Daniele Bigoni (<a class="reference external" href="mailto:dabi&#37;&#52;&#48;dtu&#46;dk">dabi<span>&#64;</span>dtu<span>&#46;</span>dk</a>)</p>
<div class="section" id="id22">
<h2>Description<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>This module is used to construct Heterogeneous Sparse Grids. These are integration rules based on Smolyak&#8217;s Sparse Grids <a class="footnote-reference" href="#id25" id="id23">[6]</a> built up in order to provide flexibility for both:</dt>
<dd><ol class="first last arabic simple">
<li>the types of polynomials to be used per direction</li>
<li>the accuracy to be used per direction</li>
</ol>
</dd>
</dl>
<p>The types of polynomials available are all the ones included in the module <tt class="xref py py-mod docutils literal"><span class="pre">Spectral1D</span></tt>. The rules don&#8217;t need to be symmetric and the accuracy per each direction can vary.</p>
<p>For rules with Heterogeneous accuracy, two sparse grids will be construced: one partial sparse grid and one full sparse grid (up to the maximum accuracy). The values computed for the partial sparse grid can then be used to interpolate on the points of the full sparse grid. This latter rule can then be used to compute the integral.</p>
</div>
<div class="section" id="id24">
<h2>References<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h2>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[6]</a></td><td><ol class="first last upperalpha simple" start="19">
<li><ol class="first upperalpha">
<li>Smolyak, &#8220;Quadrature and interpolation formulas for tensor products of certain classes of functions&#8221;. Soviet Math. Dokl., 4:240–243, 1963</li>
</ol>
</li>
</ol>
</td></tr>
</tbody>
</table>
</div>
<div class="section" id="id26">
<h2>Examples<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s consider the following space <span class="math">\(\Omega = [-\infty,\infty]     imes[0,1]\)</span> with the associated measures <span class="math">\(\mu_1(x)=\frac{1}{\sqrt{2\pi}} e^{-\frac{x^2}{2}}\)</span> and  <span class="math">\(\mu_2(x)=1\)</span> for each dimension. The product measure is given by <span class="math">\(\mu(\bar{x})=\prod_{i=1}^n \mu_i(x_i)\)</span>. We will consider the function</p>
<div class="math">
\[f(\bar{x}) = x_1^{p_1} \cdot x_2^{p_2}\]</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f_mult</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">xp</span><span class="p">,</span><span class="n">yp</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="n">xp</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">yp</span>
</pre></div>
</div>
<p>with exact value of the integral given by</p>
<div class="math">
\[\int_\Omega f(\bar{x}) \mu(\bar{x}) = \frac{2^{-1+p_2} \left( 1+(-1)^{p_2} \right) \Gamma\left( \frac{1+p_2}{2} \right)}{(1+p_1)\sqrt{\pi}}\]</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">I_mult</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="mf">2.</span><span class="o">**</span><span class="p">(</span><span class="o">-.</span><span class="mi">5</span><span class="o">+.</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">**</span><span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
</pre></div>
</div>
<p>Let <span class="math">\(p_1=2\)</span> and <span class="math">\(p_2=4\)</span>. We can obtain a sparse grid composed using Hermite basis (<tt class="xref py py-const docutils literal"><span class="pre">Spectral1D.HERMITEP_PROB</span></tt>) and Legendre basis (<tt class="xref py py-const docutils literal"><span class="pre">Spectral1D.JACOBI</span></tt>) with orders 2 and 4 respectively.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">SpectralToolbox</span> <span class="kn">import</span> <span class="n">HeterogeneousSparseGrids</span> <span class="k">as</span> <span class="n">HSG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pH</span> <span class="o">=</span> <span class="n">Spectral1D</span><span class="o">.</span><span class="n">Poly1D</span><span class="p">(</span><span class="n">Spectral1D</span><span class="o">.</span><span class="n">HERMITEP_PROB</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pL</span> <span class="o">=</span> <span class="n">Spectral1D</span><span class="o">.</span><span class="n">Poly1D</span><span class="p">(</span><span class="n">Spectral1D</span><span class="o">.</span><span class="n">JACOBI</span><span class="p">,[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">pH</span><span class="p">,</span><span class="n">pL</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Ns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sg</span> <span class="o">=</span> <span class="n">HSG</span><span class="o">.</span><span class="n">HSparseGrid</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span><span class="n">Ns</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">XF</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sparseGrid</span><span class="p">()</span>
<span class="go">[SG] Sparse Grid Generation [============================================] 100%</span>
<span class="go">[SG] Sparse Grid Generation: 0.01s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">XF</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">XF</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">XF</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">XF</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s">&#39;o&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s">&#39;or&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting partial and full sparse grids are shown in the following figure.</p>
<div class="figure" id="gridexample">
<img alt="_static/Figures/HeterSparseGrids-GridExample.png" src="_static/Figures/HeterSparseGrids-GridExample.png" />
<p class="caption">Partial (red) and full (blue) sparse grid. The full sparse grid is overlapping over the partial sparse grid.</p>
</div>
<p>The values on the partial grid can be computed and then the interpolation is taken over the full sparse grid.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fX</span> <span class="o">=</span> <span class="n">f_mult</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">Q</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fXF</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sparseGridInterp</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">fX</span><span class="p">,</span><span class="n">XF</span><span class="p">)</span>
<span class="go">[SG] Sparse Grid Interpolation [=========================================] 100%</span>
<span class="go">[SG] Sparse Grid Interpolation: 0.00s</span>
</pre></div>
</div>
<p>Finally the error of the quadrature rule is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IErr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">fXF</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="o">-</span><span class="n">I_mult</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">P</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IErr</span>
<span class="go">3.33066907388e-16</span>
</pre></div>
</div>
<dl class="class">
<dt id="SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid">
<em class="property">class </em><tt class="descclassname">SpectralToolbox.HeterogeneousSparseGrids.</tt><tt class="descname">HSparseGrid</tt><big>(</big><em>polys</em>, <em>Ns</em>, <em>tol=None</em>, <em>sdout=&lt;open file '&lt;stderr&gt;'</em>, <em>mode 'w' at 0x2b81fc700270&gt;</em><big>)</big><a class="headerlink" href="#SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Heterogeneous Sparse Grid class</p>
<p>Constructor of Heterogeneous Sparse Grid object (this does not allocate the sparse grid)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>polys</strong> (list of <tt class="xref py py-class docutils literal"><span class="pre">Spectral1D.Poly1D</span></tt>) &#8211; orthogonal polynomials to be used as basis functions</li>
<li><strong>Ns</strong> (<em>list of integers</em>) &#8211; accuracy for each dimension. It can be a list of accuracies or a single accuracy, in which case uniform accuracy is assumed</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; tolerance to be used when comparing points of the grid (optional, default=:py:func:<cite>Misc.machineEpsilon()</cite>)</li>
<li><strong>sdout</strong> (<em>stream</em>) &#8211; default output stream for the class (optional,default=``sys.stderr``)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">one of the following must hold: len(polys)==len(Ns) or len(Ns)==1, in which case the same order is used for all the directions.</p>
</div>
<p><strong>Example</strong></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">SpectralToolbox</span> <span class="kn">import</span> <span class="n">HeterogeneousSparseGrids</span> <span class="k">as</span> <span class="n">HSG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pH</span> <span class="o">=</span> <span class="n">Spectral1D</span><span class="o">.</span><span class="n">Poly1D</span><span class="p">(</span><span class="n">Spectral1D</span><span class="o">.</span><span class="n">HERMITEP_PROB</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pL</span> <span class="o">=</span> <span class="n">Spectral1D</span><span class="o">.</span><span class="n">Poly1D</span><span class="p">(</span><span class="n">Spectral1D</span><span class="o">.</span><span class="n">JACOBI</span><span class="p">,[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">pH</span><span class="p">,</span><span class="n">pL</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Ns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sg</span> <span class="o">=</span> <span class="n">HSG</span><span class="o">.</span><span class="n">HSparseGrid</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span><span class="n">Ns</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid.sparseGrid">
<tt class="descname">sparseGrid</tt><big>(</big><em>heter=False</em><big>)</big><a class="headerlink" href="#SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid.sparseGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the full and partial sparse grids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>heter</strong> (<em>bool</em>) &#8211; if <tt class="xref py py-data docutils literal"><span class="pre">Ns</span></tt> is homogeneous, this parameter will force the output of the partial sparse grid as well</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">tuple <tt class="xref py py-data docutils literal"><span class="pre">(XF,WF,X)</span></tt> containing:<ul class="simple">
<li><tt class="xref py py-data docutils literal"><span class="pre">XF</span></tt>: full grid points</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">WF</span></tt>: full grid weights</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">X</span></tt>: partial grid points</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Example</strong></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">XF</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sparseGrid</span><span class="p">()</span>
<span class="go">[SG] Sparse Grid Generation [============================================] 100%</span>
<span class="go">[SG] Sparse Grid Generation: 0.01s</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid.sparseGridInterp">
<tt class="descname">sparseGridInterp</tt><big>(</big><em>X</em>, <em>fX</em>, <em>XF</em><big>)</big><a class="headerlink" href="#SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid.sparseGridInterp" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate values of the Sparse Grid using 1D Polynomial interpolation along cuts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> (<em>2d-array of floats</em>) &#8211; partial grid on which a function has been evaluated</li>
<li><strong>fX</strong> (<em>1d-array of floats</em>) &#8211; values for the points in the partial grid</li>
<li><strong>XF</strong> (<em>2d-array of floats</em>) &#8211; full grid on which to interpolate</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><tt class="xref py py-data docutils literal"><span class="pre">fXF</span></tt> the interpolated values on the full grid</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">1d-array of floats</p>
</td>
</tr>
</tbody>
</table>
<p>..note:: The partial and full grid must be overlapping</p>
<p><strong>Example</strong></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fXF</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sparseGridInterp</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">fX</span><span class="p">,</span><span class="n">XF</span><span class="p">)</span>
<span class="go">[SG] Sparse Grid Interpolation [=========================================] 100%</span>
<span class="go">[SG] Sparse Grid Interpolation: 0.00s</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to SpectralToolbox&#8217;s documentation!</a><ul>
<li><a class="reference internal" href="#description">Description</a><ul>
<li><a class="reference internal" href="#jacobi-polynomials">Jacobi Polynomials</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#spectral-nd">Spectral ND</a></li>
<li><a class="reference internal" href="#sparse-grids">Sparse Grids</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
<li><a class="reference internal" href="#id22">Description</a></li>
<li><a class="reference internal" href="#id24">References</a></li>
<li><a class="reference internal" href="#id26">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">SpectralToolbox 0.1a documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Daniele Bigoni.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>