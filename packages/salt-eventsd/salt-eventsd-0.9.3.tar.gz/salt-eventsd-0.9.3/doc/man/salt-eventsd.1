.TH "SALT-EVENTSD" "1" "March 9th, 2015" "0.9.2" "salt-eventsd"
.SH NAME
salt-eventsd \- salt-eventsd
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.\" Man page generated from reStructeredText.
.
.sp
A python-daemon that collects events from the salt-event bus
.SH SYNOPSIS
.sp
.nf
.ft C
salt\-eventsd salt-eventsd [-h] [-c CONFIGFILE] [-l LOGLEVEL] [--logfile LOGFILE] [-d [DAEMONIZE]] [-v [VERSION]]
.ft P
.fi
.SH DESCRIPTION
.sp
The salt-eventsd collects events from the salt-masters event-bus and writes them into a database or any other configurable backend. The events to act on and the backend to send the data to are configurable per event. Events are recognized by their 'tag' and/or 'fun' field. Since many events can have different types of data-structures and we do not always want all the data, the source-datafield (usually a dictionary) and the fields to use from it can be configured. 
.SH OPTIONS
.INDENT 0.0

.TP
.BR -h 
Print short summary of options

.TP
.BR -c
Specify an alternate configuration file (default: /etc/salt/eventsd)

.TP
.BR -l
The Loglevel to use. One of: WARN,INFO,DEBUG,CRITICAL

.TP
.BR -L
The logfile to log into.

.TP
.BR -d
Daemonize when run on the command line.

.TP
.BR -v
Print current version and exit.
.UNINDENT

.SH
WHAT HAPPENS WHEN AND WHERE
THe salt-eventsd listens on the event-bus of the salt-master. It receives every(!) event that is published. The daemon looks at each events 'tag' and depending on its config decides, if it has to act or not. The matching is done using precompiled regular expressions, so its also valid to have regex-expressions in the 'tag'-fields of an event. This is for example done for the job-returns where the event is matched on the tag 'salt/job/[0-9]*/ret/\w+'. Not matching events are simply ignored. 

Whenever a event matches, it is saved into a event-queue (python list). This happens transparently, the events are not "consumed" and still get to the master like all other vents. When the event-queue reaches its maximum amount of events (event_limit), a worker thread is started that takes care of pushing all the events into their respective backends.

For environments where not so many events occur, the event_timer might be the useful. The timer starts with the configured interval when the daemon starts. It fires an event every 'event_timer' seconds if and only if, the event_limit has not been reached during the last 'event_timer' seconds. Whenever the timer-event occurs, the currently queued events in the event-queue manually pushed into the repspective backends. This is to prevent events from sitting too long in the event-queue without handled somehow.

.SH SEE ALSO
.sp
\fIsalt-eventsd(5)\fP
\fIsalt(7)\fP
\fIsalt\-master(1)\fP
.SH AUTHOR
Volker Schwicking <vs@hosteurope.de> based on work from Thomas Hatch <thatch45@gmail.com> and many others, please see the Authors file
.SH COPYRIGHT
2013, Volker Schwicking
.\" Generated by docutils manpage writer.
.\" 
.
