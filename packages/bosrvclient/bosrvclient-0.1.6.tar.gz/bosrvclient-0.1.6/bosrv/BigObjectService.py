#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def star_apply(self, token, srvname, cmd_stmt, workspace, opts):
    """
    Parameters:
     - token
     - srvname
     - cmd_stmt
     - workspace
     - opts
    """
    pass

  def sql_execute(self, token, sql_stmt, workspace, opts):
    """
    @brief   Method to take a constructed sql statement and run
    @return  Created resource when applicable

    Parameters:
     - token
     - sql_stmt
     - workspace
     - opts
    """
    pass

  def assoc_execute(self, token, stmt, workspace, opts):
    """
    Parameters:
     - token
     - stmt
     - workspace
     - opts
    """
    pass

  def cursor_fetch(self, token, resource, rng):
    """
    @brief   Method to fetch data defined in the range of RangeSpec
    @return  JSON object of rows of tuples defined by the target resource
             [
                 [...],
                 [...],
                 ...
                 -1 // Indicator for EOL in the table
             ]

    Parameters:
     - token
     - resource
     - rng
    """
    pass

  def cursor_close(self, token, resource):
    """
    @brief   Method to close the resource under this cursor.

             Call to this method may not necessarily result in resource
             recycled.

    Parameters:
     - token
     - resource
    """
    pass

  def get_table_list(self, token, workspace):
    """
    @brief   Method to retreive list of created resources at location

    Parameters:
     - token
     - workspace
    """
    pass

  def get_table_schema(self, token, table_name, workspace):
    """
    @brief   Method to retreive metadata regarding resource at location

    Parameters:
     - token
     - table_name
     - workspace
    """
    pass

  def get_table_relation(self, token, table_name, workspace):
    """
    @brief   Method to retreive relation of table to its dimensions (?)

    Parameters:
     - token
     - table_name
     - workspace
    """
    pass

  def get_table_create_stmt(self, token, resource, inmemory):
    """
    @brief   Method to retreive resource's original create statement

    Parameters:
     - token
     - resource
     - inmemory
    """
    pass

  def get_qbo_list(self, token, workspace):
    """
    @brief   Method to retreive list of created resources at location

    Parameters:
     - token
     - workspace
    """
    pass

  def get_qbo_info(self, token, table_name, workspace):
    """
    @brief   Method to retreive metadata regarding resource at location

    Parameters:
     - token
     - table_name
     - workspace
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def star_apply(self, token, srvname, cmd_stmt, workspace, opts):
    """
    Parameters:
     - token
     - srvname
     - cmd_stmt
     - workspace
     - opts
    """
    self.send_star_apply(token, srvname, cmd_stmt, workspace, opts)
    return self.recv_star_apply()

  def send_star_apply(self, token, srvname, cmd_stmt, workspace, opts):
    self._oprot.writeMessageBegin('star_apply', TMessageType.CALL, self._seqid)
    args = star_apply_args()
    args.token = token
    args.srvname = srvname
    args.cmd_stmt = cmd_stmt
    args.workspace = workspace
    args.opts = opts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_star_apply(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = star_apply_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "star_apply failed: unknown result");

  def sql_execute(self, token, sql_stmt, workspace, opts):
    """
    @brief   Method to take a constructed sql statement and run
    @return  Created resource when applicable

    Parameters:
     - token
     - sql_stmt
     - workspace
     - opts
    """
    self.send_sql_execute(token, sql_stmt, workspace, opts)
    return self.recv_sql_execute()

  def send_sql_execute(self, token, sql_stmt, workspace, opts):
    self._oprot.writeMessageBegin('sql_execute', TMessageType.CALL, self._seqid)
    args = sql_execute_args()
    args.token = token
    args.sql_stmt = sql_stmt
    args.workspace = workspace
    args.opts = opts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sql_execute(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sql_execute_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.sqlerr is not None:
      raise result.sqlerr
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sql_execute failed: unknown result");

  def assoc_execute(self, token, stmt, workspace, opts):
    """
    Parameters:
     - token
     - stmt
     - workspace
     - opts
    """
    self.send_assoc_execute(token, stmt, workspace, opts)
    return self.recv_assoc_execute()

  def send_assoc_execute(self, token, stmt, workspace, opts):
    self._oprot.writeMessageBegin('assoc_execute', TMessageType.CALL, self._seqid)
    args = assoc_execute_args()
    args.token = token
    args.stmt = stmt
    args.workspace = workspace
    args.opts = opts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_assoc_execute(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = assoc_execute_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "assoc_execute failed: unknown result");

  def cursor_fetch(self, token, resource, rng):
    """
    @brief   Method to fetch data defined in the range of RangeSpec
    @return  JSON object of rows of tuples defined by the target resource
             [
                 [...],
                 [...],
                 ...
                 -1 // Indicator for EOL in the table
             ]

    Parameters:
     - token
     - resource
     - rng
    """
    self.send_cursor_fetch(token, resource, rng)
    return self.recv_cursor_fetch()

  def send_cursor_fetch(self, token, resource, rng):
    self._oprot.writeMessageBegin('cursor_fetch', TMessageType.CALL, self._seqid)
    args = cursor_fetch_args()
    args.token = token
    args.resource = resource
    args.rng = rng
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cursor_fetch(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cursor_fetch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cursor_fetch failed: unknown result");

  def cursor_close(self, token, resource):
    """
    @brief   Method to close the resource under this cursor.

             Call to this method may not necessarily result in resource
             recycled.

    Parameters:
     - token
     - resource
    """
    self.send_cursor_close(token, resource)
    self.recv_cursor_close()

  def send_cursor_close(self, token, resource):
    self._oprot.writeMessageBegin('cursor_close', TMessageType.CALL, self._seqid)
    args = cursor_close_args()
    args.token = token
    args.resource = resource
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cursor_close(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cursor_close_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    return

  def get_table_list(self, token, workspace):
    """
    @brief   Method to retreive list of created resources at location

    Parameters:
     - token
     - workspace
    """
    self.send_get_table_list(token, workspace)
    return self.recv_get_table_list()

  def send_get_table_list(self, token, workspace):
    self._oprot.writeMessageBegin('get_table_list', TMessageType.CALL, self._seqid)
    args = get_table_list_args()
    args.token = token
    args.workspace = workspace
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_list(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_list_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_list failed: unknown result");

  def get_table_schema(self, token, table_name, workspace):
    """
    @brief   Method to retreive metadata regarding resource at location

    Parameters:
     - token
     - table_name
     - workspace
    """
    self.send_get_table_schema(token, table_name, workspace)
    return self.recv_get_table_schema()

  def send_get_table_schema(self, token, table_name, workspace):
    self._oprot.writeMessageBegin('get_table_schema', TMessageType.CALL, self._seqid)
    args = get_table_schema_args()
    args.token = token
    args.table_name = table_name
    args.workspace = workspace
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_schema(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_schema_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_schema failed: unknown result");

  def get_table_relation(self, token, table_name, workspace):
    """
    @brief   Method to retreive relation of table to its dimensions (?)

    Parameters:
     - token
     - table_name
     - workspace
    """
    self.send_get_table_relation(token, table_name, workspace)
    return self.recv_get_table_relation()

  def send_get_table_relation(self, token, table_name, workspace):
    self._oprot.writeMessageBegin('get_table_relation', TMessageType.CALL, self._seqid)
    args = get_table_relation_args()
    args.token = token
    args.table_name = table_name
    args.workspace = workspace
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_relation(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_relation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_relation failed: unknown result");

  def get_table_create_stmt(self, token, resource, inmemory):
    """
    @brief   Method to retreive resource's original create statement

    Parameters:
     - token
     - resource
     - inmemory
    """
    self.send_get_table_create_stmt(token, resource, inmemory)
    return self.recv_get_table_create_stmt()

  def send_get_table_create_stmt(self, token, resource, inmemory):
    self._oprot.writeMessageBegin('get_table_create_stmt', TMessageType.CALL, self._seqid)
    args = get_table_create_stmt_args()
    args.token = token
    args.resource = resource
    args.inmemory = inmemory
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_create_stmt(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_create_stmt_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_create_stmt failed: unknown result");

  def get_qbo_list(self, token, workspace):
    """
    @brief   Method to retreive list of created resources at location

    Parameters:
     - token
     - workspace
    """
    self.send_get_qbo_list(token, workspace)
    return self.recv_get_qbo_list()

  def send_get_qbo_list(self, token, workspace):
    self._oprot.writeMessageBegin('get_qbo_list', TMessageType.CALL, self._seqid)
    args = get_qbo_list_args()
    args.token = token
    args.workspace = workspace
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_qbo_list(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_qbo_list_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_qbo_list failed: unknown result");

  def get_qbo_info(self, token, table_name, workspace):
    """
    @brief   Method to retreive metadata regarding resource at location

    Parameters:
     - token
     - table_name
     - workspace
    """
    self.send_get_qbo_info(token, table_name, workspace)
    return self.recv_get_qbo_info()

  def send_get_qbo_info(self, token, table_name, workspace):
    self._oprot.writeMessageBegin('get_qbo_info', TMessageType.CALL, self._seqid)
    args = get_qbo_info_args()
    args.token = token
    args.table_name = table_name
    args.workspace = workspace
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_qbo_info(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_qbo_info_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_qbo_info failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["star_apply"] = Processor.process_star_apply
    self._processMap["sql_execute"] = Processor.process_sql_execute
    self._processMap["assoc_execute"] = Processor.process_assoc_execute
    self._processMap["cursor_fetch"] = Processor.process_cursor_fetch
    self._processMap["cursor_close"] = Processor.process_cursor_close
    self._processMap["get_table_list"] = Processor.process_get_table_list
    self._processMap["get_table_schema"] = Processor.process_get_table_schema
    self._processMap["get_table_relation"] = Processor.process_get_table_relation
    self._processMap["get_table_create_stmt"] = Processor.process_get_table_create_stmt
    self._processMap["get_qbo_list"] = Processor.process_get_qbo_list
    self._processMap["get_qbo_info"] = Processor.process_get_qbo_info

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_star_apply(self, seqid, iprot, oprot):
    args = star_apply_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = star_apply_result()
    try:
      result.success = self._handler.star_apply(args.token, args.srvname, args.cmd_stmt, args.workspace, args.opts)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("star_apply", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sql_execute(self, seqid, iprot, oprot):
    args = sql_execute_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sql_execute_result()
    try:
      result.success = self._handler.sql_execute(args.token, args.sql_stmt, args.workspace, args.opts)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.SQLError, sqlerr:
      result.sqlerr = sqlerr
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("sql_execute", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_assoc_execute(self, seqid, iprot, oprot):
    args = assoc_execute_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = assoc_execute_result()
    try:
      result.success = self._handler.assoc_execute(args.token, args.stmt, args.workspace, args.opts)
    except exc.ttypes.ASSOCError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("assoc_execute", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cursor_fetch(self, seqid, iprot, oprot):
    args = cursor_fetch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cursor_fetch_result()
    try:
      result.success = self._handler.cursor_fetch(args.token, args.resource, args.rng)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("cursor_fetch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cursor_close(self, seqid, iprot, oprot):
    args = cursor_close_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cursor_close_result()
    try:
      self._handler.cursor_close(args.token, args.resource)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("cursor_close", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_list(self, seqid, iprot, oprot):
    args = get_table_list_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_list_result()
    try:
      result.success = self._handler.get_table_list(args.token, args.workspace)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_table_list", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_schema(self, seqid, iprot, oprot):
    args = get_table_schema_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_schema_result()
    try:
      result.success = self._handler.get_table_schema(args.token, args.table_name, args.workspace)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_table_schema", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_relation(self, seqid, iprot, oprot):
    args = get_table_relation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_relation_result()
    try:
      result.success = self._handler.get_table_relation(args.token, args.table_name, args.workspace)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_table_relation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_create_stmt(self, seqid, iprot, oprot):
    args = get_table_create_stmt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_create_stmt_result()
    try:
      result.success = self._handler.get_table_create_stmt(args.token, args.resource, args.inmemory)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_table_create_stmt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_qbo_list(self, seqid, iprot, oprot):
    args = get_qbo_list_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_qbo_list_result()
    try:
      result.success = self._handler.get_qbo_list(args.token, args.workspace)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_qbo_list", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_qbo_info(self, seqid, iprot, oprot):
    args = get_qbo_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_qbo_info_result()
    try:
      result.success = self._handler.get_qbo_info(args.token, args.table_name, args.workspace)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_qbo_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class star_apply_args:
  """
  Attributes:
   - token
   - srvname
   - cmd_stmt
   - workspace
   - opts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'srvname', None, None, ), # 2
    (3, TType.STRING, 'cmd_stmt', None, None, ), # 3
    (4, TType.STRING, 'workspace', None, None, ), # 4
    (5, TType.STRING, 'opts', None, None, ), # 5
  )

  def __init__(self, token=None, srvname=None, cmd_stmt=None, workspace=None, opts=None,):
    self.token = token
    self.srvname = srvname
    self.cmd_stmt = cmd_stmt
    self.workspace = workspace
    self.opts = opts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.srvname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.cmd_stmt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.workspace = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.opts = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('star_apply_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.srvname is not None:
      oprot.writeFieldBegin('srvname', TType.STRING, 2)
      oprot.writeString(self.srvname)
      oprot.writeFieldEnd()
    if self.cmd_stmt is not None:
      oprot.writeFieldBegin('cmd_stmt', TType.STRING, 3)
      oprot.writeString(self.cmd_stmt)
      oprot.writeFieldEnd()
    if self.workspace is not None:
      oprot.writeFieldBegin('workspace', TType.STRING, 4)
      oprot.writeString(self.workspace)
      oprot.writeFieldEnd()
    if self.opts is not None:
      oprot.writeFieldBegin('opts', TType.STRING, 5)
      oprot.writeString(self.opts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class star_apply_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('star_apply_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sql_execute_args:
  """
  Attributes:
   - token
   - sql_stmt
   - workspace
   - opts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'sql_stmt', None, None, ), # 2
    (3, TType.STRING, 'workspace', None, None, ), # 3
    (4, TType.STRING, 'opts', None, None, ), # 4
  )

  def __init__(self, token=None, sql_stmt=None, workspace=None, opts=None,):
    self.token = token
    self.sql_stmt = sql_stmt
    self.workspace = workspace
    self.opts = opts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.sql_stmt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.workspace = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.opts = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sql_execute_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.sql_stmt is not None:
      oprot.writeFieldBegin('sql_stmt', TType.STRING, 2)
      oprot.writeString(self.sql_stmt)
      oprot.writeFieldEnd()
    if self.workspace is not None:
      oprot.writeFieldBegin('workspace', TType.STRING, 3)
      oprot.writeString(self.workspace)
      oprot.writeFieldEnd()
    if self.opts is not None:
      oprot.writeFieldBegin('opts', TType.STRING, 4)
      oprot.writeString(self.opts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sql_execute_result:
  """
  Attributes:
   - success
   - err
   - sqlerr
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'sqlerr', (exc.ttypes.SQLError, exc.ttypes.SQLError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, err=None, sqlerr=None, arr=None,):
    self.success = success
    self.err = err
    self.sqlerr = sqlerr
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sqlerr = exc.ttypes.SQLError()
          self.sqlerr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sql_execute_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.sqlerr is not None:
      oprot.writeFieldBegin('sqlerr', TType.STRUCT, 2)
      self.sqlerr.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 3)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class assoc_execute_args:
  """
  Attributes:
   - token
   - stmt
   - workspace
   - opts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'stmt', None, None, ), # 2
    (3, TType.STRING, 'workspace', None, None, ), # 3
    (4, TType.STRING, 'opts', None, None, ), # 4
  )

  def __init__(self, token=None, stmt=None, workspace=None, opts=None,):
    self.token = token
    self.stmt = stmt
    self.workspace = workspace
    self.opts = opts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stmt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.workspace = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.opts = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('assoc_execute_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.stmt is not None:
      oprot.writeFieldBegin('stmt', TType.STRING, 2)
      oprot.writeString(self.stmt)
      oprot.writeFieldEnd()
    if self.workspace is not None:
      oprot.writeFieldBegin('workspace', TType.STRING, 3)
      oprot.writeString(self.workspace)
      oprot.writeFieldEnd()
    if self.opts is not None:
      oprot.writeFieldBegin('opts', TType.STRING, 4)
      oprot.writeString(self.opts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class assoc_execute_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ASSOCError, exc.ttypes.ASSOCError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ASSOCError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('assoc_execute_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cursor_fetch_args:
  """
  Attributes:
   - token
   - resource
   - rng
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'resource', None, None, ), # 2
    (3, TType.STRUCT, 'rng', (RangeSpec, RangeSpec.thrift_spec), None, ), # 3
  )

  def __init__(self, token=None, resource=None, rng=None,):
    self.token = token
    self.resource = resource
    self.rng = rng

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.resource = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.rng = RangeSpec()
          self.rng.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cursor_fetch_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.resource is not None:
      oprot.writeFieldBegin('resource', TType.STRING, 2)
      oprot.writeString(self.resource)
      oprot.writeFieldEnd()
    if self.rng is not None:
      oprot.writeFieldBegin('rng', TType.STRUCT, 3)
      self.rng.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cursor_fetch_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cursor_fetch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cursor_close_args:
  """
  Attributes:
   - token
   - resource
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'resource', None, None, ), # 2
  )

  def __init__(self, token=None, resource=None,):
    self.token = token
    self.resource = resource

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.resource = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cursor_close_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.resource is not None:
      oprot.writeFieldBegin('resource', TType.STRING, 2)
      oprot.writeString(self.resource)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cursor_close_result:
  """
  Attributes:
   - err
   - arr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, err=None, arr=None,):
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cursor_close_result')
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_list_args:
  """
  Attributes:
   - token
   - workspace
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'workspace', None, None, ), # 2
  )

  def __init__(self, token=None, workspace=None,):
    self.token = token
    self.workspace = workspace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.workspace = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_list_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.workspace is not None:
      oprot.writeFieldBegin('workspace', TType.STRING, 2)
      oprot.writeString(self.workspace)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_list_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_list_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_schema_args:
  """
  Attributes:
   - token
   - table_name
   - workspace
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'workspace', None, None, ), # 3
  )

  def __init__(self, token=None, table_name=None, workspace=None,):
    self.token = token
    self.table_name = table_name
    self.workspace = workspace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.workspace = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_schema_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.workspace is not None:
      oprot.writeFieldBegin('workspace', TType.STRING, 3)
      oprot.writeString(self.workspace)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_schema_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_schema_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_relation_args:
  """
  Attributes:
   - token
   - table_name
   - workspace
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'workspace', None, None, ), # 3
  )

  def __init__(self, token=None, table_name=None, workspace=None,):
    self.token = token
    self.table_name = table_name
    self.workspace = workspace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.workspace = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_relation_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.workspace is not None:
      oprot.writeFieldBegin('workspace', TType.STRING, 3)
      oprot.writeString(self.workspace)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_relation_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_relation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_create_stmt_args:
  """
  Attributes:
   - token
   - resource
   - inmemory
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'resource', None, None, ), # 2
    (3, TType.BOOL, 'inmemory', None, None, ), # 3
  )

  def __init__(self, token=None, resource=None, inmemory=None,):
    self.token = token
    self.resource = resource
    self.inmemory = inmemory

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.resource = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.inmemory = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_create_stmt_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.resource is not None:
      oprot.writeFieldBegin('resource', TType.STRING, 2)
      oprot.writeString(self.resource)
      oprot.writeFieldEnd()
    if self.inmemory is not None:
      oprot.writeFieldBegin('inmemory', TType.BOOL, 3)
      oprot.writeBool(self.inmemory)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_create_stmt_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_create_stmt_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_qbo_list_args:
  """
  Attributes:
   - token
   - workspace
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'workspace', None, None, ), # 2
  )

  def __init__(self, token=None, workspace=None,):
    self.token = token
    self.workspace = workspace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.workspace = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_qbo_list_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.workspace is not None:
      oprot.writeFieldBegin('workspace', TType.STRING, 2)
      oprot.writeString(self.workspace)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_qbo_list_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_qbo_list_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_qbo_info_args:
  """
  Attributes:
   - token
   - table_name
   - workspace
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'workspace', None, None, ), # 3
  )

  def __init__(self, token=None, table_name=None, workspace=None,):
    self.token = token
    self.table_name = table_name
    self.workspace = workspace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.workspace = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_qbo_info_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.workspace is not None:
      oprot.writeFieldBegin('workspace', TType.STRING, 3)
      oprot.writeString(self.workspace)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_qbo_info_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_qbo_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
