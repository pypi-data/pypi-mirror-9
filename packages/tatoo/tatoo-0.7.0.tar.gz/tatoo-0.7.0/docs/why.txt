Why tatoo?
==========

The answer is very simple: the lack of powerful yet simple
task execution toolkits. It tries to bring the awesomeness of Celery
to the local task execution.

Here are some core features tatoo provides:

* laziness, almost everything is created on demand,
* extreme configurability,
* extensibility,
* beautiful programming api,
* it works the same in Python 2.6+, 3.3+ and Pypy,
* but it is written with Python 3 in mind, so it uses a lot of
  Python 3 features, carefully backported to Python 2,
* it is tested continuously on Linux, Windows and MacOS,
* it doesn't try to reinvent the wheel, requirements have been
  chosen carefully.

Of course, there are alternatives to tatoo and you can use them if
they're more suitable for you.

There are two features commonly missing in all listed libraries:

* configurability and
* extensibility.

There are a lot of use-cases when you will need to subclass the base
``Task`` class, for example, to provide specific method. How to tell
the library to use your custom subclass instead of base class?
Or how to add a custom command to the command line interface?

The answer is "you can't", or "monkey-patch".

Tatoo is written to be configurable and extensible as much as possible.
Cases listed above are "easy level" of tatoo configuring abilities.
You can even extend it to call tasks remotely!

Why not Pyinvoke?
-----------------

The programming interface that tatoo provides looks very similar to
the Pyinvoke's. However, Pyinvoke makes a lot of assumptions of how to handle
task arguments. For instance, it generates command line arguments and options
automatically from the function definition and automatically defines types
of arguments with default values (using :mod:`inspect` module).
The upside of this is that you don't need to write any code to make your task
available from the command line, keyword arguments are cased to corresponding
types automatically.
The downside is you can't really control this process. You can't specify
arguments and options explicitly. You can't define complex types (e.g.
``File`` type). Automatic generation of options makes your command line
interface to depend on the task signature - imagine that you want
to change the order of arguments, this will cause Pyinvoke to generate
options differently.

Pyinvoke brings unnecessary concepts of pre- and post-tasks, deduplication,
namespaces, contexts, standard tasks, contextualized tasks and so on. This
makes Pyinvoke difficult to learn and use.

Why not Doit, Shovel, Paver and others?
---------------------------------------

Other libraries has similar concerns, often they're too specialized. Some
libraries has very verbose syntax for defining tasks, others are too
simplified.
Also, it seems that these libraries were designed as
`Make for python <https://wiki.python.org/moin/ConfigurationAndBuildTools>`_.

Tatoo is not just yet-another-Make, although it can be used that way.
The aim of tatoo is to provide simple, but extensible interface to call
tasks and expect the possibility to add additional behaviors, so
you can start growing from a very simple task to a number of complex
tasks calling each other without days spent on reading the documentation and
the source code figuring out how to make a small step aside.
