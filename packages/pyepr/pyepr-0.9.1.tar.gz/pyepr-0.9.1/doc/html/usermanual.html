<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>User Manual &mdash; PyEPR 0.9.1 documentation</title>
    
    <link rel="stylesheet" href="_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.9.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="PyEPR 0.9.1 documentation" href="index.html" />
    <link rel="next" title="Tutorials" href="tutorials.html" />
    <link rel="prev" title="ENVISAT Product Reader Python API" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorials.html" title="Tutorials"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="ENVISAT Product Reader Python API"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PyEPR 0.9.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="user-manual">
<h1>User Manual<a class="headerlink" href="#user-manual" title="Permalink to this headline">¶</a></h1>
<div class="section" id="quick-start">
<h2>Quick start<a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a> provides <a class="reference external" href="https://www.python.org">Python</a> bindings for the ENVISAT Product Reader C API
(<a class="reference external" href="https://github.com/bcdev/epr-api">EPR API</a>) for reading satellite data from <a class="reference external" href="https://envisat.esa.int">ENVISAT</a> <a class="reference external" href="https://earth.esa.int">ESA</a> (European
Space Agency) mission.</p>
<p><a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a>, as well as the <a class="reference external" href="https://github.com/bcdev/epr-api">EPR API</a> for C, supports <a class="reference external" href="https://envisat.esa.int">ENVISAT</a> MERIS, AATSR
Level 1B and Level 2 and also ASAR data products. It provides access to
the data either on a geophysical (decoded, ready-to-use pixel samples)
or on a raw data layer. The raw data access makes it possible to read
any data field contained in a product file.</p>
<p>Full access to the Python EPR API is provided by the <a class="reference internal" href="reference.html#module-epr" title="epr: Python bindings for ENVISAT Product Reader C API"><tt class="xref py py-mod docutils literal"><span class="pre">epr</span></tt></a> module that
have to be imported by the client program e-g- as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">epr</span>
</pre></div>
</div>
<p>The following snippet open an ASAR product and dumps the &#8220;Main Processing
Parameters&#8221; record to the standard output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">epr</span>

<span class="n">product</span> <span class="o">=</span> <span class="n">epr</span><span class="o">.</span><span class="n">Product</span><span class="p">(</span>
    <span class="s">&#39;ASA_IMP_1PNUPA20060202_062233_000000152044_00435_20529_3110.N1&#39;</span><span class="p">)</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">get_dataset</span><span class="p">(</span><span class="s">&#39;MAIN_PROCESSING_PARAMS_ADS&#39;</span><span class="p">)</span>
<span class="n">record</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">read_record</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
<span class="n">product</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Since version 0.9 <a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a> also include <em>update</em> features that are not
available in the EPR C API.
The user can open a product in update mode (&#8216;rb+&#8217;) and call the
<a class="reference internal" href="reference.html#epr.Field.set_elem" title="epr.Field.set_elem"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Field.set_elem()</span></tt></a> and <a class="reference internal" href="reference.html#epr.Field.set_elems" title="epr.Field.set_elems"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Field.set_elems()</span></tt></a> methods of
<a class="reference internal" href="reference.html#epr.Field" title="epr.Field"><tt class="xref py py-class docutils literal"><span class="pre">epr.Field</span></tt></a> class to update its elements and write changes to disk.</p>
</div>
<div class="section" id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p>In order to use PyEPR it is needed that the following software are
correctly installed and configured:</p>
<ul class="simple">
<li><a class="reference external" href="https://www.python.org">Python2</a> &gt;= 2.6 or <a class="reference external" href="https://www.python.org">Python3</a> &gt;= 3.1</li>
<li><a class="reference external" href="http://www.numpy.org">numpy</a> &gt;= 1.5.0</li>
<li><a class="reference external" href="https://github.com/bcdev/epr-api">EPR API</a> &gt;= 2.2 (optional, since PyEPR 0.7 the source tar-ball comes
with a copy of the PER C API sources)</li>
<li>a reasonably updated C compiler <a class="footnote-reference" href="#id3" id="id1">[1]</a> (build only)</li>
<li><a class="reference external" href="http://cython.org">Cython</a> &gt;= 0.19 <a class="footnote-reference" href="#id4" id="id2">[2]</a> (optional and build only)</li>
<li><a class="reference external" href="https://pypi.python.org/pypi/unittest2">unittest2</a> (only required for Python &lt; 2.7)</li>
</ul>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a> has been developed and tested with <a class="reference external" href="http://gcc.gnu.org">gcc</a> 4.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><p class="first">The source tarball of official releases also includes the C extension
code generated by <a class="reference external" href="http://cython.org">cython</a> so users don&#8217;s strictly need <a class="reference external" href="http://cython.org">cython</a> to
install <a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a>.</p>
<p class="last">It is only needed to re-generate the C extension code (e.g. if one
wants to build a development version of <a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a>).</p>
</td></tr>
</tbody>
</table>
</div>
<div class="section" id="download">
<h2>Download<a class="headerlink" href="#download" title="Permalink to this headline">¶</a></h2>
<p>Official source tar-balls can be downloaded form <a class="reference external" href="https://pypi.python.org/pypi">PyPi</a>:</p>
<blockquote>
<div><a class="reference external" href="https://pypi.python.org/pypi/pyepr">https://pypi.python.org/pypi/pyepr</a></div></blockquote>
<p>The source code of the development versions is available on the <a class="reference external" href="https://github.com">GitHub</a>
project page</p>
<blockquote>
<div><a class="reference external" href="https://github.com/avalentino/pyepr">https://github.com/avalentino/pyepr</a></div></blockquote>
<p>To clone the <a class="reference external" href="http://git-scm.com">git</a> repository the following command can be used:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nv">$ </span>git clone https://github.com/avalentino/pyepr.git
</pre></div>
</div>
</div>
<div class="section" id="installation">
<span id="id5"></span><h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>The easier way to install <a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a> is using tools like <a class="reference external" href="https://pypi.python.org/pypi/pip">pip</a> or <a class="reference external" href="https://pypi.python.org/pypi/setuptools#using-setuptools-and-easyinstall">easy_install</a>:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nv">$ </span>pip install numpy pyepr
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>the <tt class="file docutils literal"><span class="pre">setup.py</span></tt> script does not use <a class="reference external" href="https://pypi.python.org/pypi/setuptools#using-setuptools-and-easyinstall">easy_install</a> specific functions
so it is unable to handle dependencies automatically.</p>
<p>Also the <tt class="file docutils literal"><span class="pre">setup.py</span></tt> script uses <a class="reference external" href="http://www.numpy.org">numpy</a> to retrieve the path of
headers and libraries.
For this reaseon <a class="reference external" href="http://www.numpy.org">numpy</a> must be already installed when <tt class="file docutils literal"><span class="pre">setup.py</span></tt>
is executed.</p>
<p>In the above example the required <a class="reference external" href="http://www.numpy.org">numpy</a> package is explicitly included in
the list of packages to be installed.</p>
<div class="last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#requirements">Requirements</a></p>
</div>
</div>
<p><a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a> uses the standard <a class="reference external" href="https://www.python.org">Python</a> <a class="reference external" href="https://docs.python.org/3/distutils">distutils</a> so it can be installed from
sources using the following command:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nv">$ </span>python setup.py install
</pre></div>
</div>
<p>For a user specific installation use:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nv">$ </span>python setup.py install --user
</pre></div>
</div>
<p>To install <a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a> in a non-standard path:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nv">$ </span>python setup.py install --prefix<span class="o">=</span>&lt;TARGET_PATH&gt;
</pre></div>
</div>
<p>just make sure that <tt class="file docutils literal"><span class="pre">&lt;TARGET_PATH&gt;/lib/pythonX.Y/site-packages</span></tt> is in
the <span class="target" id="index-0"></span><a class="reference external" href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH" title="(in Python v3.4)"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></tt></a>.</p>
<p>The <tt class="file docutils literal"><span class="pre">setup.py</span></tt> script by default checks for the availability of the
EPR C API source code in the <tt class="file docutils literal"><span class="pre">&lt;package-root&gt;/epr-api-src</span></tt> directory
and tries to build PyEPR in <em>standalone mode</em>, i.e. without linking an
external dynamic library of EPR-API.</p>
<p>If no EPR C API sources are found then the <tt class="file docutils literal"><span class="pre">setup.py</span></tt> of PyEPR
automatically tries to link the EPR-API dynamic library.
This can happen, for example, if the user is using a copy of the PyEPR
sources cloned from a <a class="reference external" href="http://git-scm.com">git</a> repository.
In this case it is assumed that the <a class="reference external" href="https://github.com/bcdev/epr-api">EPR API</a> C library is properly
installed in the system (see the <a class="reference internal" href="#requirements">Requirements</a> section).</p>
<p>It is possible to control which <a class="reference external" href="https://github.com/bcdev/epr-api">EPR API</a> C sources to use by means of the
<em class="xref std std-option">--epr-api-src</em> option of the <tt class="file docutils literal"><span class="pre">setup.py</span></tt> script:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nv">$ </span>python setup.py install --epr-api-src<span class="o">=</span>../epr-api/src
</pre></div>
</div>
<p>Also it is possible to switch off the <em>standalone mode</em> and force the link
with the system <a class="reference external" href="https://github.com/bcdev/epr-api">EPR API</a> C library:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nv">$ </span>python setup.py install --epr-api-src<span class="o">=</span>None
</pre></div>
</div>
</div>
<div class="section" id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a> package comes with a complete test suite but in order to run it
the ENVISAT sample product used for testing,
<a class="reference external" href="https://earth.esa.int/services/sample_products/meris/LRC/L2/MER_LRC_2PTGMV20000620_104318_00000104X000_00000_00000_0001.N1.gz">MER_LRC_2PTGMV20000620_104318_00000104X000_00000_00000_0001.N1</a>,
have to be downloaded from the <a class="reference external" href="https://earth.esa.int">ESA</a> website, saved in the <tt class="file docutils literal"><span class="pre">tests</span></tt>
directory and decompressed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">since <a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a> 0.9.0 the test product is downloaded and decompressed
automatically by the test script if not already available.
In this case a working Internet connection is expected to be available
when the test suite is run.</p>
</div>
<p>On GNU Linux platforms the following shell commands can be used:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nv">$ </span><span class="nb">cd </span>pyepr-X.Y.Z/tests
<span class="nv">$ </span>wget https://earth.esa.int/services/sample_products/meris/LRC/L2/<span class="se">\</span>
  MER_LRC_2PTGMV20000620_104318_00000104X000_00000_00000_0001.N1.gz
<span class="nv">$ </span>gunzip MER_LRC_2PTGMV20000620_104318_00000104X000_00000_00000_0001.N1.gz
</pre></div>
</div>
<p>After installation the test suite can be run using the following command
in the <tt class="file docutils literal"><span class="pre">tests</span></tt> directory:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nv">$ </span>python test_all.py
</pre></div>
</div>
</div>
<div class="section" id="python-vs-c-api">
<h2>Python vs C API<a class="headerlink" href="#python-vs-c-api" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="https://www.python.org">Python</a> EPR API is fully object oriented.
The main structures of the <a class="reference external" href="https://rawgithub.com/bcdev/epr-api/master/docs/epr_c_api/index.html">C API</a> have been implemented as objects while
C function have been logically grouped and mapped onto object methods.</p>
<p>The entire process of defining an object oriented API for <a class="reference external" href="https://www.python.org">Python</a> has
been quite easy and straightforward thanks to the good design of the C
API,</p>
<p>Of course there are also some differences that are illustrated in the
following sections.</p>
</div>
<div class="section" id="memory-management">
<h2>Memory management<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h2>
<p>Being <a class="reference external" href="https://www.python.org">Python</a> a very high level language uses have never to worry about
memory allocation/de-allocation. They simply have to instantiate objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">product</span> <span class="o">=</span> <span class="n">epr</span><span class="o">.</span><span class="n">Product</span><span class="p">(</span><span class="s">&#39;filename.N1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>and use them freely.</p>
<p>Objects are automatically destroyed when there are no more references to
them and memory is de-allocated automatically.</p>
<p>Even better, each object holds a reference to other objects it depends
on so the user never have to worry about identifiers validity or about
the correct order structures have to be freed.</p>
<p>For example: the C <cite>EPR_DatasetId</cite> structure has a field (<cite>product_id</cite>)
that points to the <em>product</em> descriptor <cite>EPR_productId</cite> to which it
belongs to.</p>
<p>The reference to the parent product is used, for example, when one wants
to read a record using the <cite>epr_read_record</cite> function:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">EPR_SRecord</span><span class="o">*</span> <span class="nf">epr_read_record</span><span class="p">(</span><span class="n">EPR_SDatasetId</span><span class="o">*</span> <span class="n">dataset_id</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
<p>The function takes a <cite>EPR_SDatasetId</cite> as a parameter and assumes all
fields (including <tt class="docutils literal"><span class="pre">dataset-&gt;product_id</span></tt>) are valid.
It is responsibility of the programmer to keep all structures valid and
free them at the right moment and in the correct order.</p>
<p>This is the standard way to go in C but not in <a class="reference external" href="https://www.python.org">Python</a>.</p>
<p>In <a class="reference external" href="https://www.python.org">Python</a> all is by far simpler, and the user can get a <em>dateset</em>
object instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dataset</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">get_dataset</span><span class="p">(</span><span class="s">&#39;MAIN_PROCESSING_PARAMS_ADS&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>and then forget about the <em>product</em> instance it depends on.
Even if the <em>product</em> variable goes out of scope and it is no more directly
accessible in the program the <em>dataset</em> object keeps staying valid since
it holds an internal reference to the <em>product</em> instance it depends on.</p>
<p>When <em>record</em> is destroyed automatically also the parent <a class="reference internal" href="reference.html#epr.Product" title="epr.Product"><tt class="xref py py-class docutils literal"><span class="pre">epr.Product</span></tt></a>
object is destroyed (assumed there is no other reference to it).</p>
<p>The entire machinery is completely automatic and transparent to the user.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">of course when a <em>product</em> object is explicitly closed using the
<a class="reference internal" href="reference.html#epr.Product.close" title="epr.Product.close"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Product.close()</span></tt></a> any I/O operation on it and on other objects
(bands, datasets, etc) associated to it is no more possible.</p>
</div>
</div>
<div class="section" id="arrays">
<h2>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a> uses <a class="reference external" href="http://www.numpy.org">numpy</a> in order to manage efficiently the potentially large
amount of data contained in <a class="reference external" href="https://envisat.esa.int">ENVISAT</a> products.</p>
<ul>
<li><p class="first"><a class="reference internal" href="reference.html#epr.Field.get_elems" title="epr.Field.get_elems"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Field.get_elems()</span></tt></a> return an 1D array containing elements of
the field</p>
</li>
<li><p class="first">the <cite>Raster.data</cite> property is a 2D array exposes data contained in the
<a class="reference internal" href="reference.html#epr.Raster" title="epr.Raster"><tt class="xref py py-class docutils literal"><span class="pre">epr.Raster</span></tt></a> object in form of <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt></a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><a class="reference internal" href="reference.html#epr.Raster.data" title="epr.Raster.data"><tt class="xref py py-attr docutils literal"><span class="pre">epr.Raster.data</span></tt></a> directly exposes <a class="reference internal" href="reference.html#epr.Raster" title="epr.Raster"><tt class="xref py py-class docutils literal"><span class="pre">epr.Raster</span></tt></a>
i.e. shares the same memory buffer with <a class="reference internal" href="reference.html#epr.Raster" title="epr.Raster"><tt class="xref py py-class docutils literal"><span class="pre">epr.Raster</span></tt></a>:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">raster</span><span class="o">.</span><span class="n">get_pixel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raster</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raster</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raster</span><span class="o">.</span><span class="n">get_pixel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="reference.html#epr.Band.read_as_array" title="epr.Band.read_as_array"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Band.read_as_array()</span></tt></a> is an additional method provided by
the <a class="reference external" href="https://www.python.org">Python</a> EPR API (does not exist any correspondent function in the
C API). It is mainly a facility method that allows users to get access
to band data without creating an intermediate <a class="reference internal" href="reference.html#epr.Raster" title="epr.Raster"><tt class="xref py py-class docutils literal"><span class="pre">epr.Raster</span></tt></a> object.
It read a slice of data from the <a class="reference internal" href="reference.html#epr.Band" title="epr.Band"><tt class="xref py py-class docutils literal"><span class="pre">epr.Band</span></tt></a> and returns it as a
2D <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt></a>.</p>
</li>
</ul>
</div>
<div class="section" id="enumerators">
<h2>Enumerators<a class="headerlink" href="#enumerators" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://www.python.org">Python</a> does not have <em>enumerators</em> at language level (at least this is true
for <a class="reference external" href="https://www.python.org">Python</a> &lt; 3.4).
Enumerations are simply mapped as module constants that have the same
name of the C enumerate but are spelled all in capital letters.</p>
<p>For example:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">C</th>
<th class="head">Pythn</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>e_tid_double</td>
<td>E_TID_DOUBLE</td>
</tr>
<tr class="row-odd"><td>e_smod_1OF1</td>
<td>E_SMOD_1OF1</td>
</tr>
<tr class="row-even"><td>e_smid_log</td>
<td>E_SMID_LOG</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="error-handling-and-logging">
<h2>Error handling and logging<a class="headerlink" href="#error-handling-and-logging" title="Permalink to this headline">¶</a></h2>
<p>Currently error handling and logging functions of the EPR C API are not
exposed to python.</p>
<p>Internal library logging is completely silenced and errors are converted
to <a class="reference external" href="https://www.python.org">Python</a> exceptions.
Where appropriate standard <a class="reference external" href="https://www.python.org">Python</a> exception types are use in other cases
custom exception types (e.g. <a class="reference internal" href="reference.html#epr.EPRError" title="epr.EPRError"><tt class="xref py py-exc docutils literal"><span class="pre">epr.EPRError</span></tt></a>,
<a class="reference internal" href="reference.html#epr.EPRValueError" title="epr.EPRValueError"><tt class="xref py py-exc docutils literal"><span class="pre">epr.EPRValueError</span></tt></a>) are used.</p>
</div>
<div class="section" id="library-initialization">
<h2>Library initialization<a class="headerlink" href="#library-initialization" title="Permalink to this headline">¶</a></h2>
<p>Differently from the C API library initialization is not needed: it is
performed internally the first time the <a class="reference internal" href="reference.html#module-epr" title="epr: Python bindings for ENVISAT Product Reader C API"><tt class="xref py py-mod docutils literal"><span class="pre">epr</span></tt></a> module is imported
in <a class="reference external" href="https://www.python.org">Python</a>.</p>
</div>
<div class="section" id="high-level-api">
<h2>High level API<a class="headerlink" href="#high-level-api" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a> provides some utility method that has no correspondent in the C API:</p>
<ul class="simple">
<li><a class="reference internal" href="reference.html#epr.Record.fields" title="epr.Record.fields"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Record.fields()</span></tt></a></li>
<li><a class="reference internal" href="reference.html#epr.Record.get_field_names" title="epr.Record.get_field_names"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Record.get_field_names()</span></tt></a></li>
<li><a class="reference internal" href="reference.html#epr.Dataset.records" title="epr.Dataset.records"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Dataset.records()</span></tt></a></li>
<li><a class="reference internal" href="reference.html#epr.Product.get_dataset_names" title="epr.Product.get_dataset_names"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Product.get_dataset_names()</span></tt></a></li>
<li><a class="reference internal" href="reference.html#epr.Product.get_band_names" title="epr.Product.get_band_names"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Product.get_band_names()</span></tt></a></li>
<li><a class="reference internal" href="reference.html#epr.Product.datasets" title="epr.Product.datasets"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Product.datasets()</span></tt></a></li>
<li><a class="reference internal" href="reference.html#epr.Product.bands" title="epr.Product.bands"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Product.bands()</span></tt></a></li>
</ul>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">product</span><span class="o">.</span><span class="n">datasets</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">records</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="k">print</span><span class="p">()</span>
</pre></div>
</div>
<p>Another example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="s">&#39;proc_data&#39;</span> <span class="ow">in</span> <span class="n">product</span><span class="o">.</span><span class="n">band_names</span><span class="p">():</span>
    <span class="n">band</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="s">&#39;proc_data&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">band</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="special-methods">
<h2>Special methods<a class="headerlink" href="#special-methods" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="https://www.python.org">Python</a> EPR API also implements some <a class="reference external" href="https://docs.python.org/3/reference/datamodel.html">special method</a> in order to make
EPR programming even handy and, in short, <a class="reference external" href="http://www.cafepy.com/article/be_pythonic">pythonic</a>.</p>
<p>The <tt class="docutils literal"><span class="pre">__repr__</span></tt> methods have been overridden to provide a little more
information with respect to the standard implementation.</p>
<p>In some cases <tt class="docutils literal"><span class="pre">__str__</span></tt> method have been overridden to output a verbose
string representation of the objects and their contents.</p>
<p>If the EPR object has a <tt class="docutils literal"><span class="pre">print_</span></tt> method (like e.g. <a class="reference internal" href="reference.html#epr.Record.print_" title="epr.Record.print_"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Record.print_()</span></tt></a>
and <a class="reference internal" href="reference.html#epr.Field.print_" title="epr.Field.print_"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Field.print_()</span></tt></a>) then the string representation of the object
will have the same format used by the <tt class="docutils literal"><span class="pre">print_</span></tt> method.
So writing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
</pre></div>
</div>
<p>giver the same result of:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">record</span><span class="o">.</span><span class="n">print_</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
</pre></div>
</div>
<p>Of course the <a class="reference internal" href="reference.html#epr.Record.print_" title="epr.Record.print_"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Record.print_()</span></tt></a> method is more efficient for writing
to file.</p>
<p>Also <a class="reference internal" href="reference.html#epr.Dataset" title="epr.Dataset"><tt class="xref py py-class docutils literal"><span class="pre">epr.Dataset</span></tt></a> and <a class="reference internal" href="reference.html#epr.Record" title="epr.Record"><tt class="xref py py-class docutils literal"><span class="pre">epr.Record</span></tt></a> classes implement the
<tt class="docutils literal"><span class="pre">__iter__</span></tt> <a class="reference external" href="https://docs.python.org/3/reference/datamodel.html">special method</a> for iterating over records and fields
respectively.
So it is possible to write code like the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">field</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference.html#epr.DSD" title="epr.DSD"><tt class="xref py py-class docutils literal"><span class="pre">epr.DSD</span></tt></a> and <a class="reference internal" href="reference.html#epr.Field" title="epr.Field"><tt class="xref py py-class docutils literal"><span class="pre">epr.Field</span></tt></a> classes implement the <tt class="docutils literal"><span class="pre">__eq__</span></tt>
and <tt class="docutils literal"><span class="pre">__ne__</span></tt> methods for objects comparison:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">filed1</span> <span class="o">==</span> <span class="n">field2</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;field 1 and field2 are equal&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">field1</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;field1:&#39;</span><span class="p">,</span> <span class="n">field1</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;field2:&#39;</span><span class="p">,</span> <span class="n">field2</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference.html#epr.Field" title="epr.Field"><tt class="xref py py-class docutils literal"><span class="pre">epr.Field</span></tt></a> object also implement the <tt class="docutils literal"><span class="pre">__len__</span></tt> special method
that returns the number of elements in the field:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">get_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">epr</span><span class="o">.</span><span class="n">E_TID_STRING</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">field</span><span class="o">.</span><span class="n">get_num_elems</span><span class="p">()</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">get_elem</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">differently from the <a class="reference internal" href="reference.html#epr.Field.get_num_elems" title="epr.Field.get_num_elems"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Field.get_num_elems()</span></tt></a> method
<tt class="docutils literal"><span class="pre">len(field)</span></tt> return the number of elements if the field
type is not <a class="reference internal" href="reference.html#epr.E_TID_STRING" title="epr.E_TID_STRING"><tt class="xref py py-data docutils literal"><span class="pre">epr.E_TID_STRING</span></tt></a>.
If the field contains a string then the string length is
returned.</p>
</div>
<p>Finally the <a class="reference internal" href="reference.html#epr.Product" title="epr.Product"><tt class="xref py py-class docutils literal"><span class="pre">epr.Product</span></tt></a> class acts as a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#context-manager-types">context manager</a> (i.e. it
implements the <tt class="docutils literal"><span class="pre">__enter__</span></tt> and <tt class="docutils literal"><span class="pre">__exit__</span></tt> methods).</p>
<p>This allows the user to write code like the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">epr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;ASA_IMS_ ... _4650.N1&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">product</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
</pre></div>
</div>
<p>that ensure that the product is closed as soon as the program exits the
<tt class="docutils literal"><span class="pre">with</span></tt> block.</p>
</div>
<div class="section" id="update-support">
<h2>Update support<a class="headerlink" href="#update-support" title="Permalink to this headline">¶</a></h2>
<p>It is not possible to create new <a class="reference external" href="https://envisat.esa.int">ENVISAT</a> products for scratch with the
EPR API. Indeed EPR means &#8220;<strong>E</strong>NVISAT <strong>P</strong>roduct <strong>R</strong>eaeder&#8221;.
Anyway, since version 0.9, <a class="reference external" href="https://github.com/avalentino/pyepr">PyEPR</a> also include basic <em>update</em> features.
This means that, while it is still not possible to create new
<tt class="xref py py-class docutils literal"><span class="pre">Products</span></tt>, the user can <em>update</em> existing ones changing the
contents of any <tt class="xref py py-class docutils literal"><span class="pre">Field</span></tt> in any record with the only exception of
MPH and SPH <tt class="xref py py-class docutils literal"><span class="pre">Field</span></tt>s.</p>
<p>The user can open a product in update mode (&#8216;rb+&#8217;):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">product</span> <span class="o">=</span> <span class="n">epr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;ASA_IMS_ ... _4650.N1&#39;</span><span class="p">,</span> <span class="s">&#39;rb+&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>and update the <a class="reference internal" href="reference.html#epr.Field" title="epr.Field"><tt class="xref py py-class docutils literal"><span class="pre">epr.Field</span></tt></a> element at a specific index:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">field</span><span class="o">.</span><span class="n">set_elem</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
<p>or also update all elements ol the <a class="reference internal" href="reference.html#epr.Field" title="epr.Field"><tt class="xref py py-class docutils literal"><span class="pre">epr.Field</span></tt></a> in one shot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">field</span><span class="o">.</span><span class="n">set_elems</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>unfortunately there are some limitations to the update support.
Many of the internal structures of the EPR C API are loaded when the
<tt class="xref py py-class docutils literal"><span class="pre">Product</span></tt> is opened and are not automatically updated when the
<a class="reference internal" href="reference.html#epr.Field.set_elem" title="epr.Field.set_elem"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Field.set_elem()</span></tt></a> and <a class="reference internal" href="reference.html#epr.Field.set_elems" title="epr.Field.set_elems"><tt class="xref py py-meth docutils literal"><span class="pre">epr.Field.set_elems()</span></tt></a> methods are
called.
In particular <a class="reference internal" href="reference.html#epr.Band" title="epr.Band"><tt class="xref py py-class docutils literal"><span class="pre">epr.Band</span></tt></a>s contents may depend on several
<a class="reference internal" href="reference.html#epr.Field" title="epr.Field"><tt class="xref py py-class docutils literal"><span class="pre">epr.Field</span></tt></a> values, e.g. the contents of <cite>Scaling_Factor_GADS</cite>
<a class="reference internal" href="reference.html#epr.Dataset" title="epr.Dataset"><tt class="xref py py-class docutils literal"><span class="pre">epr.Dataset</span></tt></a>.
For this reason the user may need to close and re-open the
<a class="reference internal" href="reference.html#epr.Product" title="epr.Product"><tt class="xref py py-class docutils literal"><span class="pre">epr.Product</span></tt></a> in order to have all changes effectively applied.</p>
<div class="last admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="update_example.html"><em>Update Field elements</em></a>.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">User Manual</a><ul>
<li><a class="reference internal" href="#quick-start">Quick start</a></li>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
<li><a class="reference internal" href="#download">Download</a></li>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#testing">Testing</a></li>
<li><a class="reference internal" href="#python-vs-c-api">Python vs C API</a></li>
<li><a class="reference internal" href="#memory-management">Memory management</a></li>
<li><a class="reference internal" href="#arrays">Arrays</a></li>
<li><a class="reference internal" href="#enumerators">Enumerators</a></li>
<li><a class="reference internal" href="#error-handling-and-logging">Error handling and logging</a></li>
<li><a class="reference internal" href="#library-initialization">Library initialization</a></li>
<li><a class="reference internal" href="#high-level-api">High level API</a></li>
<li><a class="reference internal" href="#special-methods">Special methods</a></li>
<li><a class="reference internal" href="#update-support">Update support</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">ENVISAT Product Reader Python API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tutorials.html"
                        title="next chapter">Tutorials</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/usermanual.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorials.html" title="Tutorials"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="ENVISAT Product Reader Python API"
             >previous</a> |</li>
        <li><a href="index.html">PyEPR 0.9.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2015, Antonio Valentino.
      Last updated on Feb 27, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>