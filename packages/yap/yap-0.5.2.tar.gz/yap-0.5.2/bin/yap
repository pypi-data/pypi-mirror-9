#!/usr/bin/python

#################################################################################
#
# The MIT License (MIT)
#
# Copyright (c) 2015 Dmitry Sovetov
#
# https://github.com/dmsovetov
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#################################################################################

import argparse, os, glob

from yap import Project
from yap import Generator
from yap import Makefile
from yap import StaticLibrary
from yap import Executable
from yap import ExternalLibrary
from yap import ExternalPackage

# parseUnknownArguments
def parseUnknownArguments( args ):
	for arg in args:
		if not arg.startswith( '--' ):
			continue

		items = arg.split( '=' )
		name  = items[0][2:].upper()

		if len( items ) == 1:
			Makefile.getProject().define( 'DC_' + name + '_ENABLED' )
		else:
			Makefile.getProject().define( 'DC_' + name + '=' + items[1] )
			Makefile.getProject().define( 'DC_' + name + '_' + items[1].upper() )
			Makefile.set( name, items[1] )

# Entry point
if __name__ == "__main__":
	name = os.path.basename( os.getcwd() )

	# Parse arguments
	parser = argparse.ArgumentParser( description = 'Yet Another Project Generator', prefix_chars = '--', formatter_class = argparse.ArgumentDefaultsHelpFormatter )

	parser.add_argument( "platform",                             type = str, help = "Target platform" )
	parser.add_argument( "-s", "--source", default = '.',        type = str, help = "Project source path" )
	parser.add_argument( "-o", "--output", default = 'projects', type = str, help = "Output path" )
	parser.add_argument( "-n", "--name",   default = name,       type = str, help = "Workspace (solution) name" )

	args, unknown = parser.parse_known_args()

	if args.platform == 'install':
		print 'Error: install is not implemented'
		exit(1)

	if args.platform == 'build':
		print 'Error: build is not implemented'
		exit(1)

	if not os.path.exists( os.path.join( args.source, 'Makefile.py' ) ):
		print 'Error: no Makefile.py file found.'
		exit(1)

	platforms = { 'macos': 'MacOS', 'windows': 'Windows', 'flash': 'Flash', 'android': 'Android', 'ios': 'iOS', 'html5': 'HTML5' }
	if args.platform in platforms.keys():
		args.platform = platforms[args.platform]

	# Generate project
	Makefile.set( 'PLATFORM', args.platform )
	Makefile.setPaths( os.path.abspath( args.source ), os.path.abspath( args.output ) )
	Makefile.initialize( Project, args.name, args.platform, (lambda fileName: execfile( fileName )) )
	Makefile.getProject().define( 'DC_PLATFORM_' + args.platform.upper() )
	Makefile.getProject().define( 'DC_PLATFORM=' + args.platform )

	# Parse unknown arguments
	parseUnknownArguments( unknown )

	# Build config
	platform	    = args.platform
	findFramework   = ExternalLibrary.find
	findPackage     = ExternalPackage.find
	project         = Makefile.getProject()

	# Include
	def Include( *list ):
		for path in list:
			Makefile.getProject().target( path )

	# Has
	def Has( name ):
		return Makefile.get( name.upper() ) != None

	# Folders
	def Folders( path ):
		# class Folder
		class Folder:
			def __init__( self, path ):
				self.name = os.path.basename( path )
				self.path = path

		return [Folder( path ) for path in glob.glob( os.path.join( Makefile.getCurrentSourceDir(), path ) ) if os.path.isdir( path )]

	# Files
	def Files( path ):
		# class Folder
		class File:
			def __init__( self, path ):
				self.name = os.path.basename( path )
				self.path = path

		return [File( path ) for path in glob.glob( os.path.join( Makefile.getCurrentSourceDir(), path ) ) if os.path.isfile( path )]

	execfile( Makefile.SourceDir + '/Makefile.py' )

	Makefile.generate()
