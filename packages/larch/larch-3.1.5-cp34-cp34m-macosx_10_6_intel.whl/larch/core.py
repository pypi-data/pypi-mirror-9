# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
Larch can be used to estimate discrete choice models.
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_core', [dirname(__file__)])
        except ImportError:
            import _core
            return _core
        if fp is not None:
            try:
                _mod = imp.load_module('_core', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _core = swig_import_helper()
    del swig_import_helper
else:
    import _core
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


class LarchError(Exception):
	def __str__(self):
		return "ELM has encountered an error:" + Exception.__str__(self)
class SQLiteError(Exception):
	def __str__(self):
		return "ELM has encountered an error using SQLite:" + Exception.__str__(self)
class FacetError(Exception):
	def __str__(self):
		return "ELM has encountered an error in the data facet:" + Exception.__str__(self)
pass	

LarchError = _core.LarchError
SQLiteError = _core.SQLiteError
FacetError = _core.FacetError

class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self) -> "PyObject *" : return _core.SwigPyIterator_value(self)
    def incr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" : return _core.SwigPyIterator_incr(self, n)
    def decr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" : return _core.SwigPyIterator_decr(self, n)
    def distance(self, *args) -> "ptrdiff_t" : return _core.SwigPyIterator_distance(self, *args)
    def equal(self, *args) -> "bool" : return _core.SwigPyIterator_equal(self, *args)
    def copy(self) -> "swig::SwigPyIterator *" : return _core.SwigPyIterator_copy(self)
    def next(self) -> "PyObject *" : return _core.SwigPyIterator_next(self)
    def __next__(self) -> "PyObject *" : return _core.SwigPyIterator___next__(self)
    def previous(self) -> "PyObject *" : return _core.SwigPyIterator_previous(self)
    def advance(self, *args) -> "swig::SwigPyIterator *" : return _core.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args) -> "bool" : return _core.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args) -> "bool" : return _core.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args) -> "swig::SwigPyIterator &" : return _core.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args) -> "swig::SwigPyIterator &" : return _core.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args) -> "swig::SwigPyIterator *" : return _core.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args) -> "ptrdiff_t" : return _core.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _core.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _core.SHARED_PTR_DISOWN
import numpy
__default_array_type__ = numpy.ndarray



class IntVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.IntVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.IntVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.IntVector___bool__(self)
    def __len__(self) -> "std::vector< int >::size_type" : return _core.IntVector___len__(self)
    def pop(self) -> "std::vector< int >::value_type" : return _core.IntVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< int,std::allocator< int > > *" : return _core.IntVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.IntVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.IntVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.IntVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< int >::value_type const &" : return _core.IntVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.IntVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.IntVector_append(self, *args)
    def empty(self) -> "bool" : return _core.IntVector_empty(self)
    def size(self) -> "std::vector< int >::size_type" : return _core.IntVector_size(self)
    def clear(self) -> "void" : return _core.IntVector_clear(self)
    def swap(self, *args) -> "void" : return _core.IntVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< int >::allocator_type" : return _core.IntVector_get_allocator(self)
    def begin(self) -> "std::vector< int >::iterator" : return _core.IntVector_begin(self)
    def end(self) -> "std::vector< int >::iterator" : return _core.IntVector_end(self)
    def rbegin(self) -> "std::vector< int >::reverse_iterator" : return _core.IntVector_rbegin(self)
    def rend(self) -> "std::vector< int >::reverse_iterator" : return _core.IntVector_rend(self)
    def pop_back(self) -> "void" : return _core.IntVector_pop_back(self)
    def erase(self, *args) -> "std::vector< int >::iterator" : return _core.IntVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_IntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.IntVector_push_back(self, *args)
    def front(self) -> "std::vector< int >::value_type const &" : return _core.IntVector_front(self)
    def back(self) -> "std::vector< int >::value_type const &" : return _core.IntVector_back(self)
    def assign(self, *args) -> "void" : return _core.IntVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.IntVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.IntVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.IntVector_reserve(self, *args)
    def capacity(self) -> "std::vector< int >::size_type" : return _core.IntVector_capacity(self)
    __swig_destroy__ = _core.delete_IntVector
    __del__ = lambda self : None;
IntVector_swigregister = _core.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.DoubleVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.DoubleVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.DoubleVector___bool__(self)
    def __len__(self) -> "std::vector< double >::size_type" : return _core.DoubleVector___len__(self)
    def pop(self) -> "std::vector< double >::value_type" : return _core.DoubleVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< double,std::allocator< double > > *" : return _core.DoubleVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.DoubleVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.DoubleVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.DoubleVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< double >::value_type const &" : return _core.DoubleVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.DoubleVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.DoubleVector_append(self, *args)
    def empty(self) -> "bool" : return _core.DoubleVector_empty(self)
    def size(self) -> "std::vector< double >::size_type" : return _core.DoubleVector_size(self)
    def clear(self) -> "void" : return _core.DoubleVector_clear(self)
    def swap(self, *args) -> "void" : return _core.DoubleVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< double >::allocator_type" : return _core.DoubleVector_get_allocator(self)
    def begin(self) -> "std::vector< double >::iterator" : return _core.DoubleVector_begin(self)
    def end(self) -> "std::vector< double >::iterator" : return _core.DoubleVector_end(self)
    def rbegin(self) -> "std::vector< double >::reverse_iterator" : return _core.DoubleVector_rbegin(self)
    def rend(self) -> "std::vector< double >::reverse_iterator" : return _core.DoubleVector_rend(self)
    def pop_back(self) -> "void" : return _core.DoubleVector_pop_back(self)
    def erase(self, *args) -> "std::vector< double >::iterator" : return _core.DoubleVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.DoubleVector_push_back(self, *args)
    def front(self) -> "std::vector< double >::value_type const &" : return _core.DoubleVector_front(self)
    def back(self) -> "std::vector< double >::value_type const &" : return _core.DoubleVector_back(self)
    def assign(self, *args) -> "void" : return _core.DoubleVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.DoubleVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.DoubleVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.DoubleVector_reserve(self, *args)
    def capacity(self) -> "std::vector< double >::size_type" : return _core.DoubleVector_capacity(self)
    __swig_destroy__ = _core.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _core.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class ULongLongVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.ULongLongVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.ULongLongVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.ULongLongVector___bool__(self)
    def __len__(self) -> "std::vector< unsigned long long >::size_type" : return _core.ULongLongVector___len__(self)
    def pop(self) -> "std::vector< unsigned long long >::value_type" : return _core.ULongLongVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< unsigned long long,std::allocator< unsigned long long > > *" : return _core.ULongLongVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.ULongLongVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.ULongLongVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.ULongLongVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< unsigned long long >::value_type const &" : return _core.ULongLongVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.ULongLongVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.ULongLongVector_append(self, *args)
    def empty(self) -> "bool" : return _core.ULongLongVector_empty(self)
    def size(self) -> "std::vector< unsigned long long >::size_type" : return _core.ULongLongVector_size(self)
    def clear(self) -> "void" : return _core.ULongLongVector_clear(self)
    def swap(self, *args) -> "void" : return _core.ULongLongVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< unsigned long long >::allocator_type" : return _core.ULongLongVector_get_allocator(self)
    def begin(self) -> "std::vector< unsigned long long >::iterator" : return _core.ULongLongVector_begin(self)
    def end(self) -> "std::vector< unsigned long long >::iterator" : return _core.ULongLongVector_end(self)
    def rbegin(self) -> "std::vector< unsigned long long >::reverse_iterator" : return _core.ULongLongVector_rbegin(self)
    def rend(self) -> "std::vector< unsigned long long >::reverse_iterator" : return _core.ULongLongVector_rend(self)
    def pop_back(self) -> "void" : return _core.ULongLongVector_pop_back(self)
    def erase(self, *args) -> "std::vector< unsigned long long >::iterator" : return _core.ULongLongVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_ULongLongVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.ULongLongVector_push_back(self, *args)
    def front(self) -> "std::vector< unsigned long long >::value_type const &" : return _core.ULongLongVector_front(self)
    def back(self) -> "std::vector< unsigned long long >::value_type const &" : return _core.ULongLongVector_back(self)
    def assign(self, *args) -> "void" : return _core.ULongLongVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.ULongLongVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.ULongLongVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.ULongLongVector_reserve(self, *args)
    def capacity(self) -> "std::vector< unsigned long long >::size_type" : return _core.ULongLongVector_capacity(self)
    __swig_destroy__ = _core.delete_ULongLongVector
    __del__ = lambda self : None;
ULongLongVector_swigregister = _core.ULongLongVector_swigregister
ULongLongVector_swigregister(ULongLongVector)

class LongLongVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.LongLongVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.LongLongVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.LongLongVector___bool__(self)
    def __len__(self) -> "std::vector< long long >::size_type" : return _core.LongLongVector___len__(self)
    def pop(self) -> "std::vector< long long >::value_type" : return _core.LongLongVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< long long,std::allocator< long long > > *" : return _core.LongLongVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.LongLongVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.LongLongVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.LongLongVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< long long >::value_type const &" : return _core.LongLongVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.LongLongVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.LongLongVector_append(self, *args)
    def empty(self) -> "bool" : return _core.LongLongVector_empty(self)
    def size(self) -> "std::vector< long long >::size_type" : return _core.LongLongVector_size(self)
    def clear(self) -> "void" : return _core.LongLongVector_clear(self)
    def swap(self, *args) -> "void" : return _core.LongLongVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< long long >::allocator_type" : return _core.LongLongVector_get_allocator(self)
    def begin(self) -> "std::vector< long long >::iterator" : return _core.LongLongVector_begin(self)
    def end(self) -> "std::vector< long long >::iterator" : return _core.LongLongVector_end(self)
    def rbegin(self) -> "std::vector< long long >::reverse_iterator" : return _core.LongLongVector_rbegin(self)
    def rend(self) -> "std::vector< long long >::reverse_iterator" : return _core.LongLongVector_rend(self)
    def pop_back(self) -> "void" : return _core.LongLongVector_pop_back(self)
    def erase(self, *args) -> "std::vector< long long >::iterator" : return _core.LongLongVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_LongLongVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.LongLongVector_push_back(self, *args)
    def front(self) -> "std::vector< long long >::value_type const &" : return _core.LongLongVector_front(self)
    def back(self) -> "std::vector< long long >::value_type const &" : return _core.LongLongVector_back(self)
    def assign(self, *args) -> "void" : return _core.LongLongVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.LongLongVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.LongLongVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.LongLongVector_reserve(self, *args)
    def capacity(self) -> "std::vector< long long >::size_type" : return _core.LongLongVector_capacity(self)
    __swig_destroy__ = _core.delete_LongLongVector
    __del__ = lambda self : None;
LongLongVector_swigregister = _core.LongLongVector_swigregister
LongLongVector_swigregister(LongLongVector)

class StrVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.StrVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.StrVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.StrVector___bool__(self)
    def __len__(self) -> "std::vector< std::string >::size_type" : return _core.StrVector___len__(self)
    def pop(self) -> "std::vector< std::string >::value_type" : return _core.StrVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< std::string,std::allocator< std::string > > *" : return _core.StrVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.StrVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.StrVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.StrVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &" : return _core.StrVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.StrVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.StrVector_append(self, *args)
    def empty(self) -> "bool" : return _core.StrVector_empty(self)
    def size(self) -> "std::vector< std::string >::size_type" : return _core.StrVector_size(self)
    def clear(self) -> "void" : return _core.StrVector_clear(self)
    def swap(self, *args) -> "void" : return _core.StrVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< std::string >::allocator_type" : return _core.StrVector_get_allocator(self)
    def begin(self) -> "std::vector< std::string >::iterator" : return _core.StrVector_begin(self)
    def end(self) -> "std::vector< std::string >::iterator" : return _core.StrVector_end(self)
    def rbegin(self) -> "std::vector< std::string >::reverse_iterator" : return _core.StrVector_rbegin(self)
    def rend(self) -> "std::vector< std::string >::reverse_iterator" : return _core.StrVector_rend(self)
    def pop_back(self) -> "void" : return _core.StrVector_pop_back(self)
    def erase(self, *args) -> "std::vector< std::string >::iterator" : return _core.StrVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_StrVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.StrVector_push_back(self, *args)
    def front(self) -> "std::vector< std::string >::value_type const &" : return _core.StrVector_front(self)
    def back(self) -> "std::vector< std::string >::value_type const &" : return _core.StrVector_back(self)
    def assign(self, *args) -> "void" : return _core.StrVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.StrVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.StrVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.StrVector_reserve(self, *args)
    def capacity(self) -> "std::vector< std::string >::size_type" : return _core.StrVector_capacity(self)
    __swig_destroy__ = _core.delete_StrVector
    __del__ = lambda self : None;
StrVector_swigregister = _core.StrVector_swigregister
StrVector_swigregister(StrVector)

class IntStringDict(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.IntStringDict_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.IntStringDict___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.IntStringDict___bool__(self)
    def __len__(self) -> "std::map< long long,std::string >::size_type" : return _core.IntStringDict___len__(self)
    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args) -> "std::map< long long,std::string >::mapped_type const &" : return _core.IntStringDict___getitem__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.IntStringDict___delitem__(self, *args)
    def has_key(self, *args) -> "bool" : return _core.IntStringDict_has_key(self, *args)
    def keys(self) -> "PyObject *" : return _core.IntStringDict_keys(self)
    def values(self) -> "PyObject *" : return _core.IntStringDict_values(self)
    def items(self) -> "PyObject *" : return _core.IntStringDict_items(self)
    def __contains__(self, *args) -> "bool" : return _core.IntStringDict___contains__(self, *args)
    def key_iterator(self) -> "swig::SwigPyIterator *" : return _core.IntStringDict_key_iterator(self)
    def value_iterator(self) -> "swig::SwigPyIterator *" : return _core.IntStringDict_value_iterator(self)
    def __setitem__(self, *args) -> "void" : return _core.IntStringDict___setitem__(self, *args)
    def asdict(self) -> "PyObject *" : return _core.IntStringDict_asdict(self)
    def __init__(self, *args): 
        this = _core.new_IntStringDict(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self) -> "bool" : return _core.IntStringDict_empty(self)
    def size(self) -> "std::map< long long,std::string >::size_type" : return _core.IntStringDict_size(self)
    def clear(self) -> "void" : return _core.IntStringDict_clear(self)
    def swap(self, *args) -> "void" : return _core.IntStringDict_swap(self, *args)
    def get_allocator(self) -> "std::map< long long,std::string >::allocator_type" : return _core.IntStringDict_get_allocator(self)
    def begin(self) -> "std::map< long long,std::string >::iterator" : return _core.IntStringDict_begin(self)
    def end(self) -> "std::map< long long,std::string >::iterator" : return _core.IntStringDict_end(self)
    def rbegin(self) -> "std::map< long long,std::string >::reverse_iterator" : return _core.IntStringDict_rbegin(self)
    def rend(self) -> "std::map< long long,std::string >::reverse_iterator" : return _core.IntStringDict_rend(self)
    def count(self, *args) -> "std::map< long long,std::string >::size_type" : return _core.IntStringDict_count(self, *args)
    def erase(self, *args) -> "void" : return _core.IntStringDict_erase(self, *args)
    def find(self, *args) -> "std::map< long long,std::string >::iterator" : return _core.IntStringDict_find(self, *args)
    def lower_bound(self, *args) -> "std::map< long long,std::string >::iterator" : return _core.IntStringDict_lower_bound(self, *args)
    def upper_bound(self, *args) -> "std::map< long long,std::string >::iterator" : return _core.IntStringDict_upper_bound(self, *args)
    def __reduce__(self):
    	args = (dict(self), )
    	return self.__class__, args

    __swig_destroy__ = _core.delete_IntStringDict
    __del__ = lambda self : None;
IntStringDict_swigregister = _core.IntStringDict_swigregister
IntStringDict_swigregister(IntStringDict)


def set_linalg(*args) -> "void" :
  return _core.set_linalg(*args)
set_linalg = _core.set_linalg

def _swigtest_empty_dict() -> "PyObject *" :
  return _core._swigtest_empty_dict()
_swigtest_empty_dict = _core._swigtest_empty_dict

def _swigtest_alpha_dict() -> "PyObject *" :
  return _core._swigtest_alpha_dict()
_swigtest_alpha_dict = _core._swigtest_alpha_dict
class ostream_c(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args): 
        this = _core.new_ostream_c(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_ostream_c
    __del__ = lambda self : None;
    def flush(self) -> "void" : return _core.ostream_c_flush(self)
    def write(self, *args) -> "int" : return _core.ostream_c_write(self, *args)
    def mode(self) -> "std::string" : return _core.ostream_c_mode(self)
    def __repr__(self) -> "std::string" : return _core.ostream_c___repr__(self)
ostream_c_swigregister = _core.ostream_c_swigregister
ostream_c_swigregister(ostream_c)

class string_sender(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def write(self, *args) -> "void" : return _core.string_sender_write(self, *args)
    __swig_destroy__ = _core.delete_string_sender
    __del__ = lambda self : None;
string_sender_swigregister = _core.string_sender_swigregister
string_sender_swigregister(string_sender)

class refcounted(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self): 
        this = _core.new_refcounted()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_refcounted
    __del__ = lambda self : None;
    def incref(self) -> "int" : return _core.refcounted_incref(self)
    def decref(self) -> "int" : return _core.refcounted_decref(self)
    def ref_count(self) -> "int" : return _core.refcounted_ref_count(self)
    def lifeboat(self) -> "void" : return _core.refcounted_lifeboat(self)
refcounted_swigregister = _core.refcounted_swigregister
refcounted_swigregister(refcounted)


def larch_initialize() -> "void" :
  return _core.larch_initialize()
larch_initialize = _core.larch_initialize

def larch_openblas_get_config() -> "char *" :
  return _core.larch_openblas_get_config()
larch_openblas_get_config = _core.larch_openblas_get_config
class OptimizationMethodList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.OptimizationMethodList_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.OptimizationMethodList___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.OptimizationMethodList___bool__(self)
    def __len__(self) -> "std::vector< sherpa_pack >::size_type" : return _core.OptimizationMethodList___len__(self)
    def pop(self) -> "std::vector< sherpa_pack >::value_type" : return _core.OptimizationMethodList_pop(self)
    def __getslice__(self, *args) -> "std::vector< sherpa_pack,std::allocator< sherpa_pack > > *" : return _core.OptimizationMethodList___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.OptimizationMethodList___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.OptimizationMethodList___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.OptimizationMethodList___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< sherpa_pack >::value_type const &" : return _core.OptimizationMethodList___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.OptimizationMethodList___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.OptimizationMethodList_append(self, *args)
    def empty(self) -> "bool" : return _core.OptimizationMethodList_empty(self)
    def size(self) -> "std::vector< sherpa_pack >::size_type" : return _core.OptimizationMethodList_size(self)
    def clear(self) -> "void" : return _core.OptimizationMethodList_clear(self)
    def swap(self, *args) -> "void" : return _core.OptimizationMethodList_swap(self, *args)
    def get_allocator(self) -> "std::vector< sherpa_pack >::allocator_type" : return _core.OptimizationMethodList_get_allocator(self)
    def begin(self) -> "std::vector< sherpa_pack >::iterator" : return _core.OptimizationMethodList_begin(self)
    def end(self) -> "std::vector< sherpa_pack >::iterator" : return _core.OptimizationMethodList_end(self)
    def rbegin(self) -> "std::vector< sherpa_pack >::reverse_iterator" : return _core.OptimizationMethodList_rbegin(self)
    def rend(self) -> "std::vector< sherpa_pack >::reverse_iterator" : return _core.OptimizationMethodList_rend(self)
    def pop_back(self) -> "void" : return _core.OptimizationMethodList_pop_back(self)
    def erase(self, *args) -> "std::vector< sherpa_pack >::iterator" : return _core.OptimizationMethodList_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_OptimizationMethodList(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.OptimizationMethodList_push_back(self, *args)
    def front(self) -> "std::vector< sherpa_pack >::value_type const &" : return _core.OptimizationMethodList_front(self)
    def back(self) -> "std::vector< sherpa_pack >::value_type const &" : return _core.OptimizationMethodList_back(self)
    def assign(self, *args) -> "void" : return _core.OptimizationMethodList_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.OptimizationMethodList_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.OptimizationMethodList_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.OptimizationMethodList_reserve(self, *args)
    def capacity(self) -> "std::vector< sherpa_pack >::size_type" : return _core.OptimizationMethodList_capacity(self)
    __swig_destroy__ = _core.delete_OptimizationMethodList
    __del__ = lambda self : None;
OptimizationMethodList_swigregister = _core.OptimizationMethodList_swigregister
OptimizationMethodList_swigregister(OptimizationMethodList)

class OptimizationMethod(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): 
        this = _core.new_OptimizationMethod(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_OptimizationMethod
    __del__ = lambda self : None;
    Min_Step = _swig_property(_core.OptimizationMethod_Min_Step_get, _core.OptimizationMethod_Min_Step_set)
    Max_Step = _swig_property(_core.OptimizationMethod_Max_Step_get, _core.OptimizationMethod_Max_Step_set)
    Step_Extend_Factor = _swig_property(_core.OptimizationMethod_Step_Extend_Factor_get, _core.OptimizationMethod_Step_Extend_Factor_set)
    Step_Retract_Factor = _swig_property(_core.OptimizationMethod_Step_Retract_Factor_get, _core.OptimizationMethod_Step_Retract_Factor_set)
    Initial_Step = _swig_property(_core.OptimizationMethod_Initial_Step_get, _core.OptimizationMethod_Initial_Step_set)
    Honeymoon = _swig_property(_core.OptimizationMethod_Honeymoon_get, _core.OptimizationMethod_Honeymoon_set)
    Patience = _swig_property(_core.OptimizationMethod_Patience_get, _core.OptimizationMethod_Patience_set)
    Max_NumIter = _swig_property(_core.OptimizationMethod_Max_NumIter_get, _core.OptimizationMethod_Max_NumIter_set)
    Min_NumIter = _swig_property(_core.OptimizationMethod_Min_NumIter_get, _core.OptimizationMethod_Min_NumIter_set)
    Algorithm = _swig_property(_core.OptimizationMethod_Algorithm_get, _core.OptimizationMethod_Algorithm_set)
    Fail = _swig_property(_core.OptimizationMethod_Fail_get, _core.OptimizationMethod_Fail_set)
    Slowness = _swig_property(_core.OptimizationMethod_Slowness_get, _core.OptimizationMethod_Slowness_set)
    def get_step(self) -> "double" : return _core.OptimizationMethod_get_step(self)
    def tell_step(self, *args) -> "void" : return _core.OptimizationMethod_tell_step(self, *args)
    def tell_turn(self, *args) -> "bool" : return _core.OptimizationMethod_tell_turn(self, *args)
    def print_pack(self) -> "std::string" : return _core.OptimizationMethod_print_pack(self)
    def AlgorithmName(self) -> "std::string" : return _core.OptimizationMethod_AlgorithmName(self)
    def __repr__(self) -> "std::string" : return _core.OptimizationMethod___repr__(self)
OptimizationMethod_swigregister = _core.OptimizationMethod_swigregister
OptimizationMethod_swigregister(OptimizationMethod)


def default_optimization_recipe() -> "std::vector< sherpa_pack,std::allocator< sherpa_pack > >" :
  return _core.default_optimization_recipe()
default_optimization_recipe = _core.default_optimization_recipe

def bfgs_optimization_recipe() -> "std::vector< sherpa_pack,std::allocator< sherpa_pack > >" :
  return _core.bfgs_optimization_recipe()
bfgs_optimization_recipe = _core.bfgs_optimization_recipe

def _set_array_module(*args) -> "void" :
  return _core._set_array_module(*args)
_set_array_module = _core._set_array_module
class three_dim(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def size1(self) -> "unsigned int const &" : return _core.three_dim_size1(self)
    def size2(self) -> "unsigned int const &" : return _core.three_dim_size2(self)
    def size3(self) -> "unsigned int const &" : return _core.three_dim_size3(self)
    def __init__(self, *args): 
        this = _core.new_three_dim(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_three_dim
    __del__ = lambda self : None;
three_dim_swigregister = _core.three_dim_swigregister
three_dim_swigregister(three_dim)


def ndarray_make() -> "etk::ndarray *" :
  return _core.ndarray_make()
ndarray_make = _core.ndarray_make

def ndarray_exp(*args) -> "void" :
  return _core.ndarray_exp(*args)
ndarray_exp = _core.ndarray_exp

def ndarray_log(*args) -> "void" :
  return _core.ndarray_log(*args)
ndarray_log = _core.ndarray_log

def ndarray_init(*args) -> "void" :
  return _core.ndarray_init(*args)
ndarray_init = _core.ndarray_init

def SymmetricArray_use_upper_triangle(*args) -> "void" :
  return _core.SymmetricArray_use_upper_triangle(*args)
SymmetricArray_use_upper_triangle = _core.SymmetricArray_use_upper_triangle
from .array import Array
from .array import SymmetricArray


class Fountain(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def ask_dna(self, *args) -> "elm::VAS_dna const" : return _core.Fountain_ask_dna(self, *args)
    def nCases(self) -> "unsigned int const &" : return _core.Fountain_nCases(self)
    def nAlts(self) -> "unsigned int const &" : return _core.Fountain_nAlts(self)
    def __init__(self): 
        this = _core.new_Fountain()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_Fountain
    __del__ = lambda self : None;
Fountain_swigregister = _core.Fountain_swigregister
Fountain_swigregister(Fountain)

class QuerySet(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def qry_idco(self) -> "std::string" : return _core.QuerySet_qry_idco(self)
    def qry_idco_(self) -> "std::string" : return _core.QuerySet_qry_idco_(self)
    def qry_idca(self) -> "std::string" : return _core.QuerySet_qry_idca(self)
    def qry_idca_(self) -> "std::string" : return _core.QuerySet_qry_idca_(self)
    def qry_alts(self) -> "std::string" : return _core.QuerySet_qry_alts(self)
    def qry_caseids(self) -> "std::string" : return _core.QuerySet_qry_caseids(self)
    def qry_choice(self) -> "std::string" : return _core.QuerySet_qry_choice(self)
    def qry_weight(self) -> "std::string" : return _core.QuerySet_qry_weight(self)
    def qry_avail(self) -> "std::string" : return _core.QuerySet_qry_avail(self)
    def tbl_idco(self) -> "std::string" : return _core.QuerySet_tbl_idco(self)
    def tbl_idca(self) -> "std::string" : return _core.QuerySet_tbl_idca(self)
    def tbl_alts(self) -> "std::string" : return _core.QuerySet_tbl_alts(self)
    def tbl_caseids(self) -> "std::string" : return _core.QuerySet_tbl_caseids(self)
    def tbl_choice(self) -> "std::string" : return _core.QuerySet_tbl_choice(self)
    def tbl_weight(self) -> "std::string" : return _core.QuerySet_tbl_weight(self)
    def tbl_avail(self) -> "std::string" : return _core.QuerySet_tbl_avail(self)
    def unweighted(self) -> "bool" : return _core.QuerySet_unweighted(self)
    def all_alts_always_available(self) -> "bool" : return _core.QuerySet_all_alts_always_available(self)
    __swig_destroy__ = _core.delete_QuerySet
    __del__ = lambda self : None;
    def __init__(self, validator : 'Facet'=None): 
        this = _core.new_QuerySet(validator)
        try: self.this.append(this)
        except: self.this = this
    def set_validator(self, *args) -> "void" : return _core.QuerySet_set_validator(self, *args)
    def __repr__(self) -> "std::string" : return _core.QuerySet___repr__(self)
    def actual_type(self) -> "std::string" : return _core.QuerySet_actual_type(self)
    def pickled(self) -> "PyObject *" : return _core.QuerySet_pickled(self)
    def __getstate__(self):
    	args = {}
    	for i in dir(self):
    		if len(i)>4 and i[:4]=='get_':
    			args['set_'+i[4:]] = getattr(self,i)()
    	return args
    def __setstate__(self, state):
    	self.__init__()
    	for key, value in state.items():
    		getattr(self,key)(value)

QuerySet_swigregister = _core.QuerySet_swigregister
QuerySet_swigregister(QuerySet)

class QuerySetSimpleCO(QuerySet):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def qry_idco(self) -> "std::string" : return _core.QuerySetSimpleCO_qry_idco(self)
    def qry_idco_(self) -> "std::string" : return _core.QuerySetSimpleCO_qry_idco_(self)
    def qry_idca(self) -> "std::string" : return _core.QuerySetSimpleCO_qry_idca(self)
    def qry_idca_(self) -> "std::string" : return _core.QuerySetSimpleCO_qry_idca_(self)
    def qry_alts(self) -> "std::string" : return _core.QuerySetSimpleCO_qry_alts(self)
    def qry_caseids(self) -> "std::string" : return _core.QuerySetSimpleCO_qry_caseids(self)
    def qry_choice(self) -> "std::string" : return _core.QuerySetSimpleCO_qry_choice(self)
    def qry_weight(self) -> "std::string" : return _core.QuerySetSimpleCO_qry_weight(self)
    def qry_avail(self) -> "std::string" : return _core.QuerySetSimpleCO_qry_avail(self)
    def unweighted(self) -> "bool" : return _core.QuerySetSimpleCO_unweighted(self)
    def all_alts_always_available(self) -> "bool" : return _core.QuerySetSimpleCO_all_alts_always_available(self)
    __swig_destroy__ = _core.delete_QuerySetSimpleCO
    __del__ = lambda self : None;
    def __repr__(self) -> "std::string" : return _core.QuerySetSimpleCO___repr__(self)
    def actual_type(self) -> "std::string" : return _core.QuerySetSimpleCO_actual_type(self)
    def __init__(self, validator : 'Facet'=None): 
        this = _core.new_QuerySetSimpleCO(validator)
        try: self.this.append(this)
        except: self.this = this
    def set_validator(self, validator : 'Facet'=None) -> "void" : return _core.QuerySetSimpleCO_set_validator(self, validator)
    def set_idco_query(self, *args) -> "void" : return _core.QuerySetSimpleCO_set_idco_query(self, *args)
    def set_choice_column(self, *args) -> "void" : return _core.QuerySetSimpleCO_set_choice_column(self, *args)
    def set_choice_column_map(self, *args) -> "void" : return _core.QuerySetSimpleCO_set_choice_column_map(self, *args)
    def set_avail_column_map(self, *args) -> "void" : return _core.QuerySetSimpleCO_set_avail_column_map(self, *args)
    def set_avail_all(self) -> "void" : return _core.QuerySetSimpleCO_set_avail_all(self)
    def set_weight_column(self, *args) -> "void" : return _core.QuerySetSimpleCO_set_weight_column(self, *args)
    def set_alts_query(self, *args) -> "void" : return _core.QuerySetSimpleCO_set_alts_query(self, *args)
    def set_alts_values(self, *args) -> "void" : return _core.QuerySetSimpleCO_set_alts_values(self, *args)
    def get_idco_query(self) -> "std::string" : return _core.QuerySetSimpleCO_get_idco_query(self)
    def get_choice_column(self) -> "std::string" : return _core.QuerySetSimpleCO_get_choice_column(self)
    def get_choice_column_map(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >" : return _core.QuerySetSimpleCO_get_choice_column_map(self)
    def get_avail_column_map(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >" : return _core.QuerySetSimpleCO_get_avail_column_map(self)
    def get_weight_column(self) -> "std::string" : return _core.QuerySetSimpleCO_get_weight_column(self)
    def get_alts_query(self) -> "std::string" : return _core.QuerySetSimpleCO_get_alts_query(self)
QuerySetSimpleCO_swigregister = _core.QuerySetSimpleCO_swigregister
QuerySetSimpleCO_swigregister(QuerySetSimpleCO)

from . import QuerySetSimpleCO as _morefuncs
del _morefuncs

class QuerySetTwoTable(QuerySet):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def qry_idco(self) -> "std::string" : return _core.QuerySetTwoTable_qry_idco(self)
    def qry_idco_(self) -> "std::string" : return _core.QuerySetTwoTable_qry_idco_(self)
    def qry_idca(self) -> "std::string" : return _core.QuerySetTwoTable_qry_idca(self)
    def qry_idca_(self) -> "std::string" : return _core.QuerySetTwoTable_qry_idca_(self)
    def qry_alts(self) -> "std::string" : return _core.QuerySetTwoTable_qry_alts(self)
    def qry_caseids(self) -> "std::string" : return _core.QuerySetTwoTable_qry_caseids(self)
    def qry_choice(self) -> "std::string" : return _core.QuerySetTwoTable_qry_choice(self)
    def qry_weight(self) -> "std::string" : return _core.QuerySetTwoTable_qry_weight(self)
    def qry_avail(self) -> "std::string" : return _core.QuerySetTwoTable_qry_avail(self)
    def unweighted(self) -> "bool" : return _core.QuerySetTwoTable_unweighted(self)
    def all_alts_always_available(self) -> "bool" : return _core.QuerySetTwoTable_all_alts_always_available(self)
    __swig_destroy__ = _core.delete_QuerySetTwoTable
    __del__ = lambda self : None;
    def __repr__(self) -> "std::string" : return _core.QuerySetTwoTable___repr__(self)
    def actual_type(self) -> "std::string" : return _core.QuerySetTwoTable_actual_type(self)
    def pickled(self) -> "PyObject *" : return _core.QuerySetTwoTable_pickled(self)
    def __init__(self, validator : 'Facet'=None): 
        this = _core.new_QuerySetTwoTable(validator)
        try: self.this.append(this)
        except: self.this = this
    def set_validator(self, validator : 'Facet'=None) -> "void" : return _core.QuerySetTwoTable_set_validator(self, validator)
    def set_idco_query(self, *args) -> "void" : return _core.QuerySetTwoTable_set_idco_query(self, *args)
    def set_idca_query(self, *args) -> "void" : return _core.QuerySetTwoTable_set_idca_query(self, *args)
    def set_choice_co_column(self, *args) -> "void" : return _core.QuerySetTwoTable_set_choice_co_column(self, *args)
    def set_choice_co_column_map(self, *args) -> "void" : return _core.QuerySetTwoTable_set_choice_co_column_map(self, *args)
    def set_choice_ca_column(self, *args) -> "void" : return _core.QuerySetTwoTable_set_choice_ca_column(self, *args)
    def set_avail_co_column_map(self, *args) -> "void" : return _core.QuerySetTwoTable_set_avail_co_column_map(self, *args)
    def set_avail_ca_column(self, *args) -> "void" : return _core.QuerySetTwoTable_set_avail_ca_column(self, *args)
    def set_avail_all(self) -> "void" : return _core.QuerySetTwoTable_set_avail_all(self)
    def set_weight_co_column(self, *args) -> "void" : return _core.QuerySetTwoTable_set_weight_co_column(self, *args)
    def set_alts_query(self, *args) -> "void" : return _core.QuerySetTwoTable_set_alts_query(self, *args)
    def set_alts_values(self, *args) -> "void" : return _core.QuerySetTwoTable_set_alts_values(self, *args)
    def get_idco_query(self) -> "std::string" : return _core.QuerySetTwoTable_get_idco_query(self)
    def get_idca_query(self) -> "std::string" : return _core.QuerySetTwoTable_get_idca_query(self)
    def get_choice_co_column(self) -> "std::string" : return _core.QuerySetTwoTable_get_choice_co_column(self)
    def get_choice_co_column_map(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >" : return _core.QuerySetTwoTable_get_choice_co_column_map(self)
    def get_choice_ca_column(self) -> "std::string" : return _core.QuerySetTwoTable_get_choice_ca_column(self)
    def get_avail_co_column_map(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >" : return _core.QuerySetTwoTable_get_avail_co_column_map(self)
    def get_avail_ca_column(self) -> "std::string" : return _core.QuerySetTwoTable_get_avail_ca_column(self)
    def get_weight_co_column(self) -> "std::string" : return _core.QuerySetTwoTable_get_weight_co_column(self)
    def get_alts_query(self) -> "std::string" : return _core.QuerySetTwoTable_get_alts_query(self)
QuerySetTwoTable_swigregister = _core.QuerySetTwoTable_swigregister
QuerySetTwoTable_swigregister(QuerySetTwoTable)

from . import QuerySetTwoTable as _morefuncs
del _morefuncs

class SQLiteDB(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _core.new_SQLiteDB(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_SQLiteDB
    __del__ = lambda self : None;
    def close(self) -> "void" : return _core.SQLiteDB_close(self)
    def copy_from_db(self, *args) -> "void" : return _core.SQLiteDB_copy_from_db(self, *args)
    def backup(self, *args) -> "void" :
        """
        Save the current SQLite database to another DB. 

        :param filename: The URI for where to save the DB.
        """
        return _core.SQLiteDB_backup(self, *args)

    def commit(self, raise_on_fail : 'int'=1) -> "void" :
        """
        Commit to SQLite database. 

        :param raise_on_fail: Raise an exception if the commit fails for any reason.
        """
        return _core.SQLiteDB_commit(self, raise_on_fail)

    def drop(self, *args) -> "void" : return _core.SQLiteDB_drop(self, *args)
    def all_table_names(self) -> "std::vector< std::string,std::allocator< std::string > >" :
        """
        A list of all table names in the SQL database, including both data tables and
        administrative tables
        """
        return _core.SQLiteDB_all_table_names(self)

    def column_names(self, *args) -> "std::vector< std::string,std::allocator< std::string > >" : return _core.SQLiteDB_column_names(self, *args)
    def column_name(self, *args) -> "std::string" : return _core.SQLiteDB_column_name(self, *args)
    def logger(self, log : 'PyObject *'=None) -> "PyObject *" :
        """
        The SQLiteDB object contains a link to the standard python logging service. By default,
        no logger is connected. Use this function to assign a logger, and then use the usual
        python logging controls to set the quantity/destination of output. To stop logging,
        call this function without any arguments.
        """
        return _core.SQLiteDB_logger(self, log)

    def error_code(self) -> "int" : return _core.SQLiteDB_error_code(self)
    def error_msg(self) -> "std::string" : return _core.SQLiteDB_error_msg(self)
    def eval_integer(self, *args) -> "int" :
        """
        Evaluate a SQL statement that should return a single text string. 

        :param sql: The SQL statement to evaluate.
        :param default_value: A default value to return if the statement does not return a single value.
        """
        return _core.SQLiteDB_eval_integer(self, *args)

    def eval_int64(self, *args) -> "long long" : return _core.SQLiteDB_eval_int64(self, *args)
    def eval_float(self, *args) -> "double" :
        """
        Evaluate a SQL statement that should return a single double precision floating point number. 

        :param sql: The SQL statement to evaluate.
        :param default_value: A default value to return if the statement does not return a single value.
        """
        return _core.SQLiteDB_eval_float(self, *args)

    def eval_text(self, *args) -> "std::string" : return _core.SQLiteDB_eval_text(self, *args)
    def eval_int64_tuple(self, *args) -> "std::vector< long long,std::allocator< long long > >" : return _core.SQLiteDB_eval_int64_tuple(self, *args)
    def eval_string_tuple(self, *args) -> "std::vector< std::string,std::allocator< std::string > >" : return _core.SQLiteDB_eval_string_tuple(self, *args)
    def __str__(self):
    	return "<SQLiteDB: %s>"%self.working_name
    def __repr__(self):
    	return "<SQLiteDB: %s>"%self.working_name
    exec_integer = eval_integer
    exec_float   = eval_float
    exec_text    = eval_text
    def Shell(self):
    	'''Enter an SQLite shell for accessing the contents of the database object.
    	
    	The shell is based on the usual SQLite3 command shell, and is not a Python
    	interpreted environment. Use Ctrl-C (Windows) or Ctrl-D (Mac OS X) to escape
    	back to the usual Python environment.'''
    	from . import apsw
    	apsw.Shell(db=self).cmdloop()

SQLiteDB_swigregister = _core.SQLiteDB_swigregister
SQLiteDB_swigregister(SQLiteDB)

class Facet(SQLiteDB,Fountain):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def ask_dna(self, c : 'long long const &'=0) -> "elm::VAS_dna" : return _core.Facet_ask_dna(self, c)
    __swig_destroy__ = _core.delete_Facet
    __del__ = lambda self : None;
    window_title = _swig_property(_core.Facet_window_title_get, _core.Facet_window_title_set)
    source_filename = _swig_property(_core.Facet_source_filename_get, _core.Facet_source_filename_set)
    working_name = _swig_property(_core.Facet_working_name_get, _core.Facet_working_name_set)
    active_facet = _swig_property(_core.Facet_active_facet_get, _core.Facet_active_facet_set)
    def _get_queries(self) -> "PyObject *" : return _core.Facet__get_queries(self)
    def _set_queries(self, *args) -> "void" : return _core.Facet__set_queries(self, *args)
    def refresh_queries(self) -> "void" : return _core.Facet_refresh_queries(self)
    def __init__(self, *args): 
        this = _core.new_Facet(*args)
        try: self.this.append(this)
        except: self.this = this
    def save_facet(self, *args) -> "void" : return _core.Facet_save_facet(self, *args)
    def load_facet(self, name : 'std::string'="") -> "void" : return _core.Facet_load_facet(self, name)
    def clear_facet(self) -> "void" : return _core.Facet_clear_facet(self)
    def list_facets(self) -> "std::vector< std::string,std::allocator< std::string > >" : return _core.Facet_list_facets(self)
    def nCases(self) -> "unsigned int const &" : return _core.Facet_nCases(self)
    def nAlts(self) -> "unsigned int const &" : return _core.Facet_nAlts(self)
    def caseids(self, firstcasenum : 'unsigned int const &'=0, numberofcases : 'unsigned int const &'=0, 
    no_error_checking : 'int'=0) -> "std::vector< long long,std::allocator< long long > >" : return _core.Facet_caseids(self, firstcasenum, numberofcases, no_error_checking)
    def altids(self) -> "std::vector< long long,std::allocator< long long > >" : return _core.Facet_altids(self)
    def alternative_names(self) -> "std::vector< std::string,std::allocator< std::string > >" : return _core.Facet_alternative_names(self)
    def alternative_codes(self) -> "std::vector< long long,std::allocator< long long > >" : return _core.Facet_alternative_codes(self)
    def alternative_name(self, *args) -> "std::string" : return _core.Facet_alternative_name(self, *args)
    def alternative_code(self, *args) -> "long long" : return _core.Facet_alternative_code(self, *args)
    def check_ca(self, *args) -> "bool" : return _core.Facet_check_ca(self, *args)
    def check_co(self, *args) -> "bool" : return _core.Facet_check_co(self, *args)
    def variables_ca(self) -> "std::vector< std::string,std::allocator< std::string > >" : return _core.Facet_variables_ca(self)
    def variables_co(self) -> "std::vector< std::string,std::allocator< std::string > >" : return _core.Facet_variables_co(self)
    def query_idca(self, *args) -> "std::string" : return _core.Facet_query_idca(self, *args)
    def query_idco(self, *args) -> "std::string" : return _core.Facet_query_idco(self, *args)
    def query_alts(self, *args) -> "std::string" : return _core.Facet_query_alts(self, *args)
    def query_choice(self, caseid : 'long long *'=None) -> "std::string" : return _core.Facet_query_choice(self, caseid)
    def query_avail(self, caseid : 'long long *'=None) -> "std::string" : return _core.Facet_query_avail(self, caseid)
    def query_weight(self, caseid : 'long long *'=None) -> "std::string" : return _core.Facet_query_weight(self, caseid)
    def qry_idca(self) -> "std::string" : return _core.Facet_qry_idca(self)
    def qry_idco(self) -> "std::string" : return _core.Facet_qry_idco(self)
    def qry_idca_(self) -> "std::string" : return _core.Facet_qry_idca_(self)
    def qry_idco_(self) -> "std::string" : return _core.Facet_qry_idco_(self)
    def qry_alts(self) -> "std::string" : return _core.Facet_qry_alts(self)
    def qry_choice(self) -> "std::string" : return _core.Facet_qry_choice(self)
    def qry_avail(self) -> "std::string" : return _core.Facet_qry_avail(self)
    def qry_weight(self) -> "std::string" : return _core.Facet_qry_weight(self)
    def qry_caseids(self) -> "std::string" : return _core.Facet_qry_caseids(self)
    def tbl_idca(self) -> "std::string" : return _core.Facet_tbl_idca(self)
    def tbl_idco(self) -> "std::string" : return _core.Facet_tbl_idco(self)
    def tbl_alts(self) -> "std::string" : return _core.Facet_tbl_alts(self)
    def tbl_choice(self) -> "std::string" : return _core.Facet_tbl_choice(self)
    def tbl_avail(self) -> "std::string" : return _core.Facet_tbl_avail(self)
    def tbl_weight(self) -> "std::string" : return _core.Facet_tbl_weight(self)
    def tbl_caseids(self) -> "std::string" : return _core.Facet_tbl_caseids(self)
    def unweighted(self) -> "bool" : return _core.Facet_unweighted(self)
    def all_alts_always_available(self) -> "bool" : return _core.Facet_all_alts_always_available(self)
    def _array_idco_reader(self, *args) -> "void" : return _core.Facet__array_idco_reader(self, *args)
    def _array_idca_reader(self, *args) -> "void" : return _core.Facet__array_idca_reader(self, *args)
    def sql(self):
    	print("sql_idco:   %s"%(self.sql_idco   if self.sql_idco   else "<blank>"))
    	print("sql_idca:   %s"%(self.sql_idca   if self.sql_idca   else "<blank>"))
    	print("sql_alts:   %s"%(self.sql_alts   if self.sql_alts   else "<blank>"))
    	print("sql_choice: %s"%(self.sql_choice if self.sql_choice else "<blank>"))
    	print("sql_avail:  %s"%(self.sql_avail  if self.sql_avail  else "<blank>"))
    	print("sql_weight: %s"%(self.sql_weight if self.sql_weight else "<blank>"))

Facet_swigregister = _core.Facet_swigregister
Facet_swigregister(Facet)

from .db import DB

ELM_IGNORED = _core.ELM_IGNORED
ELM_UPDATED = _core.ELM_UPDATED
ELM_INITIALIZED = _core.ELM_INITIALIZED
ELM_CREATED = _core.ELM_CREATED
ELM_FAILED = _core.ELM_FAILED
class ParameterLinkArray(three_dim):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self): 
        this = _core.new_ParameterLinkArray()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_ParameterLinkArray
    __del__ = lambda self : None;
    def __str__(self) -> "std::string" : return _core.ParameterLinkArray___str__(self)
    def __repr__(self) -> "std::string" : return _core.ParameterLinkArray___repr__(self)
    def pull(self, *args) -> "void" : return _core.ParameterLinkArray_pull(self, *args)
    def push(self, *args) -> "void" : return _core.ParameterLinkArray_push(self, *args)
    def pull_field(self, *args) -> "void" : return _core.ParameterLinkArray_pull_field(self, *args)
    def push_field(self, *args) -> "void" : return _core.ParameterLinkArray_push_field(self, *args)
ParameterLinkArray_swigregister = _core.ParameterLinkArray_swigregister
ParameterLinkArray_swigregister(ParameterLinkArray)

class cellcodeset_iterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self) -> "elm::cellcodeset_iterator" : return _core.cellcodeset_iterator___iter__(self)
    def next(self) -> "elm::cellcode" : return _core.cellcodeset_iterator_next(self)
    def __next__(self) -> "elm::cellcode" : return _core.cellcodeset_iterator___next__(self)
    def __init__(self, *args): 
        this = _core.new_cellcodeset_iterator(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_cellcodeset_iterator
    __del__ = lambda self : None;
cellcodeset_iterator_swigregister = _core.cellcodeset_iterator_swigregister
cellcodeset_iterator_swigregister(cellcodeset_iterator)

class cellcodeset(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args): 
        this = _core.new_cellcodeset(*args)
        try: self.this.append(this)
        except: self.this = this
    def contains(self, *args) -> "bool" : return _core.cellcodeset_contains(self, *args)
    def insert_set(self, *args) -> "void" : return _core.cellcodeset_insert_set(self, *args)
    def append(self, *args) -> "void" : return _core.cellcodeset_append(self, *args)
    def remove(self, *args) -> "bool" : return _core.cellcodeset_remove(self, *args)
    def noop(self) -> "void" : return _core.cellcodeset_noop(self)
    def __iadd__(self, *args) -> "elm::cellcodeset &" : return _core.cellcodeset___iadd__(self, *args)
    def __isub__(self, *args) -> "elm::cellcodeset &" : return _core.cellcodeset___isub__(self, *args)
    def __len__(self) -> "int" : return _core.cellcodeset___len__(self)
    def __repr__(self) -> "std::string" : return _core.cellcodeset___repr__(self)
    def __iter__(self) -> "elm::cellcodeset_iterator" : return _core.cellcodeset___iter__(self)
    __swig_destroy__ = _core.delete_cellcodeset
    __del__ = lambda self : None;
cellcodeset_swigregister = _core.cellcodeset_swigregister
cellcodeset_swigregister(cellcodeset)


def max_cellcode() -> "elm::cellcode" :
  return _core.max_cellcode()
max_cellcode = _core.max_cellcode
class string_and_cellcode(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    text = _swig_property(_core.string_and_cellcode_text_get, _core.string_and_cellcode_text_set)
    code = _swig_property(_core.string_and_cellcode_code_get, _core.string_and_cellcode_code_set)
    def __init__(self): 
        this = _core.new_string_and_cellcode()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_string_and_cellcode
    __del__ = lambda self : None;
string_and_cellcode_swigregister = _core.string_and_cellcode_swigregister
string_and_cellcode_swigregister(string_and_cellcode)

class cellcodepair(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    up = _swig_property(_core.cellcodepair_up_get, _core.cellcodepair_up_set)
    dn = _swig_property(_core.cellcodepair_dn_get, _core.cellcodepair_dn_set)
    def __init__(self, *args): 
        this = _core.new_cellcodepair(*args)
        try: self.this.append(this)
        except: self.this = this
    def __lt__(self, *args) -> "bool" : return _core.cellcodepair___lt__(self, *args)
    def __eq__(self, *args) -> "bool" : return _core.cellcodepair___eq__(self, *args)
    def __gt__(self, *args) -> "bool" : return _core.cellcodepair___gt__(self, *args)
    def __ge__(self, *args) -> "bool" : return _core.cellcodepair___ge__(self, *args)
    def __le__(self, *args) -> "bool" : return _core.cellcodepair___le__(self, *args)
    __swig_destroy__ = _core.delete_cellcodepair
    __del__ = lambda self : None;
cellcodepair_swigregister = _core.cellcodepair_swigregister
cellcodepair_swigregister(cellcodepair)

class cellcode_infodict(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.cellcode_infodict_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.cellcode_infodict___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.cellcode_infodict___bool__(self)
    def __len__(self) -> "std::map< long long,elm::VAS_dna_info >::size_type" : return _core.cellcode_infodict___len__(self)
    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args) -> "std::map< long long,elm::VAS_dna_info >::mapped_type const &" : return _core.cellcode_infodict___getitem__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.cellcode_infodict___delitem__(self, *args)
    def has_key(self, *args) -> "bool" : return _core.cellcode_infodict_has_key(self, *args)
    def keys(self) -> "PyObject *" : return _core.cellcode_infodict_keys(self)
    def values(self) -> "PyObject *" : return _core.cellcode_infodict_values(self)
    def items(self) -> "PyObject *" : return _core.cellcode_infodict_items(self)
    def __contains__(self, *args) -> "bool" : return _core.cellcode_infodict___contains__(self, *args)
    def key_iterator(self) -> "swig::SwigPyIterator *" : return _core.cellcode_infodict_key_iterator(self)
    def value_iterator(self) -> "swig::SwigPyIterator *" : return _core.cellcode_infodict_value_iterator(self)
    def __setitem__(self, *args) -> "void" : return _core.cellcode_infodict___setitem__(self, *args)
    def asdict(self) -> "PyObject *" : return _core.cellcode_infodict_asdict(self)
    def __init__(self, *args): 
        this = _core.new_cellcode_infodict(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self) -> "bool" : return _core.cellcode_infodict_empty(self)
    def size(self) -> "std::map< long long,elm::VAS_dna_info >::size_type" : return _core.cellcode_infodict_size(self)
    def clear(self) -> "void" : return _core.cellcode_infodict_clear(self)
    def swap(self, *args) -> "void" : return _core.cellcode_infodict_swap(self, *args)
    def get_allocator(self) -> "std::map< long long,elm::VAS_dna_info >::allocator_type" : return _core.cellcode_infodict_get_allocator(self)
    def begin(self) -> "std::map< long long,elm::VAS_dna_info >::iterator" : return _core.cellcode_infodict_begin(self)
    def end(self) -> "std::map< long long,elm::VAS_dna_info >::iterator" : return _core.cellcode_infodict_end(self)
    def rbegin(self) -> "std::map< long long,elm::VAS_dna_info >::reverse_iterator" : return _core.cellcode_infodict_rbegin(self)
    def rend(self) -> "std::map< long long,elm::VAS_dna_info >::reverse_iterator" : return _core.cellcode_infodict_rend(self)
    def count(self, *args) -> "std::map< long long,elm::VAS_dna_info >::size_type" : return _core.cellcode_infodict_count(self, *args)
    def erase(self, *args) -> "void" : return _core.cellcode_infodict_erase(self, *args)
    def find(self, *args) -> "std::map< long long,elm::VAS_dna_info >::iterator" : return _core.cellcode_infodict_find(self, *args)
    def lower_bound(self, *args) -> "std::map< long long,elm::VAS_dna_info >::iterator" : return _core.cellcode_infodict_lower_bound(self, *args)
    def upper_bound(self, *args) -> "std::map< long long,elm::VAS_dna_info >::iterator" : return _core.cellcode_infodict_upper_bound(self, *args)
    __swig_destroy__ = _core.delete_cellcode_infodict
    __del__ = lambda self : None;
cellcode_infodict_swigregister = _core.cellcode_infodict_swigregister
cellcode_infodict_swigregister(cellcode_infodict)

class cellcode_list(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.cellcode_list_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.cellcode_list___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.cellcode_list___bool__(self)
    def __len__(self) -> "std::list< long long >::size_type" : return _core.cellcode_list___len__(self)
    def pop(self) -> "std::list< long long >::value_type" : return _core.cellcode_list_pop(self)
    def __getslice__(self, *args) -> "std::list< long long,std::allocator< long long > > *" : return _core.cellcode_list___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.cellcode_list___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.cellcode_list___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.cellcode_list___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::list< long long >::value_type const &" : return _core.cellcode_list___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.cellcode_list___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.cellcode_list_append(self, *args)
    def empty(self) -> "bool" : return _core.cellcode_list_empty(self)
    def size(self) -> "std::list< long long >::size_type" : return _core.cellcode_list_size(self)
    def clear(self) -> "void" : return _core.cellcode_list_clear(self)
    def swap(self, *args) -> "void" : return _core.cellcode_list_swap(self, *args)
    def get_allocator(self) -> "std::list< long long >::allocator_type" : return _core.cellcode_list_get_allocator(self)
    def begin(self) -> "std::list< long long >::iterator" : return _core.cellcode_list_begin(self)
    def end(self) -> "std::list< long long >::iterator" : return _core.cellcode_list_end(self)
    def rbegin(self) -> "std::list< long long >::reverse_iterator" : return _core.cellcode_list_rbegin(self)
    def rend(self) -> "std::list< long long >::reverse_iterator" : return _core.cellcode_list_rend(self)
    def pop_back(self) -> "void" : return _core.cellcode_list_pop_back(self)
    def erase(self, *args) -> "std::list< long long >::iterator" : return _core.cellcode_list_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_cellcode_list(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.cellcode_list_push_back(self, *args)
    def front(self) -> "std::list< long long >::value_type const &" : return _core.cellcode_list_front(self)
    def back(self) -> "std::list< long long >::value_type const &" : return _core.cellcode_list_back(self)
    def assign(self, *args) -> "void" : return _core.cellcode_list_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.cellcode_list_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.cellcode_list_insert(self, *args)
    def pop_front(self) -> "void" : return _core.cellcode_list_pop_front(self)
    def push_front(self, *args) -> "void" : return _core.cellcode_list_push_front(self, *args)
    def reverse(self) -> "void" : return _core.cellcode_list_reverse(self)
    __swig_destroy__ = _core.delete_cellcode_list
    __del__ = lambda self : None;
cellcode_list_swigregister = _core.cellcode_list_swigregister
cellcode_list_swigregister(cellcode_list)

class VAS_dna_info(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    dns = _swig_property(_core.VAS_dna_info_dns_get, _core.VAS_dna_info_dns_set)
    name = _swig_property(_core.VAS_dna_info_name_get, _core.VAS_dna_info_name_set)
    is_branch = _swig_property(_core.VAS_dna_info_is_branch_get, _core.VAS_dna_info_is_branch_set)
    def __init__(self, input : 'std::string const &'=""): 
        this = _core.new_VAS_dna_info(input)
        try: self.this.append(this)
        except: self.this = this
    def is_elemental(self) -> "bool" : return _core.VAS_dna_info_is_elemental(self)
    __swig_destroy__ = _core.delete_VAS_dna_info
    __del__ = lambda self : None;
VAS_dna_info_swigregister = _core.VAS_dna_info_swigregister
VAS_dna_info_swigregister(VAS_dna_info)

class VAS_dna(cellcode_infodict):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def read_sequence(self, *args) -> "void" : return _core.VAS_dna_read_sequence(self, *args)
    def add_sequence(self, *args) -> "void" : return _core.VAS_dna_add_sequence(self, *args)
    def generate_sequence(self) -> "std::string" : return _core.VAS_dna_generate_sequence(self)
    def generate_phenotype(self) -> "std::string" : return _core.VAS_dna_generate_phenotype(self)
    def add_edge(self, *args) -> "std::string" : return _core.VAS_dna_add_edge(self, *args)
    def remove_edge(self, *args) -> "std::string" : return _core.VAS_dna_remove_edge(self, *args)
    def add_cell(self, *args) -> "int" : return _core.VAS_dna_add_cell(self, *args)
    def clear(self) -> "void" : return _core.VAS_dna_clear(self)
    def elemental_codes(self) -> "elm::cellcodeset" : return _core.VAS_dna_elemental_codes(self)
    def all_known_codes(self) -> "elm::cellcodeset" : return _core.VAS_dna_all_known_codes(self)
    def branches_in_ascending_order(self) -> "std::list< elm::cellcode,std::allocator< elm::cellcode > >" : return _core.VAS_dna_branches_in_ascending_order(self)
    def __init__(self): 
        this = _core.new_VAS_dna()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_VAS_dna
    __del__ = lambda self : None;
VAS_dna_swigregister = _core.VAS_dna_swigregister
VAS_dna_swigregister(VAS_dna)

class Component(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    data = _swig_property(_core.Component_data_get, _core.Component_data_set)
    param = _swig_property(_core.Component_param_get, _core.Component_param_set)
    altcode = _swig_property(_core.Component_altcode_get, _core.Component_altcode_set)
    altname = _swig_property(_core.Component_altname_get, _core.Component_altname_set)
    multiplier = _swig_property(_core.Component_multiplier_get, _core.Component_multiplier_set)
    def __repr__(self) -> "std::string" : return _core.Component___repr__(self)
    def __init__(self, *args, **kwargs): 
        this = _core.new_Component(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    Create = staticmethod(_core.Component_Create)
    def altcallsign(self):
    	return "%i: %s"%(self.altcode, self.altname)
    def set_from_callsign(self, x):
    	c,n = x.split(": ")
    	self.altcode = long(c)
    	self.altname = n

    __swig_destroy__ = _core.delete_Component
    __del__ = lambda self : None;
Component_swigregister = _core.Component_swigregister
Component_swigregister(Component)

def Component_Create(*args) -> "elm::InputStorage" :
  return _core.Component_Create(*args)
Component_Create = _core.Component_Create

class ComponentVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.ComponentVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.ComponentVector___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.ComponentVector___bool__(self)
    def __len__(self) -> "std::vector< elm::InputStorage >::size_type" : return _core.ComponentVector___len__(self)
    def pop(self) -> "std::vector< elm::InputStorage >::value_type" : return _core.ComponentVector_pop(self)
    def __getslice__(self, *args) -> "std::vector< elm::InputStorage,std::allocator< elm::InputStorage > > *" : return _core.ComponentVector___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _core.ComponentVector___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _core.ComponentVector___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.ComponentVector___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< elm::InputStorage >::value_type const &" : return _core.ComponentVector___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.ComponentVector___setitem__(self, *args)
    def append(self, *args) -> "void" : return _core.ComponentVector_append(self, *args)
    def empty(self) -> "bool" : return _core.ComponentVector_empty(self)
    def size(self) -> "std::vector< elm::InputStorage >::size_type" : return _core.ComponentVector_size(self)
    def clear(self) -> "void" : return _core.ComponentVector_clear(self)
    def swap(self, *args) -> "void" : return _core.ComponentVector_swap(self, *args)
    def get_allocator(self) -> "std::vector< elm::InputStorage >::allocator_type" : return _core.ComponentVector_get_allocator(self)
    def begin(self) -> "std::vector< elm::InputStorage >::iterator" : return _core.ComponentVector_begin(self)
    def end(self) -> "std::vector< elm::InputStorage >::iterator" : return _core.ComponentVector_end(self)
    def rbegin(self) -> "std::vector< elm::InputStorage >::reverse_iterator" : return _core.ComponentVector_rbegin(self)
    def rend(self) -> "std::vector< elm::InputStorage >::reverse_iterator" : return _core.ComponentVector_rend(self)
    def pop_back(self) -> "void" : return _core.ComponentVector_pop_back(self)
    def erase(self, *args) -> "std::vector< elm::InputStorage >::iterator" : return _core.ComponentVector_erase(self, *args)
    def __init__(self, *args): 
        this = _core.new_ComponentVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _core.ComponentVector_push_back(self, *args)
    def front(self) -> "std::vector< elm::InputStorage >::value_type const &" : return _core.ComponentVector_front(self)
    def back(self) -> "std::vector< elm::InputStorage >::value_type const &" : return _core.ComponentVector_back(self)
    def assign(self, *args) -> "void" : return _core.ComponentVector_assign(self, *args)
    def resize(self, *args) -> "void" : return _core.ComponentVector_resize(self, *args)
    def insert(self, *args) -> "void" : return _core.ComponentVector_insert(self, *args)
    def reserve(self, *args) -> "void" : return _core.ComponentVector_reserve(self, *args)
    def capacity(self) -> "std::vector< elm::InputStorage >::size_type" : return _core.ComponentVector_capacity(self)
    __swig_destroy__ = _core.delete_ComponentVector
    __del__ = lambda self : None;
ComponentVector_swigregister = _core.ComponentVector_swigregister
ComponentVector_swigregister(ComponentVector)

COMPONENTLIST_TYPE_UTILITYCA = _core.COMPONENTLIST_TYPE_UTILITYCA
COMPONENTLIST_TYPE_UTILITYCO = _core.COMPONENTLIST_TYPE_UTILITYCO
COMPONENTLIST_TYPE_LOGSUM = _core.COMPONENTLIST_TYPE_LOGSUM
COMPONENTLIST_TYPE_EDGE = _core.COMPONENTLIST_TYPE_EDGE
class ComponentList(ComponentVector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    _receiver_type = _swig_property(_core.ComponentList__receiver_type_get, _core.ComponentList__receiver_type_set)
    parentmodel = _swig_property(_core.ComponentList_parentmodel_get, _core.ComponentList_parentmodel_set)
    def __init__(self, type : 'int'=0, parentmodel : 'Model2'=None): 
        this = _core.new_ComponentList(type, parentmodel)
        try: self.this.append(this)
        except: self.this = this
    def receive_utility_ca(self, *args, **kwargs) -> "void" : return _core.ComponentList_receive_utility_ca(self, *args, **kwargs)
    def receive_utility_co(self, *args) -> "void" : return _core.ComponentList_receive_utility_co(self, *args)
    def receive_utility_co_kwd(self, *args, **kwargs) -> "void" : return _core.ComponentList_receive_utility_co_kwd(self, *args, **kwargs)
    def __repr__(self) -> "std::string" : return _core.ComponentList___repr__(self)
    def needs(self) -> "std::vector< std::string,std::allocator< std::string > >" : return _core.ComponentList_needs(self)
    __swig_destroy__ = _core.delete_ComponentList
    __del__ = lambda self : None;
ComponentList_swigregister = _core.ComponentList_swigregister
ComponentList_swigregister(ComponentList)

class ComponentCellcodeMap(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    _receiver_type = _swig_property(_core.ComponentCellcodeMap__receiver_type_get, _core.ComponentCellcodeMap__receiver_type_set)
    parentmodel = _swig_property(_core.ComponentCellcodeMap_parentmodel_get, _core.ComponentCellcodeMap_parentmodel_set)
    def __init__(self, type : 'int'=0, parentmodel : 'Model2'=None): 
        this = _core.new_ComponentCellcodeMap(type, parentmodel)
        try: self.this.append(this)
        except: self.this = this
    def __repr__(self) -> "std::string" : return _core.ComponentCellcodeMap___repr__(self)
    def size(self) -> "unsigned int" : return _core.ComponentCellcodeMap_size(self)
    def empty(self) -> "bool" : return _core.ComponentCellcodeMap_empty(self)
    def clear(self) -> "void" : return _core.ComponentCellcodeMap_clear(self)
    def __getitem__(self, *args) -> "elm::InputStorage &" : return _core.ComponentCellcodeMap___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.ComponentCellcodeMap___setitem__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.ComponentCellcodeMap___delitem__(self, *args)
    def __contains__(self, *args) -> "bool" : return _core.ComponentCellcodeMap___contains__(self, *args)
    def __len__(self) -> "int" : return _core.ComponentCellcodeMap___len__(self)
    def _create(self, *args) -> "void" : return _core.ComponentCellcodeMap__create(self, *args)
    def _link(self, *args) -> "void" : return _core.ComponentCellcodeMap__link(self, *args)
    __swig_destroy__ = _core.delete_ComponentCellcodeMap
    __del__ = lambda self : None;
ComponentCellcodeMap_swigregister = _core.ComponentCellcodeMap_swigregister
ComponentCellcodeMap_swigregister(ComponentCellcodeMap)

class ComponentListPair(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    descrip = _swig_property(_core.ComponentListPair_descrip_get, _core.ComponentListPair_descrip_set)
    ca = _swig_property(_core.ComponentListPair_ca_get, _core.ComponentListPair_ca_set)
    co = _swig_property(_core.ComponentListPair_co_get, _core.ComponentListPair_co_set)
    def __init__(self, type1 : 'int'=0, type2 : 'int'=0, descrip : 'std::string'="", parentmodel : 'Model2'=None): 
        this = _core.new_ComponentListPair(type1, type2, descrip, parentmodel)
        try: self.this.append(this)
        except: self.this = this
    def __call__(self, *args) -> "void" : return _core.ComponentListPair___call__(self, *args)
    def clean(self, *args) -> "void" : return _core.ComponentListPair_clean(self, *args)
    __swig_destroy__ = _core.delete_ComponentListPair
    __del__ = lambda self : None;
ComponentListPair_swigregister = _core.ComponentListPair_swigregister
ComponentListPair_swigregister(ComponentListPair)

class ComponentEdgeMap(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    _receiver_type = _swig_property(_core.ComponentEdgeMap__receiver_type_get, _core.ComponentEdgeMap__receiver_type_set)
    parentmodel = _swig_property(_core.ComponentEdgeMap_parentmodel_get, _core.ComponentEdgeMap_parentmodel_set)
    def __init__(self, parentmodel : 'Model2'=None): 
        this = _core.new_ComponentEdgeMap(parentmodel)
        try: self.this.append(this)
        except: self.this = this
    def __repr__(self) -> "std::string" : return _core.ComponentEdgeMap___repr__(self)
    def size(self) -> "unsigned int" : return _core.ComponentEdgeMap_size(self)
    def empty(self) -> "bool" : return _core.ComponentEdgeMap_empty(self)
    def clear(self) -> "void" : return _core.ComponentEdgeMap_clear(self)
    def __getitem__(self, *args) -> "elm::EdgeValue &" : return _core.ComponentEdgeMap___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.ComponentEdgeMap___setitem__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.ComponentEdgeMap___delitem__(self, *args)
    def __contains__(self, *args) -> "bool" : return _core.ComponentEdgeMap___contains__(self, *args)
    def __len__(self) -> "int" : return _core.ComponentEdgeMap___len__(self)
    def __call__(self, *args) -> "void" : return _core.ComponentEdgeMap___call__(self, *args)
    __swig_destroy__ = _core.delete_ComponentEdgeMap
    __del__ = lambda self : None;
ComponentEdgeMap_swigregister = _core.ComponentEdgeMap_swigregister
ComponentEdgeMap_swigregister(ComponentEdgeMap)

class ComponentGraphDNA(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    db = _swig_property(_core.ComponentGraphDNA_db_get, _core.ComponentGraphDNA_db_set)
    nodes = _swig_property(_core.ComponentGraphDNA_nodes_get, _core.ComponentGraphDNA_nodes_set)
    edges = _swig_property(_core.ComponentGraphDNA_edges_get, _core.ComponentGraphDNA_edges_set)
    def __init__(self, *args): 
        this = _core.new_ComponentGraphDNA(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args) -> "bool" : return _core.ComponentGraphDNA___eq__(self, *args)
    def valid(self) -> "bool" : return _core.ComponentGraphDNA_valid(self)
    def node_name(self, *args) -> "std::string" : return _core.ComponentGraphDNA_node_name(self, *args)
    def node_code(self, *args) -> "elm::cellcode" : return _core.ComponentGraphDNA_node_code(self, *args)
    def __repr__(self) -> "std::string" : return _core.ComponentGraphDNA___repr__(self)
    def elemental_codes(self) -> "elm::cellcodeset" : return _core.ComponentGraphDNA_elemental_codes(self)
    def all_node_codes(self) -> "elm::cellcodeset" : return _core.ComponentGraphDNA_all_node_codes(self)
    def nest_node_codes(self) -> "elm::cellcodeset" : return _core.ComponentGraphDNA_nest_node_codes(self)
    def elemental_names(self) -> "std::vector< std::string,std::allocator< std::string > >" : return _core.ComponentGraphDNA_elemental_names(self)
    def all_node_names(self) -> "std::vector< std::string,std::allocator< std::string > >" : return _core.ComponentGraphDNA_all_node_names(self)
    def nest_node_names(self) -> "std::vector< std::string,std::allocator< std::string > >" : return _core.ComponentGraphDNA_nest_node_names(self)
    def dn_node_codes(self, *args) -> "elm::cellcodeset" : return _core.ComponentGraphDNA_dn_node_codes(self, *args)
    def up_node_codes(self, *args) -> "elm::cellcodeset" : return _core.ComponentGraphDNA_up_node_codes(self, *args)
    def chain_dn_node_codes(self, *args) -> "elm::cellcodeset" : return _core.ComponentGraphDNA_chain_dn_node_codes(self, *args)
    def chain_up_node_codes(self, *args) -> "elm::cellcodeset" : return _core.ComponentGraphDNA_chain_up_node_codes(self, *args)
    def node_callsign(self, altcode):
    	try:
    		return "%i: %s"%(altcode, self.node_name(altcode))
    	except LarchError:
    		return "%i: %s"%(altcode, "alt_%i"%(altcode))
    def elemental_callsigns(self):
    	return [self.node_callsign(j) for j in self.elemental_codes()]
    def all_node_callsigns(self):
    	return [self.node_callsign(j) for j in self.all_node_codes()]
    def nest_node_callsigns(self):
    	return [self.node_callsign(j) for j in self.nest_node_codes()]
    def dn_node_callsigns(self,code):
    	return [self.node_callsign(j) for j in self.dn_node_codes(code)]
    def up_node_callsigns(self,code):
    	return [self.node_callsign(j) for j in self.up_node_codes(code)]
    def up_node_candidate_callsigns(self,code):
    	candidates = self.nest_node_codes()
    	candidates -= self.chain_dn_node_codes(code)
    	candidates -= code
    	candidates += 0
    	return [self.node_callsign(j) for j in candidates]
    def dn_node_candidate_callsigns(self,code):
    	candidates = self.all_node_codes()
    	candidates -= 0
    	candidates -= self.chain_up_node_codes(code)
    	candidates -= code
    	return [self.node_callsign(j) for j in candidates]

    __swig_destroy__ = _core.delete_ComponentGraphDNA
    __del__ = lambda self : None;
ComponentGraphDNA_swigregister = _core.ComponentGraphDNA_swigregister
ComponentGraphDNA_swigregister(ComponentGraphDNA)

def __ComponentList__call(self, *args, **kwargs):
	if (self._receiver_type==0):
		raise LarchError("ComponentList improperly initialized")
	elif (self._receiver_type & COMPONENTLIST_TYPE_UTILITYCA):
		self.receive_utility_ca(*args, **kwargs)
	elif (self._receiver_type & COMPONENTLIST_TYPE_UTILITYCO):
		if len(kwargs)>0 and len(args)==0:
			self.receive_utility_co_kwd(**kwargs)
		elif len(kwargs)==0 and len(args)>0:
			if len(args)<2: raise LarchError("ComponentList for co type requires at least two arguments: data and alt")
			self.receive_utility_co(*args)
		else:
			raise LarchError("ComponentList for co type requires all-or-none use of keyword arguments")
	else:
		raise LarchError("ComponentList Not Implemented for type %i list"%self._receiver_type)
	####if self.parentmodel:
	####	self.parentmodel.freshen()
ComponentList.__call__ = __ComponentList__call
del __ComponentList__call
ComponentList.__long_len = ComponentList.__len__
ComponentList.__len__ = lambda self: int(self.__long_len())

def __ComponentCellcodeMap__call(self, nest_name, nest_code=None, param_name="", multiplier=1.0, parent=None, parents=None, children=None):
	if isinstance(nest_name,(int,)) and nest_code is None:
		nest_name, nest_code = "nest%i"%nest_name, nest_name
	if isinstance(nest_name,(int,)) and isinstance(nest_code,(str,)):
		nest_name, nest_code = nest_code, nest_name
	self._create(nest_name, nest_code, param_name, multiplier)
	if parent is not None:
		self._link(parent,nest_code)
	if parents is not None:
		for p in parents: self._link(p,nest_code)
	if children is not None:
		for c in children: self._link(nest_code,c)
	####if self.parentmodel:
	####	self.parentmodel.freshen()
	return self[nest_code]
ComponentCellcodeMap.__call__ = __ComponentCellcodeMap__call
del __ComponentCellcodeMap__call

class model_options_t(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    gradient_diagnostic = _swig_property(_core.model_options_t_gradient_diagnostic_get, _core.model_options_t_gradient_diagnostic_set)
    hessian_diagnostic = _swig_property(_core.model_options_t_hessian_diagnostic_get, _core.model_options_t_hessian_diagnostic_set)
    threads = _swig_property(_core.model_options_t_threads_get, _core.model_options_t_threads_set)
    calc_null_likelihood = _swig_property(_core.model_options_t_calc_null_likelihood_get, _core.model_options_t_calc_null_likelihood_set)
    null_disregards_holdfast = _swig_property(_core.model_options_t_null_disregards_holdfast_get, _core.model_options_t_null_disregards_holdfast_set)
    calc_std_errors = _swig_property(_core.model_options_t_calc_std_errors_get, _core.model_options_t_calc_std_errors_set)
    mute_nan_warnings = _swig_property(_core.model_options_t_mute_nan_warnings_get, _core.model_options_t_mute_nan_warnings_set)
    force_finite_diff_grad = _swig_property(_core.model_options_t_force_finite_diff_grad_get, _core.model_options_t_force_finite_diff_grad_set)
    save_db_hash = _swig_property(_core.model_options_t_save_db_hash_get, _core.model_options_t_save_db_hash_set)
    force_recalculate = _swig_property(_core.model_options_t_force_recalculate_get, _core.model_options_t_force_recalculate_set)
    teardown_after_estimate = _swig_property(_core.model_options_t_teardown_after_estimate_get, _core.model_options_t_teardown_after_estimate_set)
    weight_autorescale = _swig_property(_core.model_options_t_weight_autorescale_get, _core.model_options_t_weight_autorescale_set)
    author = _swig_property(_core.model_options_t_author_get, _core.model_options_t_author_set)
    def __init__(self, threads : 'int'=1, calc_null_likelihood : 'bool'=True, null_disregards_holdfast : 'bool'=True, 
    calc_std_errors : 'bool'=True, gradient_diagnostic : 'int'=0, 
    hessian_diagnostic : 'int'=0, mute_nan_warnings : 'bool'=True, force_finite_diff_grad : 'bool'=False, 
    save_db_hash : 'bool'=False, force_recalculate : 'bool'=False, 
    author : 'std::string'="Chuck Finley", teardown_after_estimate : 'bool'=True, 
    weight_autorescale : 'bool'=True): 
        this = _core.new_model_options_t(threads, calc_null_likelihood, null_disregards_holdfast, calc_std_errors, gradient_diagnostic, 
    hessian_diagnostic, mute_nan_warnings, force_finite_diff_grad, 
    save_db_hash, force_recalculate, author, teardown_after_estimate, weight_autorescale)
        try: self.this.append(this)
        except: self.this = this
    def __call__(self, *args, **kwargs) -> "void" : return _core.model_options_t___call__(self, *args, **kwargs)
    def copy(self, *args) -> "void" : return _core.model_options_t_copy(self, *args)
    def __repr__(self) -> "std::string" : return _core.model_options_t___repr__(self)
    def __str__(self) -> "std::string" : return _core.model_options_t___str__(self)
    def _save_buffer(self) -> "std::string" : return _core.model_options_t__save_buffer(self)
    def __getitem__(self, k):
    	return getattr(self, k)
    def __setitem__(self, k, v):
    	return setattr(self, k, v)
    def _as_dict(self):
    	keys = dir(self)
    	dct = {}
    	for k in keys:
    		if k[0:2]!="__" and k not in ['copy', 'this', 'thisown', '_as_dict']:
    			dct[k] = getattr(self, k)
    	return dct

    __swig_destroy__ = _core.delete_model_options_t
    __del__ = lambda self : None;
model_options_t_swigregister = _core.model_options_t_swigregister
model_options_t_swigregister(model_options_t)

class runstats(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    startTime = _swig_property(_core.runstats_startTime_get, _core.runstats_startTime_set)
    endTime = _swig_property(_core.runstats_endTime_get, _core.runstats_endTime_set)
    iteration = _swig_property(_core.runstats_iteration_get, _core.runstats_iteration_set)
    results = _swig_property(_core.runstats_results_get, _core.runstats_results_set)
    timestamp = _swig_property(_core.runstats_timestamp_get, _core.runstats_timestamp_set)
    def elapsed_time(self) -> "double" : return _core.runstats_elapsed_time(self)
    def runtime_seconds(self) -> "double" : return _core.runstats_runtime_seconds(self)
    def runtime(self) -> "std::string" : return _core.runstats_runtime(self)
    def __init__(self, *args): 
        this = _core.new_runstats(*args)
        try: self.this.append(this)
        except: self.this = this
    def notes(self) -> "std::string" : return _core.runstats_notes(self)
    def write(self, *args) -> "void" : return _core.runstats_write(self, *args)
    def flush(self) -> "void" : return _core.runstats_flush(self)
    def write_result(self, *args) -> "void" : return _core.runstats_write_result(self, *args)
    def __repr__(self) -> "std::string" : return _core.runstats___repr__(self)
    def dictionary(self) -> "PyObject *" : return _core.runstats_dictionary(self)
    def read_from_dictionary(self, *args) -> "void" : return _core.runstats_read_from_dictionary(self, *args)
    __swig_destroy__ = _core.delete_runstats
    __del__ = lambda self : None;
runstats_swigregister = _core.runstats_swigregister
runstats_swigregister(runstats)

class Needs(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _core.Needs_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _core.Needs___nonzero__(self)
    def __bool__(self) -> "bool" : return _core.Needs___bool__(self)
    def __len__(self) -> "std::map< std::string,elm::darray_req >::size_type" : return _core.Needs___len__(self)
    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args) -> "std::map< std::string,elm::darray_req >::mapped_type const &" : return _core.Needs___getitem__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.Needs___delitem__(self, *args)
    def has_key(self, *args) -> "bool" : return _core.Needs_has_key(self, *args)
    def keys(self) -> "PyObject *" : return _core.Needs_keys(self)
    def values(self) -> "PyObject *" : return _core.Needs_values(self)
    def items(self) -> "PyObject *" : return _core.Needs_items(self)
    def __contains__(self, *args) -> "bool" : return _core.Needs___contains__(self, *args)
    def key_iterator(self) -> "swig::SwigPyIterator *" : return _core.Needs_key_iterator(self)
    def value_iterator(self) -> "swig::SwigPyIterator *" : return _core.Needs_value_iterator(self)
    def __setitem__(self, *args) -> "void" : return _core.Needs___setitem__(self, *args)
    def asdict(self) -> "PyObject *" : return _core.Needs_asdict(self)
    def __init__(self, *args): 
        this = _core.new_Needs(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self) -> "bool" : return _core.Needs_empty(self)
    def size(self) -> "std::map< std::string,elm::darray_req >::size_type" : return _core.Needs_size(self)
    def clear(self) -> "void" : return _core.Needs_clear(self)
    def swap(self, *args) -> "void" : return _core.Needs_swap(self, *args)
    def get_allocator(self) -> "std::map< std::string,elm::darray_req >::allocator_type" : return _core.Needs_get_allocator(self)
    def begin(self) -> "std::map< std::string,elm::darray_req >::iterator" : return _core.Needs_begin(self)
    def end(self) -> "std::map< std::string,elm::darray_req >::iterator" : return _core.Needs_end(self)
    def rbegin(self) -> "std::map< std::string,elm::darray_req >::reverse_iterator" : return _core.Needs_rbegin(self)
    def rend(self) -> "std::map< std::string,elm::darray_req >::reverse_iterator" : return _core.Needs_rend(self)
    def count(self, *args) -> "std::map< std::string,elm::darray_req >::size_type" : return _core.Needs_count(self, *args)
    def erase(self, *args) -> "void" : return _core.Needs_erase(self, *args)
    def find(self, *args) -> "std::map< std::string,elm::darray_req >::iterator" : return _core.Needs_find(self, *args)
    def lower_bound(self, *args) -> "std::map< std::string,elm::darray_req >::iterator" : return _core.Needs_lower_bound(self, *args)
    def upper_bound(self, *args) -> "std::map< std::string,elm::darray_req >::iterator" : return _core.Needs_upper_bound(self, *args)
    def __repr__(self):
    	return "<Needs:" + ",".join(["{}({})".format(i,len(j.get_variables())) for i,j in self.items()]) + ">"

    __swig_destroy__ = _core.delete_Needs
    __del__ = lambda self : None;
Needs_swigregister = _core.Needs_swigregister
Needs_swigregister(Needs)

class darray_req(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    dtype = _swig_property(_core.darray_req_dtype_get, _core.darray_req_dtype_set)
    dimty = _swig_property(_core.darray_req_dimty_get, _core.darray_req_dimty_set)
    n_alts = _swig_property(_core.darray_req_n_alts_get, _core.darray_req_n_alts_set)
    contig = _swig_property(_core.darray_req_contig_get, _core.darray_req_contig_set)
    def __init__(self, *args): 
        this = _core.new_darray_req(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_darray_req
    __del__ = lambda self : None;
    def nVars(self) -> "size_t" : return _core.darray_req_nVars(self)
    def nAlts(self) -> "size_t" : return _core.darray_req_nAlts(self)
    def get_variables(self) -> "std::vector< std::string,std::allocator< std::string > > const &" : return _core.darray_req_get_variables(self)
    def set_variables(self, *args) -> "void" : return _core.darray_req_set_variables(self, *args)
    def __str__(self) -> "std::string" : return _core.darray_req___str__(self)
    def __repr__(self) -> "std::string" : return _core.darray_req___repr__(self)
    def satisfied_by(self, *args) -> "int" : return _core.darray_req_satisfied_by(self, *args)
darray_req_swigregister = _core.darray_req_swigregister
darray_req_swigregister(darray_req)


def check_darray(*args) -> "std::string" :
  return _core.check_darray(*args)
check_darray = _core.check_darray
class ParameterList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _core.new_ParameterList(*args)
        try: self.this.append(this)
        except: self.this = this
    def parameter(self, *args, **kwargs) -> "freedom_info &" : return _core.ParameterList_parameter(self, *args, **kwargs)
    def __getitem__(self, *args) -> "freedom_info &" : return _core.ParameterList___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _core.ParameterList___setitem__(self, *args)
    def __delitem__(self, *args) -> "void" : return _core.ParameterList___delitem__(self, *args)
    def __contains__(self, *args) -> "bool" : return _core.ParameterList___contains__(self, *args)
    def _len(self) -> "size_t" : return _core.ParameterList__len(self)
    def values(self, *args) -> "void" : return _core.ParameterList_values(self, *args)
    def zeros(self) -> "PyObject *" : return _core.ParameterList_zeros(self)
    def constraints(self) -> "PyObject *" : return _core.ParameterList_constraints(self)
    def freshen(self) -> "void" : return _core.ParameterList_freshen(self)
    __swig_destroy__ = _core.delete_ParameterList
    __del__ = lambda self : None;
ParameterList_swigregister = _core.ParameterList_swigregister
ParameterList_swigregister(ParameterList)

ParameterList.__len__ = lambda self: int(self._len())

class Parameter(object):
    """
    This object represents a discrete choice model parameter.

    Parameters
    ----------
    name : str
    	The name of the parameter. This name is used both in commands
    	that refer to this parameter, as well as in reports. Generally
    	it is best to choose a short but descriptive name that does
    	not include any special characters, although any unicode string
    	should be acceptable.
    value : float
    	This value represents the current value of the parameter.
    null_value : float
    	This value represents the default value of the parameter, which
    	would be assumed if no information is available. It is generally
    	zero, although for some parameters -- notably the logsum parameters
    	in a nest logit model, but also certain others -- the default value
    	might be one, or some other value.
    holdfast : bool
    	Sets the holdfast attribute. When True, the value of this parameter
    	is held constant during parameter estimation.

    Other Parameters
    ----------------
    initial_value : float
    	The initial value of the parameter. This is where the
    	search algorithm began.
    std_err, robust_std_err : float
    	This is the standard error of the estimate of this parameter. The
    	standard error is derived from the curvature of the log likelihood
    	function at its maximum. The robust standard error of the estimate
    	is derived from the sandwich estimator.
    covariance, robust_covariance : dict
    	These are dictionary with parameter names as keys and floats
    	as values, representing the (robust) covariance between this estimator
    	and the other estimators in the model.

    Notes
    -----
    It is not usually necessary to define the 'other parameters' explicitly.
    The values are normally derived as an outcome of the model estimation
    process, and the ability to set them here is provided to allow
    the save and load methods to accurately
    recreate a model with all attributes intact.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    name = _swig_property(_core.Parameter_name_get, _core.Parameter_name_set)
    value = _swig_property(_core.Parameter_value_get, _core.Parameter_value_set)
    null_value = _swig_property(_core.Parameter_null_value_get, _core.Parameter_null_value_set)
    initial_value = _swig_property(_core.Parameter_initial_value_get, _core.Parameter_initial_value_set)
    std_err = _swig_property(_core.Parameter_std_err_get, _core.Parameter_std_err_set)
    robust_std_err = _swig_property(_core.Parameter_robust_std_err_get, _core.Parameter_robust_std_err_set)
    max_value = _swig_property(_core.Parameter_max_value_get, _core.Parameter_max_value_set)
    min_value = _swig_property(_core.Parameter_min_value_get, _core.Parameter_min_value_set)
    holdfast = _swig_property(_core.Parameter_holdfast_get, _core.Parameter_holdfast_set)
    _covar = _swig_property(_core.Parameter__covar_get, _core.Parameter__covar_set)
    _robust_covar = _swig_property(_core.Parameter__robust_covar_get, _core.Parameter__robust_covar_set)
    def getCovariance(self) -> "PyObject *" : return _core.Parameter_getCovariance(self)
    def setCovariance(self, *args) -> "void" : return _core.Parameter_setCovariance(self, *args)
    def getRobustCovariance(self) -> "PyObject *" : return _core.Parameter_getRobustCovariance(self)
    def setRobustCovariance(self, *args) -> "void" : return _core.Parameter_setRobustCovariance(self, *args)
    def t_stat(self) -> "double" :
        """
        Calculates the t statistic against the null value of the parameter. 

        The t statistic is calculated as value - null_value)/std_err.
        """
        return _core.Parameter_t_stat(self)

    def representation(self, pretty : 'bool'=True) -> "std::string" : return _core.Parameter_representation(self, pretty)
    def __init__(self, *args, **kwargs): 
        """
        __init__(freedom_info self, std::string const & name="", double const & value=0, double const & null_value=0, 
            int const & holdfast=0, double const & initial_value=NAN, double const & std_err=NAN, 
            double const & robust_std_err=NAN, double const & min_value=-INF, 
            double const & max_value=INF, PyObject * covariance=None, PyObject * robust_covariance=None) -> Parameter

        This object represents a discrete choice model parameter.

        Parameters
        ----------
        name : str
        	The name of the parameter. This name is used both in commands
        	that refer to this parameter, as well as in reports. Generally
        	it is best to choose a short but descriptive name that does
        	not include any special characters, although any unicode string
        	should be acceptable.
        value : float
        	This value represents the current value of the parameter.
        null_value : float
        	This value represents the default value of the parameter, which
        	would be assumed if no information is available. It is generally
        	zero, although for some parameters -- notably the logsum parameters
        	in a nest logit model, but also certain others -- the default value
        	might be one, or some other value.
        holdfast : bool
        	Sets the holdfast attribute. When True, the value of this parameter
        	is held constant during parameter estimation.

        Other Parameters
        ----------------
        initial_value : float
        	The initial value of the parameter. This is where the
        	search algorithm began.
        std_err, robust_std_err : float
        	This is the standard error of the estimate of this parameter. The
        	standard error is derived from the curvature of the log likelihood
        	function at its maximum. The robust standard error of the estimate
        	is derived from the sandwich estimator.
        covariance, robust_covariance : dict
        	These are dictionary with parameter names as keys and floats
        	as values, representing the (robust) covariance between this estimator
        	and the other estimators in the model.

        Notes
        -----
        It is not usually necessary to define the 'other parameters' explicitly.
        The values are normally derived as an outcome of the model estimation
        process, and the ability to set them here is provided to allow
        the save and load methods to accurately
        recreate a model with all attributes intact.
        """
        this = _core.new_Parameter(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_Parameter
    __del__ = lambda self : None;
    def update(self, *args) -> "void" : return _core.Parameter_update(self, *args)
    def __str__(self, z : 'void *'=None) -> "std::string" : return _core.Parameter___str__(self, z)
    def __repr__(self, z : 'void *'=None) -> "std::string" : return _core.Parameter___repr__(self, z)
    covariance = _swig_property(getCovariance, setCovariance)
    robust_covariance = _swig_property(getRobustCovariance, setRobustCovariance)
    def __getitem__(self, *arg):
    	return self.__getattribute__(*arg)

    def t_stat_signif(self, df=None):
    	'''Calulates the significance level of the t-test.
    	
    	When df is not given, the reported value is calculated as
    	:math:`2(1-\Phi(t))`, with :math:`\Phi(t)` as the CDF of a the standard
    	normal distribution evaluated at :math:`t`. When df is given, the
    	t distribution with the indicated number of degrees of freedom is
    	used in place of the normal diatribution. In most discrete choice modeling
    	scenarios, the number of degrees of freedom is large enough that the
    	resulting values are indistinguishable.
    	'''
    	import scipy.stats
    	t = self.t_stat()
    	if df is None:
    		return 2.0*scipy.stats.norm.sf(abs(t), loc=0, scale=1)
    	return 2.0*scipy.stats.t.sf(abs(t), df, loc=0, scale=1)

Parameter_swigregister = _core.Parameter_swigregister
Parameter_swigregister(Parameter)


def algorithm_name(*args) -> "std::string" :
  return _core.algorithm_name(*args)
algorithm_name = _core.algorithm_name
class sherpa_result(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    starting_obj_value = _swig_property(_core.sherpa_result_starting_obj_value_get, _core.sherpa_result_starting_obj_value_set)
    best_obj_value = _swig_property(_core.sherpa_result_best_obj_value_get, _core.sherpa_result_best_obj_value_set)
    result = _swig_property(_core.sherpa_result_result_get, _core.sherpa_result_result_set)
    explain_stop = _swig_property(_core.sherpa_result_explain_stop_get, _core.sherpa_result_explain_stop_set)
    def __init__(self): 
        this = _core.new_sherpa_result()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _core.delete_sherpa_result
    __del__ = lambda self : None;
sherpa_result_swigregister = _core.sherpa_result_swigregister
sherpa_result_swigregister(sherpa_result)

class sherpa(ParameterList):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def LL(self) -> "double" : return _core.sherpa_LL(self)
    max_iterations = _swig_property(_core.sherpa_max_iterations_get, _core.sherpa_max_iterations_set)
    def covariance_matrix(self) -> "etk::symmetric_matrix *" : return _core.sherpa_covariance_matrix(self)
    def robust_covariance_matrix(self) -> "etk::symmetric_matrix *" : return _core.sherpa_robust_covariance_matrix(self)
    def __init__(self, *args): 
        this = _core.new_sherpa(*args)
        try: self.this.append(this)
        except: self.this = this
    def any_holdfast(self) -> "bool" : return _core.sherpa_any_holdfast(self)
    def count_holdfast(self) -> "size_t" : return _core.sherpa_count_holdfast(self)
    def hessfull_to_hessfree(self, *args) -> "void" : return _core.sherpa_hessfull_to_hessfree(self, *args)
    def hessfree_to_hessfull(self, *args) -> "void" : return _core.sherpa_hessfree_to_hessfull(self, *args)
    __swig_destroy__ = _core.delete_sherpa
    __del__ = lambda self : None;
sherpa_swigregister = _core.sherpa_swigregister
sherpa_swigregister(sherpa)

class Model2(sherpa):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def CoefUtilityCA(self) -> "PyObject *" : return _core.Model2_CoefUtilityCA(self)
    def CoefUtilityCO(self) -> "PyObject *" : return _core.Model2_CoefUtilityCO(self)
    def needs(self) -> "std::map< std::string,elm::darray_req,std::less< std::string >,std::allocator< std::pair< std::string const,elm::darray_req > > >" :
        val = _core.Model2_needs(self)
        temp = {}
        for i,j in val.items(): temp[i] = j
        val = temp


        return val

    def provision(self, *args) -> "void" :
        if len(args)==0 and hasattr(self,'db') and isinstance(self.db,DB):
        	args = (self.db.provision(self.needs()), )


        return _core.Model2_provision(self, *args)

    def is_provisioned(self, ex : 'bool'=True) -> "int" : return _core.Model2_is_provisioned(self, ex)
    def Data(self, *args) -> "elm::darray const *" : return _core.Model2_Data(self, *args)
    def calc_utility(self, *args) -> "std::shared_ptr< etk::ndarray >" : return _core.Model2_calc_utility(self, *args)
    def calc_probability(self, *args) -> "std::shared_ptr< etk::ndarray >" : return _core.Model2_calc_probability(self, *args)
    def calc_logsums(self, *args) -> "std::shared_ptr< etk::ndarray >" : return _core.Model2_calc_logsums(self, *args)
    def calc_utility_probability(self, *args) -> "std::shared_ptr< etk::ndarray >" : return _core.Model2_calc_utility_probability(self, *args)
    def calc_utility_logsums(self, *args) -> "std::shared_ptr< etk::ndarray >" : return _core.Model2_calc_utility_logsums(self, *args)
    def probability(self, params : 'etk::ndarray *'=None) -> "etk::ndarray *" : return _core.Model2_probability(self, params)
    hessian_matrix = _swig_property(_core.Model2_hessian_matrix_get, _core.Model2_hessian_matrix_set)
    def utilityca(self, *args) -> "void" : return _core.Model2_utilityca(self, *args)
    def utilityco(self, *args) -> "void" : return _core.Model2_utilityco(self, *args)
    utility = _swig_property(_core.Model2_utility_get, _core.Model2_utility_set)
    Input_QuantityCA = _swig_property(_core.Model2_Input_QuantityCA_get, _core.Model2_Input_QuantityCA_set)
    nest = _swig_property(_core.Model2_nest_get, _core.Model2_nest_set)
    link = _swig_property(_core.Model2_link_get, _core.Model2_link_set)
    samplingbias = _swig_property(_core.Model2_samplingbias_get, _core.Model2_samplingbias_set)
    def Input_Graph(self) -> "elm::ComponentGraphDNA" : return _core.Model2_Input_Graph(self)
    def logger(self, l : 'PyObject *'=None) -> "PyObject *" : return _core.Model2_logger(self, l)
    _string_sender_ptr = _swig_property(_core.Model2__string_sender_ptr_get, _core.Model2__string_sender_ptr_set)
    option = _swig_property(_core.Model2_option_get, _core.Model2_option_set)
    def estimate(self, *args) -> "elm::runstats" :
        if self._ref_to_db is not None and self.is_provisioned(False)==0:
        	self.provision()
        	self.setUpMessage = "autoprovision yes (estimate)"
        	if self.logger(): self.logger().info("autoprovisioned data from database")


        return _core.Model2_estimate(self, *args)

    def estimate_tight(self, magnitude : 'double'=8) -> "elm::runstats" : return _core.Model2_estimate_tight(self, magnitude)
    def _get_parameter(self) -> "PyObject *" : return _core.Model2__get_parameter(self)
    def _get_nest(self) -> "PyObject *" : return _core.Model2__get_nest(self)
    def _get_link(self) -> "PyObject *" : return _core.Model2__get_link(self)
    def _get_utilityca(self) -> "PyObject *" : return _core.Model2__get_utilityca(self)
    def _get_utilityco(self) -> "PyObject *" : return _core.Model2__get_utilityco(self)
    def _get_samplingbiasca(self) -> "PyObject *" : return _core.Model2__get_samplingbiasca(self)
    def _get_samplingbiasco(self) -> "PyObject *" : return _core.Model2__get_samplingbiasco(self)
    def _get_logger(self) -> "PyObject *" : return _core.Model2__get_logger(self)
    def _get_estimation_statistics(self) -> "PyObject *" : return _core.Model2__get_estimation_statistics(self)
    def _get_estimation_run_statistics(self) -> "PyObject *" : return _core.Model2__get_estimation_run_statistics(self)
    def _set_estimation_statistics(self, *args, **kwargs) -> "void" : return _core.Model2__set_estimation_statistics(self, *args, **kwargs)
    def _set_estimation_run_statistics(self, startTimeSec : 'long const &'=0, startTimeUSec : 'long const &'=0, endTimeSec : 'long const &'=0, 
    endTimeUSec : 'long const &'=0, iteration : 'unsigned int const &'=0, 
    results : 'std::string const &'="", notes : 'std::string const &'="") -> "void" : return _core.Model2__set_estimation_run_statistics(self, startTimeSec, startTimeUSec, endTimeSec, endTimeUSec, iteration, results, notes)
    def prints(self, precision : 'unsigned int const &'=5, cell_width : 'unsigned int const &'=11) -> "std::string" : return _core.Model2_prints(self, precision, cell_width)
    def full_report(self, precision : 'unsigned int const &'=5, cell_width : 'unsigned int const &'=11) -> "std::string" : return _core.Model2_full_report(self, precision, cell_width)
    def __repr__(self) -> "std::string" : return _core.Model2___repr__(self)
    def __init__(self, *args): 
        this = _core.new_Model2(*args)
        try: self.this.append(this)
        except: self.this = this
        try:
        	self._ref_to_db = args[0]
        except IndexError:
        	self._ref_to_db = None



    __swig_destroy__ = _core.delete_Model2
    __del__ = lambda self : None;
    def change_data_pointer(self, *args) -> "void" :
        val = _core.Model2_change_data_pointer(self, *args)
        try:
        	self._ref_to_db = args[0]
        except IndexError:
        	self._ref_to_db = None


        return val

    def delete_data_pointer(self) -> "void" :
        val = _core.Model2_delete_data_pointer(self)
        self._ref_to_db = None


        return val

    def setUp(self, and_load_data : 'bool'=True) -> "void" :
        if self._ref_to_db is not None and self.is_provisioned(False)==0:
        	self.provision()
        	self.setUpMessage = "autoprovision yes (setUp)"
        	if self.logger(): self.logger().info("autoprovisioned data from database")


        return _core.Model2_setUp(self, and_load_data)

    setUpMessage = _swig_property(_core.Model2_setUpMessage_get, _core.Model2_setUpMessage_set)
    def tearDown(self) -> "void" : return _core.Model2_tearDown(self)
    title = _swig_property(_core.Model2_title_get, _core.Model2_title_set)
    def save_buffer(self) -> "std::string" : return _core.Model2_save_buffer(self)
    def simulate_probability(self, *args) -> "void" : return _core.Model2_simulate_probability(self, *args)
    def simulate_choices(self, *args) -> "void" : return _core.Model2_simulate_choices(self, *args)
    @staticmethod
    def Example(n=1, db=None):
    	from . import examples
    	examples.load_example(n)
    	if db is None:
    		m = examples.model(examples.data())
    	else:
    		m = examples.model(db)
    	return m
              

    def Utility(self) -> "etk::ndarray *" : return _core.Model2_Utility(self)
    def Probability(self) -> "etk::ndarray *" : return _core.Model2_Probability(self)
    def Cond_Prob(self) -> "etk::ndarray *" : return _core.Model2_Cond_Prob(self)
    def Allocation(self) -> "etk::ndarray *" : return _core.Model2_Allocation(self)
    def GammaZ(self) -> "etk::ndarray *" : return _core.Model2_GammaZ(self)
    def CaseLogLike(self) -> "etk::ndarray *" : return _core.Model2_CaseLogLike(self)
    def SamplingWeight(self) -> "etk::ndarray *" : return _core.Model2_SamplingWeight(self)
    def AdjProbability(self) -> "etk::ndarray *" : return _core.Model2_AdjProbability(self)
    def nAlts(self) -> "unsigned long long" : return _core.Model2_nAlts(self)
    def nCases(self) -> "unsigned long long" : return _core.Model2_nCases(self)
    def alternative_names(self) -> "std::vector< std::string,std::allocator< std::string > >" : return _core.Model2_alternative_names(self)
    def alternative_codes(self) -> "std::vector< long long,std::allocator< long long > >" : return _core.Model2_alternative_codes(self)
    def parameter_values(self, *args) -> "void" : return _core.Model2_parameter_values(self, *args)
    def loglike(self, *args) -> "double" : return _core.Model2_loglike(self, *args)
    def d_loglike(self, *args) -> "std::vector< double,std::allocator< double > >" : return _core.Model2_d_loglike(self, *args)
    def d2_loglike(self, *args) -> "void" : return _core.Model2_d2_loglike(self, *args)
    def negative_loglike(self, *args) -> "double" : return _core.Model2_negative_loglike(self, *args)
    def negative_d_loglike(self, *args) -> "std::vector< double,std::allocator< double > >" : return _core.Model2_negative_d_loglike(self, *args)
    def teardown(self) -> "void" : return _core.Model2_teardown(self)
Model2_swigregister = _core.Model2_swigregister
Model2_swigregister(Model2)

from .model import Model



